# objects.py

import pygame
import math
from typing import Tuple, List, Callable, Dict, Optional
from pathlib import Path
import config
from asset_manager import AssetManager
import random

# Core entities imported from entities.core
from entities.core import Weapon, Player, Enemy, Boss, Bullet


# =========================================================
# ê³µí†µ ë² ì´ìŠ¤ í´ë˜ìŠ¤: ì»·ì”¬ íš¨ê³¼ìš©
# =========================================================
class BaseCutsceneEffect:
    """
    ëª¨ë“  ì»·ì”¬ íš¨ê³¼ í´ë˜ìŠ¤ì˜ ê³µí†µ ë² ì´ìŠ¤ í´ë˜ìŠ¤

    ê³µí†µ ê¸°ëŠ¥:
    - í˜ì´ì¦ˆ ê´€ë¦¬ (FADEIN, DISPLAY, DIALOGUE, FADEOUT, DONE)
    - ë°°ê²½ ì´ë¯¸ì§€ ë¡œë”©
    - ëŒ€í™” ì‹œìŠ¤í…œ (íƒ€ì´í•‘ íš¨ê³¼, í´ë¦­ ì§„í–‰)
    - í˜ì´ë“œ ì¸/ì•„ì›ƒ
    - ì´ë²¤íŠ¸ ì²˜ë¦¬
    - í°íŠ¸ ê´€ë¦¬
    """

    # ê³µí†µ í˜ì´ì¦ˆ ìƒìˆ˜
    PHASE_FADEIN = 0
    PHASE_DISPLAY = 1
    PHASE_DIALOGUE = 2
    PHASE_FADEOUT = 3
    PHASE_DONE = 4

    def __init__(self, screen_size: tuple, background_path: str = None,
                 dialogue_after: list = None, sound_manager=None,
                 special_effects: dict = None, scene_id: str = "base_scene"):
        """
        Args:
            screen_size: í™”ë©´ í¬ê¸° (width, height)
            background_path: ë°°ê²½ ì´ë¯¸ì§€ ê²½ë¡œ
            dialogue_after: ëŒ€ì‚¬ ë¦¬ìŠ¤íŠ¸ [{"speaker": "...", "text": "..."}, ...]
            sound_manager: íš¨ê³¼ìŒ ì¬ìƒìš©
            special_effects: íŠ¹ìˆ˜ íš¨ê³¼ ì„¤ì •
            scene_id: ì”¬ ì‹ë³„ì (ë¦¬í”Œë ˆì´ìš©)
        """
        self.screen_size = screen_size
        self.background_path = background_path
        self.dialogue_after = dialogue_after or []
        self.sound_manager = sound_manager
        self.special_effects = special_effects or {}
        self.scene_id = scene_id

        self.is_alive = True
        self.phase = self.PHASE_FADEIN
        self.phase_timer = 0.0

        # í˜ì´ë“œ ì„¤ì •
        self.fadein_duration = 1.5
        self.fadeout_duration = 1.5
        self.fade_alpha = 0.0

        # ë°°ê²½
        self.background = None
        if background_path:
            self._load_background(background_path)

        # ëŒ€í™” ê´€ë ¨
        self.current_dialogue_index = 0
        self.dialogue_text = ""
        self.typing_progress = 0.0
        self.typing_speed = 30.0
        self.waiting_for_click = False

        # ì´ˆìƒí™” ìºì‹œ
        self.portrait_cache = {}

        # í°íŠ¸
        self.fonts = {}

        # ì½œë°±
        self.on_complete = None
        self.on_replay_request = None

    def _load_background(self, path: str, overlay_alpha: int = 0):
        """
        ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ

        Args:
            path: ì´ë¯¸ì§€ ê²½ë¡œ
            overlay_alpha: ì–´ë‘ìš´ ì˜¤ë²„ë ˆì´ ì•ŒíŒŒê°’ (0=ì—†ìŒ, 220=ì–´ë‘¡ê²Œ)
        """
        try:
            img = pygame.image.load(path).convert()
            self.background = pygame.transform.smoothscale(img, self.screen_size)

            if overlay_alpha > 0:
                overlay = pygame.Surface(self.screen_size, pygame.SRCALPHA)
                overlay.fill((0, 0, 0, overlay_alpha))
                self.background.blit(overlay, (0, 0))
        except Exception as e:
            print(f"WARNING: Failed to load background: {path} - {e}")
            self.background = pygame.Surface(self.screen_size)
            self.background.fill((20, 20, 30))

    def set_fonts(self, fonts: dict):
        """í°íŠ¸ ì„¤ì •"""
        self.fonts = fonts

    def _get_portrait(self, speaker: str) -> pygame.Surface:
        """ì´ˆìƒí™” ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸° (ìºì‹œ ì‚¬ìš©)"""
        if speaker in self.portrait_cache:
            return self.portrait_cache[speaker]

        try:
            from mode_configs.config_story_dialogue import CHARACTER_PORTRAITS
            path = CHARACTER_PORTRAITS.get(speaker)
        except ImportError:
            path = None

        if path:
            try:
                img = pygame.image.load(path).convert_alpha()
                target_size = (120, 120)
                img = pygame.transform.smoothscale(img, target_size)
                self.portrait_cache[speaker] = img
                return img
            except Exception as e:
                print(f"WARNING: Failed to load portrait for {speaker}: {e}")

        return None

    def _start_dialogue(self):
        """í˜„ì¬ ëŒ€í™” ì‹œì‘"""
        if self.current_dialogue_index < len(self.dialogue_after):
            self.dialogue_text = self.dialogue_after[self.current_dialogue_index].get("text", "")
            self.typing_progress = 0.0
            self.waiting_for_click = False

    def _update_dialogue(self, dt: float):
        """ëŒ€í™” ì—…ë°ì´íŠ¸ (íƒ€ì´í•‘ íš¨ê³¼)"""
        if self.current_dialogue_index >= len(self.dialogue_after):
            return True  # ëŒ€í™” ì™„ë£Œ

        if not self.waiting_for_click:
            self.typing_progress += dt * self.typing_speed
            if self.typing_progress >= len(self.dialogue_text):
                self.typing_progress = len(self.dialogue_text)
                self.waiting_for_click = True

        return False  # ëŒ€í™” ì§„í–‰ ì¤‘

    def _advance_dialogue(self):
        """ë‹¤ìŒ ëŒ€í™”ë¡œ ì§„í–‰"""
        self.current_dialogue_index += 1
        if self.current_dialogue_index < len(self.dialogue_after):
            self._start_dialogue()
            return False  # ë” ìˆìŒ
        return True  # ëŒ€í™” ì™„ë£Œ

    def _update_fadein(self, dt: float) -> bool:
        """í˜ì´ë“œì¸ ì—…ë°ì´íŠ¸. ì™„ë£Œ ì‹œ True ë°˜í™˜"""
        progress = min(1.0, self.phase_timer / self.fadein_duration)
        self.fade_alpha = progress * 255
        return progress >= 1.0

    def _update_fadeout(self, dt: float) -> bool:
        """í˜ì´ë“œì•„ì›ƒ ì—…ë°ì´íŠ¸. ì™„ë£Œ ì‹œ True ë°˜í™˜"""
        progress = min(1.0, self.phase_timer / self.fadeout_duration)
        self.fade_alpha = 255 * (1.0 - progress)
        return progress >= 1.0

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸ - ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ í™•ì¥"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        if self.phase == self.PHASE_FADEIN:
            if self._update_fadein(dt):
                self._on_fadein_complete()

        elif self.phase == self.PHASE_DIALOGUE:
            self._update_dialogue(dt)

        elif self.phase == self.PHASE_FADEOUT:
            if self._update_fadeout(dt):
                self._on_fadeout_complete()

    def _on_fadein_complete(self):
        """í˜ì´ë“œì¸ ì™„ë£Œ ì‹œ í˜¸ì¶œ - ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ì˜¤ë²„ë¼ì´ë“œ"""
        self.phase = self.PHASE_DISPLAY
        self.phase_timer = 0.0

    def _on_fadeout_complete(self):
        """í˜ì´ë“œì•„ì›ƒ ì™„ë£Œ ì‹œ í˜¸ì¶œ"""
        self.phase = self.PHASE_DONE
        self.is_alive = False
        if self.on_complete:
            self.on_complete()

    def _transition_to_fadeout(self):
        """í˜ì´ë“œì•„ì›ƒìœ¼ë¡œ ì „í™˜"""
        self.phase = self.PHASE_FADEOUT
        self.phase_timer = 0.0

    def _transition_to_dialogue(self):
        """ëŒ€í™” í˜ì´ì¦ˆë¡œ ì „í™˜"""
        self.phase = self.PHASE_DIALOGUE
        self.phase_timer = 0.0
        self._start_dialogue()

    def handle_event(self, event: pygame.event.Event) -> bool:
        """ì´ë²¤íŠ¸ ì²˜ë¦¬ - ê³µí†µ ë¡œì§"""
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            return self._handle_click()

        elif event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_SPACE, pygame.K_RETURN]:
                return self._handle_click()
            elif event.key == pygame.K_ESCAPE:
                self._transition_to_fadeout()
                return True

        return False

    def _handle_click(self) -> bool:
        """í´ë¦­ ì²˜ë¦¬ - ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ í™•ì¥ ê°€ëŠ¥"""
        if self.phase == self.PHASE_DIALOGUE:
            if self.waiting_for_click:
                if self._advance_dialogue():
                    self._transition_to_fadeout()
            else:
                # íƒ€ì´í•‘ ìŠ¤í‚µ
                self.typing_progress = len(self.dialogue_text)
                self.waiting_for_click = True
            return True
        return False

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§ - ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ í™•ì¥"""
        self._render_background(screen)

    def _render_background(self, screen: pygame.Surface):
        """ë°°ê²½ ë Œë”ë§"""
        if self.background:
            bg_copy = self.background.copy()
            if self.fade_alpha < 255:
                bg_copy.set_alpha(int(self.fade_alpha))
            screen.blit(bg_copy, (0, 0))
        else:
            screen.fill((20, 20, 30))

    def _render_dialogue(self, screen: pygame.Surface, box_color: tuple = (20, 30, 40, 220),
                         border_color: tuple = (100, 100, 150), text_color: tuple = (220, 220, 220)):
        """ëŒ€í™”ì°½ ë Œë”ë§ (ì´ˆìƒí™” í¬í•¨)"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return

        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=box_color, border_color=border_color, text_color=text_color,
                           has_portrait=(portrait is not None), portrait=portrait)

    def _render_click_hint(self, screen: pygame.Surface, text: str = "í´ë¦­í•˜ì—¬ ê³„ì†"):
        """í´ë¦­ íŒíŠ¸ ë Œë”ë§"""
        if "small" not in self.fonts:
            return

        alpha = int(128 + 127 * math.sin(pygame.time.get_ticks() / 300))
        hint_surf = self.fonts["small"].render(text, True, (200, 200, 200))
        hint_surf.set_alpha(alpha)
        hint_rect = hint_surf.get_rect(midbottom=(self.screen_size[0] // 2, self.screen_size[1] - 20))
        screen.blit(hint_surf, hint_rect)


# =========================================================
# ê³µí†µ ëŒ€í™”ì°½ ë Œë”ë§ í—¬í¼ í•¨ìˆ˜
# =========================================================
def render_dialogue_box(screen: pygame.Surface, screen_size: tuple, fonts: dict,
                        dialogue: dict, dialogue_text: str, typing_progress: float,
                        waiting_for_click: bool, box_color: tuple = (20, 30, 40, 220),
                        border_color: tuple = (100, 100, 150), text_color: tuple = (220, 220, 220),
                        box_height: int = 150, has_portrait: bool = False, portrait: pygame.Surface = None):
    """
    ê³µí†µ ëŒ€í™”ì°½ ë Œë”ë§ í•¨ìˆ˜

    Args:
        screen: ë Œë”ë§í•  í™”ë©´
        screen_size: (width, height) í™”ë©´ í¬ê¸°
        fonts: {"small": font, "medium": font} í°íŠ¸ ë”•ì…”ë„ˆë¦¬
        dialogue: {"speaker": "...", "text": "..."} ëŒ€í™” ë°ì´í„°
        dialogue_text: ì „ì²´ ëŒ€ì‚¬ í…ìŠ¤íŠ¸
        typing_progress: íƒ€ì´í•‘ ì§„í–‰ë¥  (0~len)
        waiting_for_click: í´ë¦­ ëŒ€ê¸° ì¤‘ ì—¬ë¶€
        box_color: ë°•ìŠ¤ ë°°ê²½ìƒ‰ (R, G, B, A)
        border_color: í…Œë‘ë¦¬ ìƒ‰ìƒ (R, G, B) ë˜ëŠ” (R, G, B, A)
        text_color: ëŒ€ì‚¬ í…ìŠ¤íŠ¸ ìƒ‰ìƒ
        box_height: ë°•ìŠ¤ ë†’ì´
        has_portrait: ì´ˆìƒí™” í‘œì‹œ ì—¬ë¶€
        portrait: ì´ˆìƒí™” Surface (has_portrait=Trueì¼ ë•Œ)
    """
    speaker = dialogue.get("speaker", "") if dialogue else ""

    screen_w, screen_h = screen_size
    box_width = (screen_w - 100) // 2  # ê°€ë¡œ 1/2 í¬ê¸°
    box_x = (screen_w - box_width) // 2  # ì¤‘ì•™ ì •ë ¬
    box_y = screen_h - box_height - 40

    # ë°•ìŠ¤ ë°°ê²½
    box_surf = pygame.Surface((box_width, box_height), pygame.SRCALPHA)
    pygame.draw.rect(box_surf, box_color, (0, 0, box_width, box_height), border_radius=10)

    # í…Œë‘ë¦¬
    border_col = border_color if len(border_color) == 4 else border_color + (200,)
    pygame.draw.rect(box_surf, border_col, (0, 0, box_width, box_height), 2, border_radius=10)
    screen.blit(box_surf, (box_x, box_y))

    # í…ìŠ¤íŠ¸ ì‹œì‘ ìœ„ì¹˜
    text_left_x = box_x + 30
    portrait_width = 0

    # ì´ˆìƒí™” (ì˜µì…˜)
    if has_portrait and portrait:
        portrait_width = 120
        portrait_x = box_x + 15
        portrait_y = box_y + (box_height - portrait_width) // 2
        # ì´ˆìƒí™” ë°°ê²½
        pygame.draw.circle(screen, (30, 30, 40),
                          (portrait_x + portrait_width // 2, portrait_y + portrait_width // 2),
                          portrait_width // 2 + 5)
        # ì´ˆìƒí™” ë§ˆìŠ¤í‚¹ (ì›í˜•)
        mask_surf = pygame.Surface((portrait_width, portrait_width), pygame.SRCALPHA)
        pygame.draw.circle(mask_surf, (255, 255, 255, 255),
                          (portrait_width // 2, portrait_width // 2), portrait_width // 2)
        portrait_copy = portrait.copy()
        portrait_copy = pygame.transform.smoothscale(portrait_copy, (portrait_width, portrait_width))
        portrait_copy.blit(mask_surf, (0, 0), special_flags=pygame.BLEND_RGBA_MIN)
        screen.blit(portrait_copy, (portrait_x, portrait_y))
        text_left_x = portrait_x + portrait_width + 20

    # í™”ì ì´ë¦„
    if speaker and "medium" in fonts:
        try:
            from mode_configs.config_story_dialogue import CHARACTER_COLORS, CHARACTER_NAMES
            name_color = CHARACTER_COLORS.get(speaker, (200, 200, 200))
            name = CHARACTER_NAMES.get(speaker, speaker)
        except ImportError:
            name_color = (200, 200, 200)
            name = speaker

        name_surf = fonts["medium"].render(name, True, name_color)
        screen.blit(name_surf, (text_left_x, box_y + 15))

    # ëŒ€ì‚¬ í…ìŠ¤íŠ¸ (ì¤„ë°”ê¿ˆ ì²˜ë¦¬)
    if "small" in fonts and dialogue_text:
        visible_text = dialogue_text[:int(typing_progress)]
        # í…ìŠ¤íŠ¸ ì˜ì—­ ë„ˆë¹„ ê³„ì‚°
        text_area_width = box_width - (text_left_x - box_x) - 30
        line_height = fonts["small"].get_height() + 4
        max_lines = 3  # ìµœëŒ€ ì¤„ ìˆ˜

        # í…ìŠ¤íŠ¸ë¥¼ ì¤„ë°”ê¿ˆí•˜ì—¬ ë Œë”ë§
        lines = []
        current_line = ""
        for char in visible_text:
            test_line = current_line + char
            test_width = fonts["small"].size(test_line)[0]
            if test_width > text_area_width and current_line:
                lines.append(current_line)
                current_line = char
            else:
                current_line = test_line
        if current_line:
            lines.append(current_line)

        # ìµœëŒ€ ì¤„ ìˆ˜ ì œí•œ
        lines = lines[:max_lines]

        # ê° ì¤„ ë Œë”ë§
        for i, line in enumerate(lines):
            text_surf = fonts["small"].render(line, True, text_color)
            screen.blit(text_surf, (text_left_x, box_y + 55 + i * line_height))

    # í´ë¦­ ì•ˆë‚´
    if waiting_for_click and "small" in fonts:
        hint = fonts["small"].render("â–¼", True, (150, 150, 150))
        screen.blit(hint, (box_x + box_width - 50, box_y + box_height - 35))

    return box_x, box_y, box_width, box_height  # í•„ìš”ì‹œ ë°˜í™˜

# =========================================================
# 0. Weapon í´ë˜ìŠ¤ (ë¬´ê¸° ë¡œì§)
# =========================================================
class Weapon:
    def __init__(self, damage: float, cooldown: float, bullet_count: int, spread_angle: float = 5.0):
        self.damage = damage
        self.cooldown = cooldown
        self.bullet_count = bullet_count
        self.spread_angle = spread_angle
        self.time_since_last_shot = 0.0 # ë°œì‚¬ ì¿¨íƒ€ì„ ì¶”ì 

    def update(self, dt: float):
        """ë¬´ê¸°ì˜ ì¿¨íƒ€ì„ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤."""
        self.time_since_last_shot += dt

    def can_shoot(self) -> bool:
        """í˜„ì¬ ë°œì‚¬ ê°€ëŠ¥í•œì§€ í™•ì¸í•©ë‹ˆë‹¤."""
        return self.time_since_last_shot >= self.cooldown

    def fire(self, start_pos: pygame.math.Vector2, target_pos: pygame.math.Vector2, bullets: List, piercing_state: bool, player=None):
        """
        ì§€ì •ëœ ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ì•Œì„ ë°œì‚¬í•©ë‹ˆë‹¤.
        """
        if not self.can_shoot():
            return

        self.time_since_last_shot = 0.0 # ì¿¨íƒ€ì„ ì´ˆê¸°í™”

        # ëª©í‘œ ë°©í–¥ ë²¡í„° ê³„ì‚°
        direction = target_pos - start_pos
        base_angle = math.atan2(direction.y, direction.x)

        # Berserker ìŠ¤í‚¬: ì €ì²´ë ¥ ì‹œ ë°ë¯¸ì§€ 2ë°°
        bullet_damage = self.damage
        if player and hasattr(player, 'has_berserker') and player.has_berserker:
            if player.hp / player.max_hp < 0.3:
                bullet_damage = int(self.damage * 2.0)

        # ë°œì‚¬ê° ë¶„ì‚° ê³„ì‚°
        for i in range(self.bullet_count):
            if self.bullet_count == 1:
                angle_offset = 0
            else:
                # ì´ì•Œ ìˆ˜ì— ë”°ë¼ ê· ë“±í•˜ê²Œ ê°ë„ë¥¼ ë¶„ì‚°
                angle_spread = self.spread_angle * (self.bullet_count - 1)
                start_offset = -angle_spread / 2
                angle_offset = start_offset + (i * self.spread_angle)

            # ê°ë„ë¥¼ ë¼ë””ì•ˆì—ì„œ ì¿¼í„°ë‹ˆì–¸ (ì´ë™ ë²¡í„°)ë¡œ ë³€í™˜
            new_angle = base_angle + math.radians(angle_offset)
            bullet_direction = pygame.math.Vector2(math.cos(new_angle), math.sin(new_angle)).normalize()

            # ìƒˆ ì´ì•Œ ê°ì²´ ìƒì„± ë° ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
            bullet = Bullet(
                start_pos.copy(),
                bullet_direction,
                bullet_damage,
                piercing_state # í”¼ì–´ì‹± ìƒíƒœë¥¼ Bulletì— ì „ë‹¬
            )
            bullets.append(bullet)

    # ì „ìˆ  ë ˆë²¨ì—…ì„ ìœ„í•œ ë©”ì„œë“œ (utils.pyì—ì„œ í˜¸ì¶œ)
    def increase_damage(self, ratio: float):
        self.damage = int(self.damage * (1 + ratio))
        print(f"INFO: Damage increased to {self.damage}")

    def decrease_cooldown(self, ratio: float):
        self.cooldown = max(0.05, self.cooldown * (1 - ratio))
        print(f"INFO: Cooldown decreased to {self.cooldown:.2f}")

    def add_bullet(self):
        self.bullet_count += 1
        print(f"INFO: Bullet count increased to {self.bullet_count}")

# =========================================================
# 1. ì• ë‹ˆë©”ì´ì…˜/ì´í™íŠ¸ í´ë˜ìŠ¤
# =========================================================

class AnimatedEffect:
    """ì• ë‹ˆë©”ì´ì…˜ì„ ì¬ìƒí•˜ê³  ìŠ¤ìŠ¤ë¡œ ì œê±°ë˜ëŠ” ì´í™íŠ¸ í´ë˜ìŠ¤"""
    def __init__(self, pos: Tuple[int, int], screen_height: int, image_path: Path, object_type_key: str, frame_duration: float = 0.1, total_frames: int = 1):
        self.pos = pygame.math.Vector2(pos)
        self.start_time = pygame.time.get_ticks() / 1000.0
        self.frame_duration = frame_duration
        self.total_frames = total_frames
        self.is_finished = False

        # ì´ë¯¸ì§€ ë¡œë“œ ë° í¬ê¸° ì„¤ì • (config.IMAGE_SIZE_RATIOS ì‚¬ìš©)
        size_ratio = config.IMAGE_SIZE_RATIOS.get(object_type_key, 0.03) # ê¸°ë³¸ê°’ 0.03
        image_height = int(screen_height * size_ratio)

        # ì´ë¯¸ì§€ í¬ê¸°ëŠ” ì´í™íŠ¸ ì¢…ë¥˜ì— ë”°ë¼ ì¡°ì • ê°€ëŠ¥í•˜ë„ë¡ í•¨
        self.image = AssetManager.get_image(image_path, (image_height, image_height))
        self.image_rect = self.image.get_rect(center=(self.pos.x, self.pos.y))

    def update(self, dt: float, current_time: float):
        """ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤."""

        elapsed_time = current_time - self.start_time

        # ë‹¨ì¼ í”„ë ˆì„ ì´í™íŠ¸ì´ë¯€ë¡œ ë°”ë¡œ ì¢…ë£Œ
        if elapsed_time > self.frame_duration * self.total_frames:
             self.is_finished = True

    def draw(self, screen: pygame.Surface):
        """í˜„ì¬ í”„ë ˆì„ì˜ ì´ë¯¸ì§€ë¥¼ í™”ë©´ì— ê·¸ë¦½ë‹ˆë‹¤."""
        if not self.is_finished:
            screen.blit(self.image, self.image_rect)


class DamageNumber:
    """ë°ë¯¸ì§€ ìˆ«ìë¥¼ í‘œì‹œí•˜ëŠ” í´ë˜ìŠ¤ (ëˆ„ì  ë°ë¯¸ì§€ ì§€ì›)"""

    # ë°ë¯¸ì§€ í¬ê¸°ì— ë”°ë¥¸ í°íŠ¸/ìƒ‰ìƒ ì„¤ì •
    DAMAGE_TIERS = {
        "small": {"threshold": 0, "font_size": 20, "color": (200, 200, 200), "lifetime": 0.8},
        "normal": {"threshold": 30, "font_size": 26, "color": (255, 255, 100), "lifetime": 1.2},
        "big": {"threshold": 100, "font_size": 34, "color": (255, 180, 50), "lifetime": 1.5},
        "huge": {"threshold": 300, "font_size": 44, "color": (255, 100, 50), "lifetime": 2.0},
        "massive": {"threshold": 1000, "font_size": 56, "color": (255, 50, 50), "lifetime": 2.5},
    }

    def __init__(self, damage: float, pos: Tuple[float, float], is_accumulated: bool = False,
                 is_critical: bool = False, font: pygame.font.Font = None):
        self.damage = int(damage)
        self.pos = pygame.math.Vector2(pos)
        self.start_time = pygame.time.get_ticks() / 1000.0
        self.is_finished = False
        self.is_accumulated = is_accumulated  # ëˆ„ì  ë°ë¯¸ì§€ ì—¬ë¶€
        self.is_critical = is_critical

        # ë°ë¯¸ì§€ í‹°ì–´ ê²°ì •
        self.tier = self._get_damage_tier()
        tier_data = self.DAMAGE_TIERS[self.tier]

        # ëˆ„ì  ë°ë¯¸ì§€ëŠ” ë” í¬ê²Œ í‘œì‹œ
        font_size = tier_data["font_size"]
        if is_accumulated:
            font_size = int(font_size * 1.3)

        self.lifetime = tier_data["lifetime"]
        self.color = tier_data["color"]

        # í¬ë¦¬í‹°ì»¬ì€ ë¹¨ê°„ìƒ‰
        if is_critical:
            self.color = (255, 50, 100)
            font_size = int(font_size * 1.2)

        # í°íŠ¸ ì„¤ì •
        if font is None:
            self.font = pygame.font.Font(None, font_size)
        else:
            self.font = font

        # ì´ˆê¸° ìŠ¤ì¼€ì¼ (íŒì—… íš¨ê³¼ìš©)
        self.scale = 1.5 if is_accumulated else 1.0
        self.target_scale = 1.0

        # í…ìŠ¤íŠ¸ ë Œë”ë§
        self._render_text()

        # ëœë¤ ì˜¤í”„ì…‹ (ê²¹ì¹¨ ë°©ì§€)
        self.offset_x = random.uniform(-15, 15) if not is_accumulated else 0
        self.pos.x += self.offset_x

        # ìœ„ë¡œ ë– ì˜¤ë¥´ëŠ” ì†ë„ (ëˆ„ì ì€ ë” ëŠë¦¬ê²Œ)
        self.rise_speed = 30 if is_accumulated else 60

    def _get_damage_tier(self) -> str:
        """ë°ë¯¸ì§€ í¬ê¸°ì— ë”°ë¥¸ í‹°ì–´ ë°˜í™˜"""
        tier = "small"
        for tier_name, data in self.DAMAGE_TIERS.items():
            if self.damage >= data["threshold"]:
                tier = tier_name
        return tier

    def _render_text(self):
        """í…ìŠ¤íŠ¸ ë Œë”ë§ (ìŠ¤ì¼€ì¼ ì ìš©)"""
        # ëˆ„ì  ë°ë¯¸ì§€ëŠ” ! ì¶”ê°€
        display_text = f"{self.damage}!" if self.is_accumulated else str(self.damage)

        # ê¸°ë³¸ í…ìŠ¤íŠ¸
        base_text = self.font.render(display_text, True, self.color)

        # ìŠ¤ì¼€ì¼ ì ìš©
        if self.scale != 1.0:
            new_size = (int(base_text.get_width() * self.scale),
                       int(base_text.get_height() * self.scale))
            self.text = pygame.transform.smoothscale(base_text, new_size)
        else:
            self.text = base_text

        self.text_rect = self.text.get_rect(center=(self.pos.x, self.pos.y))

    def update(self, dt: float, current_time: float):
        """ë°ë¯¸ì§€ ìˆ«ìë¥¼ ìœ„ë¡œ ì´ë™ì‹œí‚¤ê³  í˜ì´ë“œ ì•„ì›ƒ"""
        elapsed_time = current_time - self.start_time

        if elapsed_time >= self.lifetime:
            self.is_finished = True
            return

        # ìŠ¤ì¼€ì¼ ì• ë‹ˆë©”ì´ì…˜ (íŒì—… íš¨ê³¼)
        if self.scale > self.target_scale:
            self.scale = max(self.target_scale, self.scale - dt * 3)
            self._render_text()

        # ìœ„ë¡œ ë– ì˜¤ë¦„
        self.pos.y -= self.rise_speed * dt
        self.text_rect.center = (self.pos.x, self.pos.y)

        # í˜ì´ë“œ ì•„ì›ƒ (í›„ë°˜ë¶€ì—ë§Œ)
        fade_start = self.lifetime * 0.6
        if elapsed_time > fade_start:
            alpha = int(255 * (1 - (elapsed_time - fade_start) / (self.lifetime - fade_start)))
            self.text.set_alpha(max(0, alpha))

    def draw(self, screen: pygame.Surface):
        """ë°ë¯¸ì§€ ìˆ«ìë¥¼ í™”ë©´ì— ê·¸ë¦½ë‹ˆë‹¤."""
        if not self.is_finished:
            screen.blit(self.text, self.text_rect)


class DamageNumberManager:
    """
    ë°ë¯¸ì§€ ìˆ«ì ê´€ë¦¬ì - ëˆ„ì  ì‹œìŠ¤í…œ

    ë™ì‘ ë°©ì‹:
    1. ê°™ì€ ëŒ€ìƒ(ì )ì—ê²Œ ì¼ì • ì‹œê°„(accumulate_window) ë‚´ ë°œìƒí•œ ë°ë¯¸ì§€ ëˆ„ì 
    2. ëˆ„ì  ì‹œê°„ì´ ì§€ë‚˜ë©´ í° ìˆ«ìë¡œ í•œë²ˆì— í‘œì‹œ
    3. ê°œë³„ ì‘ì€ í‹± ë°ë¯¸ì§€ëŠ” ì„ íƒì ìœ¼ë¡œ í‘œì‹œ ê°€ëŠ¥
    """

    def __init__(self, accumulate_window: float = 0.4, show_ticks: bool = False,
                 max_numbers: int = 15):
        """
        Args:
            accumulate_window: ë°ë¯¸ì§€ ëˆ„ì  ì‹œê°„ (ì´ˆ)
            show_ticks: ê°œë³„ ì‘ì€ ë°ë¯¸ì§€ë„ í‘œì‹œí• ì§€ ì—¬ë¶€
            max_numbers: í™”ë©´ì— í‘œì‹œí•  ìµœëŒ€ ë°ë¯¸ì§€ ìˆ«ì ìˆ˜
        """
        self.accumulate_window = accumulate_window
        self.show_ticks = show_ticks
        self.max_numbers = max_numbers

        # í™œì„± ë°ë¯¸ì§€ ìˆ«ìë“¤
        self.damage_numbers: List[DamageNumber] = []

        # ëŒ€ìƒë³„ ëˆ„ì  ë°ë¯¸ì§€ {enemy_id: {"damage": total, "pos": last_pos, "start_time": time}}
        self.accumulated_damage: Dict[int, Dict] = {}

    def add_damage(self, damage: float, pos: Tuple[float, float], target_id: int = None,
                   is_critical: bool = False):
        """
        ë°ë¯¸ì§€ ì¶”ê°€

        Args:
            damage: ë°ë¯¸ì§€ ì–‘
            pos: í‘œì‹œ ìœ„ì¹˜
            target_id: ëŒ€ìƒ ì‹ë³„ì (ì—†ìœ¼ë©´ ëˆ„ì  ì•ˆí•¨)
            is_critical: í¬ë¦¬í‹°ì»¬ ì—¬ë¶€
        """
        current_time = pygame.time.get_ticks() / 1000.0

        # ëŒ€ìƒì´ ìˆìœ¼ë©´ ëˆ„ì 
        if target_id is not None:
            if target_id in self.accumulated_damage:
                acc = self.accumulated_damage[target_id]
                acc["damage"] += damage
                acc["pos"] = pos  # ë§ˆì§€ë§‰ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                acc["is_critical"] = acc.get("is_critical", False) or is_critical
            else:
                self.accumulated_damage[target_id] = {
                    "damage": damage,
                    "pos": pos,
                    "start_time": current_time,
                    "is_critical": is_critical,
                }

            # ì‘ì€ í‹± ë°ë¯¸ì§€ í‘œì‹œ (ì„ íƒì )
            if self.show_ticks and damage < 50:
                self._add_tick_damage(damage, pos)
        else:
            # ëŒ€ìƒ ì—†ìœ¼ë©´ ë°”ë¡œ í‘œì‹œ
            self._create_damage_number(damage, pos, is_accumulated=False, is_critical=is_critical)

    def _add_tick_damage(self, damage: float, pos: Tuple[float, float]):
        """ì‘ì€ í‹± ë°ë¯¸ì§€ í‘œì‹œ"""
        # í‹± ë°ë¯¸ì§€ëŠ” ì‘ê³  ë¹ ë¥´ê²Œ ì‚¬ë¼ì§
        dmg_num = DamageNumber(damage, pos, is_accumulated=False)
        dmg_num.lifetime = 0.5
        dmg_num.rise_speed = 80
        self.damage_numbers.append(dmg_num)

    def _create_damage_number(self, damage: float, pos: Tuple[float, float],
                              is_accumulated: bool = False, is_critical: bool = False):
        """ë°ë¯¸ì§€ ìˆ«ì ìƒì„±"""
        dmg_num = DamageNumber(damage, pos, is_accumulated=is_accumulated, is_critical=is_critical)
        self.damage_numbers.append(dmg_num)

        # ìµœëŒ€ ê°œìˆ˜ ì œí•œ
        if len(self.damage_numbers) > self.max_numbers:
            # ê°€ì¥ ì˜¤ë˜ëœ ê²ƒ ì œê±°
            self.damage_numbers = self.damage_numbers[-self.max_numbers:]

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸ - ëˆ„ì  ì‹œê°„ ì²´í¬ ë° ë°ë¯¸ì§€ ìˆ«ì ì—…ë°ì´íŠ¸"""
        current_time = pygame.time.get_ticks() / 1000.0

        # ëˆ„ì  ë°ë¯¸ì§€ í™•ì¸ ë° í‘œì‹œ
        targets_to_remove = []
        for target_id, acc in self.accumulated_damage.items():
            elapsed = current_time - acc["start_time"]

            if elapsed >= self.accumulate_window:
                # ëˆ„ì  ì‹œê°„ ê²½ê³¼ - í° ìˆ«ìë¡œ í‘œì‹œ
                self._create_damage_number(
                    acc["damage"],
                    acc["pos"],
                    is_accumulated=True,
                    is_critical=acc.get("is_critical", False)
                )
                targets_to_remove.append(target_id)

        # í‘œì‹œ ì™„ë£Œëœ ëˆ„ì  ë°ë¯¸ì§€ ì œê±°
        for target_id in targets_to_remove:
            del self.accumulated_damage[target_id]

        # ë°ë¯¸ì§€ ìˆ«ì ì—…ë°ì´íŠ¸
        for dmg_num in self.damage_numbers:
            dmg_num.update(dt, current_time)

        # ì™„ë£Œëœ ìˆ«ì ì œê±°
        self.damage_numbers = [d for d in self.damage_numbers if not d.is_finished]

    def flush_target(self, target_id: int):
        """íŠ¹ì • ëŒ€ìƒì˜ ëˆ„ì  ë°ë¯¸ì§€ ì¦‰ì‹œ í‘œì‹œ (ì  ì‚¬ë§ ì‹œ)"""
        if target_id in self.accumulated_damage:
            acc = self.accumulated_damage[target_id]
            self._create_damage_number(
                acc["damage"],
                acc["pos"],
                is_accumulated=True,
                is_critical=acc.get("is_critical", False)
            )
            del self.accumulated_damage[target_id]

    def draw(self, screen: pygame.Surface):
        """ëª¨ë“  ë°ë¯¸ì§€ ìˆ«ì ê·¸ë¦¬ê¸°"""
        for dmg_num in self.damage_numbers:
            dmg_num.draw(screen)

    def clear(self):
        """ëª¨ë“  ë°ë¯¸ì§€ ìˆ«ì ì´ˆê¸°í™”"""
        self.damage_numbers.clear()
        self.accumulated_damage.clear()


# =========================================================
# 2. í”Œë ˆì´ì–´ í´ë˜ìŠ¤
# =========================================================

class Player:
    """í”Œë ˆì´ì–´ ìš°ì£¼ì„  í´ë˜ìŠ¤"""

    def __init__(self, pos: pygame.math.Vector2, screen_height: int, upgrades: Dict[str, int], ship_type: str = None):
        # 0. ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ ì €ì¥
        self.upgrades = upgrades

        # 0-1. í•¨ì„  íƒ€ì… ì„¤ì •
        self.ship_type = ship_type or config.DEFAULT_SHIP
        self.ship_data = config.SHIP_TYPES.get(self.ship_type, config.SHIP_TYPES[config.DEFAULT_SHIP])
        self.ship_stats = self.ship_data["stats"]

        # 1. ìœ„ì¹˜ ë° ì´ë™
        self.pos = pos
        self.base_speed = config.PLAYER_BASE_SPEED
        self.speed = self.base_speed  # ì‹¤ì œ ì´ë™ ì†ë„ (ì—…ê·¸ë ˆì´ë“œ ì ìš© í›„)

        # 2. ì²´ë ¥ ìŠ¤íƒ¯
        # í”Œë ˆì´ì–´ ì´ˆê¸° ìµœëŒ€ ì²´ë ¥ (ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ ì ìš© ì „)
        self.initial_max_hp = config.PLAYER_BASE_HP

        # ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìŠ¤íƒ¯ ê³„ì‚° (í•¨ì„  ë°°ìœ¨ ì ìš© í¬í•¨)
        self.calculate_stats_from_upgrades()

        # ìµœëŒ€ ì²´ë ¥ (ì „ìˆ  ë ˆë²¨ì—…ìœ¼ë¡œ ì¦ê°€ ê°€ëŠ¥)
        self.max_hp = self.initial_max_hp

        # í˜„ì¬ ì²´ë ¥ (ìµœëŒ€ì¹˜ë¡œ ì‹œì‘)
        self.hp = self.max_hp

        # ì‚¬ë§ í”Œë˜ê·¸ (HPê°€ 0ì´ ëœ ì  ìˆìœ¼ë©´ True, ë¶€í™œ ì‹œ Falseë¡œ ë¦¬ì…‹)
        self.is_dead = False

        # 3. ì´ë¯¸ì§€ ë° íˆíŠ¸ë°•ìŠ¤ (í•¨ì„  í¬ê¸°ì— ë”°ë¼ ì¡°ì •)
        ship_size = self.ship_stats.get("size", "medium")
        size_ratio = config.SHIP_SIZE_RATIOS.get(ship_size, config.IMAGE_SIZE_RATIOS["PLAYER"])
        image_size = int(screen_height * size_ratio)

        # í•¨ì„  ì´ë¯¸ì§€ ë¡œë“œ ì‹œë„
        ship_image_path = config.ASSET_DIR / "images" / "ships" / self.ship_data.get("image", "fighter_front.png")
        if ship_image_path.exists():
            self.image = AssetManager.get_image(ship_image_path, (image_size, image_size))
        else:
            # ê¸°ë³¸ í”Œë ˆì´ì–´ ì´ë¯¸ì§€ ì‚¬ìš©
            self.image = AssetManager.get_image(config.PLAYER_SHIP_IMAGE_PATH, (image_size, image_size))
        self.image_rect = self.image.get_rect(center=(self.pos.x, self.pos.y))

        hitbox_size = int(image_size * config.PLAYER_HITBOX_RATIO)
        self.hitbox = pygame.Rect(0, 0, hitbox_size, hitbox_size)
        self.hitbox.center = (int(self.pos.x), int(self.pos.y))

        # 3-1. ì „ìˆ  ë ˆë²¨ì—… ì†ì„± (ë¬´ê¸°)
        self.is_piercing = False  # ê´€í†µ ì†ì„±

        # 3-2. ì „ìˆ  ë ˆë²¨ì—… ì†ì„± (ì¶”ê°€ ì†ì„±)
        self.has_explosive = False  # í­ë°œ ì†ì„±
        self.explosive_radius = 100.0  # í­ë°œ ë²”ìœ„
        self.has_chain_explosion = False  # ì—°ì‡„ í­ë°œ
        self.has_lightning = False  # ë²ˆê°œ ì†ì„±
        self.lightning_chain_count = 0  # ì—°ì‡„ íšŸìˆ˜
        self.has_static_field = False  # ì •ì „ê¸°ì¥
        self.has_frost = False  # ë¹™ê²° ì†ì„±
        self.frost_slow_ratio = 0.0  # ë‘”í™” ë¹„ìœ¨
        self.has_deep_freeze = False  # ì‹¬í™” ë¹™ê²°
        self.freeze_chance = 0.0  # ë¹™ê²° í™•ë¥ 

        # 3-3. ë°©ì–´ ì†ì„±
        self.damage_reduction = 0.0  # í”¼í•´ ê°ì†Œ ë¹„ìœ¨
        self.regeneration_rate = 0.0  # ì´ˆë‹¹ HP íšŒë³µëŸ‰
        self.last_regen_time = 0.0  # ë§ˆì§€ë§‰ íšŒë³µ ì‹œê°„

        # 3-4. ìœ í‹¸ë¦¬í‹° ì†ì„±
        self.coin_drop_multiplier = 1.0  # ì½”ì¸ ë“œë¡­ ë°°ìœ¨
        self.exp_multiplier = 1.0  # ê²½í—˜ì¹˜ ë°°ìœ¨
        self.has_coin_magnet = False  # ì½”ì¸ ìì„ íš¨ê³¼

        # 3-5. ì§€ì› ìœ ë‹› (ë™ë£Œ ì‹œìŠ¤í…œ)
        self.turret_count = 0  # ë³´ìœ í•œ í„°ë › ìŠ¬ë¡¯ ìˆ˜
        self.pending_turret_placements = 0  # ë°°ì¹˜ ëŒ€ê¸° ì¤‘ì¸ í„°ë › ìˆ˜
        self.drone_count = 0  # ë³´ìœ í•œ ë“œë¡  ìˆ˜

        # 3-6. íšë“í•œ ìŠ¤í‚¬ ì¶”ì  (ìŠ¤í‚¬ ì´ë¦„: íšë“ íšŸìˆ˜)
        self.acquired_skills = {}

        # 3-7. í™œì„±í™”ëœ ì‹œë„ˆì§€ ì¶”ì  (ì‹œë„ˆì§€ íš¨ê³¼ ì´ë¦„ ë¦¬ìŠ¤íŠ¸)
        self.active_synergies = []

        # 3-8. ìŠ¤í‚¬ í™œì„±í™” íƒ€ì„ ì¶”ì  (ìŠ¤í‚¬ UI í‘œì‹œìš©)
        self.skill_last_trigger = {
            'add_explosive': 0.0,
            'add_lightning': 0.0,
            'add_frost': 0.0,
        }

        # 4. ë¬´ê¸° ì´ˆê¸°í™” (í•¨ì„  ë°°ìœ¨ + Workshop ì—…ê·¸ë ˆì´ë“œ ì ìš©)
        damage_mult = self.ship_stats.get("damage_mult", 1.0)
        cooldown_mult = self.ship_stats.get("cooldown_mult", 1.0)

        base_cooldown = config.WEAPON_COOLDOWN_BASE

        # ì˜êµ¬ ì¿¨ë‹¤ìš´ ì—…ê·¸ë ˆì´ë“œ ì ìš©
        cd_level = self.upgrades.get("COOLDOWN", 0)
        cd_reduction_ratio = config.PERMANENT_COOLDOWN_REDUCTION_RATIO * cd_level

        # Workshop FIRE_RATE: -10% cooldown per level
        fire_rate_level = self.upgrades.get("FIRE_RATE", 0)
        workshop_cd_reduction = 0.10 * fire_rate_level

        final_cooldown = base_cooldown * (1 - cd_reduction_ratio - workshop_cd_reduction) * cooldown_mult
        final_cooldown = max(0.05, final_cooldown)  # ìµœì†Œ ì¿¨ë‹¤ìš´ ì œí•œ

        # ë°ë¯¸ì§€ ê³„ì‚°
        base_damage = config.BULLET_DAMAGE_BASE

        # Workshop DAMAGE: +8% per level
        damage_level = self.upgrades.get("DAMAGE", 0)
        if damage_level > 0:
            base_damage = base_damage * (1 + 0.08 * damage_level)

        # ë¬´ê¸° ì¸ìŠ¤í„´ìŠ¤ ìƒì„± (í•¨ì„  ë°ë¯¸ì§€ ë°°ìœ¨ ì ìš©)
        self.weapon = Weapon(
            damage=int(base_damage * damage_mult),
            cooldown=final_cooldown,
            bullet_count=1,
            spread_angle=5.0
        )

        # Workshop PIERCING: +1 penetration per level
        piercing_level = self.upgrades.get("PIERCING", 0)
        if piercing_level > 0:
            self.is_piercing = True

        # 5. íˆíŠ¸ í”Œë˜ì‹œ íš¨ê³¼ ì†ì„±
        self.hit_flash_timer = 0.0  # íˆíŠ¸ í”Œë˜ì‹œ íƒ€ì´ë¨¸
        self.is_flashing = False  # í˜„ì¬ í”Œë˜ì‹œ ì¤‘ì¸ì§€
        self.was_hit_recently = False  # ìµœê·¼ í”¼ê²© ì—¬ë¶€ (CombatMotionEffectìš©)

        # 6. ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥ (íˆíŠ¸ í”Œë˜ì‹œìš©)
        self.original_image = self.image.copy()

        # 7. ê¶ê·¹ê¸° ì‹œìŠ¤í…œ (Q í‚¤)
        self.ultimate_type = "NOVA_BLAST"  # ê¸°ë³¸ ê¶ê·¹ê¸° íƒ€ì…
        self.ultimate_charge = config.ULTIMATE_SETTINGS["charge_time"]  # ê¶ê·¹ê¸° ì¶©ì „ íƒ€ì´ë¨¸
        self.ultimate_cooldown_timer = 0.0  # ê¶ê·¹ê¸° ì¿¨ë‹¤ìš´ íƒ€ì´ë¨¸
        self.ultimate_active = False  # ê¶ê·¹ê¸° í™œì„±í™” ìƒíƒœ
        self.ultimate_timer = 0.0  # ê¶ê·¹ê¸° íš¨ê³¼ ì§€ì† ì‹œê°„
        self.ultimate_effects = []  # ê¶ê·¹ê¸° ì‹œê° íš¨ê³¼ ë¦¬ìŠ¤íŠ¸
        # Time Freezeìš©
        self.time_freeze_active = False
        self.time_freeze_timer = 0.0
        # Orbital Strikeìš©
        self.orbital_strikes = []  # [(target_pos, delay, strike_timer), ...]
        self.orbital_strike_timer = 0.0

        # 9. ê³ ê¸‰ ìŠ¤í‚¬ ì†ì„± (Wave 11-15)
        self.execute_threshold = 0.0  # Execute: ì¦‰ì‚¬ ì²´ë ¥ ì„ê³„ê°’ (0.2 = 20%)
        self.has_phoenix = False  # Phoenix Rebirth: ë¶€í™œ ìŠ¤í‚¬
        self.phoenix_cooldown = 0.0  # Phoenix ì¿¨ë‹¤ìš´ íƒ€ì´ë¨¸ (120ì´ˆ)
        self.has_berserker = False  # Berserker: ì €ì²´ë ¥ ì‹œ ê³µê²©ë ¥ ì¦ê°€
        self.has_starfall = False  # Starfall: í‚¬ë§ˆë‹¤ ë³„ë˜¥ë³„ ì†Œí™˜
        self.starfall_kill_counter = 0  # Starfall í‚¬ ì¹´ìš´í„°
        self.has_arcane_mastery = False  # Arcane Mastery: ëª¨ë“  ì†ì„± íš¨ê³¼ +50%
        self.second_chance_rate = 0.0  # Second Chance: ì¹˜ëª…íƒ€ íšŒí”¼ í™•ë¥ 

        # 10. ì´ë™ íš¨ê³¼ ì‹œìŠ¤í…œ
        self.velocity = pygame.math.Vector2(0, 0)  # í˜„ì¬ ì´ë™ ì†ë„ ë²¡í„°
        self.trail_particles = []  # ì´ë™ íŠ¸ë ˆì¼ íŒŒí‹°í´ [(pos, lifetime, color, size), ...]
        self.afterimages = []  # ì”ìƒ íš¨ê³¼ [(image, pos, alpha, lifetime), ...]
        self.last_trail_spawn = 0.0  # ë§ˆì§€ë§‰ íŠ¸ë ˆì¼ ìƒì„± ì‹œê°„
        self.trail_spawn_interval = 0.02  # íŠ¸ë ˆì¼ ìƒì„± ê°„ê²© (ì´ˆ)
        self.disable_afterimages = False  # ì”ìƒ ë¹„í™œì„±í™” í”Œë˜ê·¸ (ê³µì„± ëª¨ë“œìš©)

        # 10-1. ì´ë™ ë°©í–¥ ê¸°ìš¸ê¸°(í‹¸íŠ¸) ì‹œìŠ¤í…œ
        self.current_tilt = 0.0  # í˜„ì¬ ê¸°ìš¸ê¸° ê°ë„ (ë„)
        self.target_tilt = 0.0  # ëª©í‘œ ê¸°ìš¸ê¸° ê°ë„ (ë„)
        self.tilt_speed = 8.0  # ê¸°ìš¸ê¸° ë³´ê°„ ì†ë„ (í´ìˆ˜ë¡ ë¹ ë¥´ê²Œ ê¸°ìš¸ì–´ì§)
        self.max_tilt_angle = 25.0  # ìµœëŒ€ ê¸°ìš¸ê¸° ê°ë„ (ë„)
        self.tilt_return_speed = 5.0  # ì›ìœ„ì¹˜ ë³µê·€ ì†ë„

        # 11. í•¨ì„  íŠ¹ìˆ˜ ëŠ¥ë ¥ ì‹œìŠ¤í…œ (E í‚¤)
        self.ship_ability_type = self.ship_data.get("special")  # í•¨ì„  íŠ¹ìˆ˜ ëŠ¥ë ¥ íƒ€ì…
        self.ship_ability_cooldown = 0.0  # ëŠ¥ë ¥ ì¿¨ë‹¤ìš´ íƒ€ì´ë¨¸
        self.ship_ability_active = False  # ëŠ¥ë ¥ í™œì„±í™” ìƒíƒœ
        self.ship_ability_timer = 0.0  # ëŠ¥ë ¥ ì§€ì† ì‹œê°„

        # í•¨ì„ ë³„ ëŠ¥ë ¥ ì´ˆê¸°í™”
        self._init_ship_ability()

        # 12. ë§ˆìš°ìŠ¤ ì´ë™ ì‹œìŠ¤í…œ
        self.mouse_target = None  # ë§ˆìš°ìŠ¤ í´ë¦­ ëª©í‘œ ìœ„ì¹˜ (Vector2 ë˜ëŠ” None)
        self.mouse_move_speed_mult = 1.0  # ë§ˆìš°ìŠ¤ ì´ë™ ì†ë„ ë°°ìœ¨
        self.mouse_arrival_threshold = 10.0  # ëª©í‘œ ë„ë‹¬ íŒì • ê±°ë¦¬ (px)

    def _init_ship_ability(self):
        """í•¨ì„ ë³„ íŠ¹ìˆ˜ ëŠ¥ë ¥ ì´ˆê¸°í™”"""
        ability = self.ship_ability_type

        # INTERCEPTOR: Evasion Boost (2ì´ˆ ë¬´ì  ëŒ€ì‹œ)
        self.evasion_active = False
        self.evasion_duration = 2.0
        self.evasion_cooldown_max = 15.0

        # BOMBER: Bomb Drop (AoE í­íƒ„)
        self.bomb_damage = 500
        self.bomb_radius = 200
        self.bomb_cooldown_max = 10.0

        # STEALTH: Cloaking (3ì´ˆ ì€ì‹ )
        self.cloak_active = False
        self.cloak_duration = 3.0
        self.cloak_cooldown_max = 20.0
        self.cloak_alpha = 255  # ì€ì‹  ì‹œ íˆ¬ëª…ë„

        # TITAN: Shield (í”¼í•´ í¡ìˆ˜)
        self.shield_active = False
        self.shield_hp = 0
        self.shield_max_hp = 0
        self.shield_absorption = 0.30  # 30% í”¼í•´ í¡ìˆ˜
        self.shield_cooldown_max = 25.0
        self.shield_duration = 8.0

        # Titan í•¨ì„ ì¼ ê²½ìš° ì‹¤ë“œ ìµœëŒ€ì¹˜ ì„¤ì •
        if self.ship_type == "TITAN":
            self.shield_max_hp = int(self.max_hp * 0.5)  # ìµœëŒ€ HPì˜ 50%

    def calculate_stats_from_upgrades(self):
        """ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ ë ˆë²¨ì„ ê¸°ë°˜ìœ¼ë¡œ í”Œë ˆì´ì–´ ìŠ¤íƒ¯ì„ ê³„ì‚°í•©ë‹ˆë‹¤. (í•¨ì„  ë°°ìœ¨ + Workshop ì—…ê·¸ë ˆì´ë“œ ì ìš©)"""

        # í•¨ì„  ë°°ìœ¨ ê°€ì ¸ì˜¤ê¸°
        hp_mult = self.ship_stats.get("hp_mult", 1.0)
        speed_mult = self.ship_stats.get("speed_mult", 1.0)

        # === ê¸°ì¡´ ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ (ìƒì ) ===
        # ìµœëŒ€ HP ê³„ì‚° (ê¸°ì¡´ ë ˆë²¨ ì‹œìŠ¤í…œ)
        hp_level = self.upgrades.get("MAX_HP", 1)
        hp_bonus = config.PERMANENT_MAX_HP_BONUS_AMOUNT * (hp_level - 1)
        base_hp = config.PLAYER_BASE_HP + hp_bonus

        # === Workshop ì—…ê·¸ë ˆì´ë“œ ì ìš© ===
        # Workshop MAX_HP: +10% per level
        workshop_hp_level = self.upgrades.get("MAX_HP", 0)
        if workshop_hp_level > 0:
            base_hp = base_hp * (1 + 0.10 * workshop_hp_level)

        # í•¨ì„  ë°°ìœ¨ ì ìš©
        self.initial_max_hp = int(base_hp * hp_mult)

        # ì´ë™ ì†ë„ ê³„ì‚°
        speed_level = self.upgrades.get("SPEED", 0)
        speed_bonus = config.PERMANENT_SPEED_BONUS_AMOUNT * speed_level
        base_speed = self.base_speed + speed_bonus

        # Workshop SPEED: +5% per level
        workshop_speed_level = self.upgrades.get("SPEED", 0)
        if workshop_speed_level > 0:
            base_speed = base_speed * (1 + 0.05 * workshop_speed_level)

        # í•¨ì„  ë°°ìœ¨ ì ìš©
        self.speed = base_speed * speed_mult

        # === Workshop ìŠ¤í‚¬ ì ìš© ===
        # Chain Lightning
        if self.upgrades.get("CHAIN_LIGHTNING", 0) > 0:
            self.has_lightning = True
            self.lightning_chain_count = 3

        # Explosive Rounds
        if self.upgrades.get("EXPLOSIVE_ROUNDS", 0) > 0:
            self.has_explosive = True

        # Freeze Shot
        if self.upgrades.get("FREEZE_SHOT", 0) > 0:
            self.has_frost = True
            self.frost_slow_ratio = 0.5

        # Execute
        if self.upgrades.get("EXECUTE", 0) > 0:
            self.execute_threshold = 0.15  # 15% HP ì´í•˜ ì¦‰ì‚¬

        # Phoenix Rebirth
        if self.upgrades.get("PHOENIX", 0) > 0:
            self.has_phoenix = True

        # Coin Magnet
        if self.upgrades.get("COIN_MAGNET", 0) > 0:
            self.has_coin_magnet = True

        # Coin Multiplier
        if self.upgrades.get("COIN_MULT", 0) > 0:
            self.coin_drop_multiplier = 1.5

        # HP Regeneration
        if self.upgrades.get("HP_REGEN", 0) > 0:
            self.regeneration_rate = 2.0  # ì´ˆë‹¹ 2 HP íšŒë³µ

        # Defense (-3% per level)
        defense_level = self.upgrades.get("DEFENSE", 0)
        if defense_level > 0:
            self.damage_reduction = 0.03 * defense_level

    def move(self, keys: Dict, dt: float, screen_size: Tuple[int, int], current_time: float = 0.0, game_data: Dict = None):
        """í‚¤ ì…ë ¥ ë˜ëŠ” ë§ˆìš°ìŠ¤ í´ë¦­ ëª©í‘œë¥¼ ê¸°ë°˜ìœ¼ë¡œ í”Œë ˆì´ì–´ë¥¼ ì´ë™ì‹œí‚¤ê³  ì´ë™ íš¨ê³¼ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."""

        # ì´ë™ ë²¡í„° ì´ˆê¸°í™”
        velocity = pygame.math.Vector2(0, 0)

        # í‚¤ë³´ë“œ ì…ë ¥ì— ë”°ë¼ ì†ë„ ì„¤ì •
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            velocity.x = -1
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            velocity.x = 1
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            velocity.y = -1
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            velocity.y = 1

        # í‚¤ë³´ë“œ ì…ë ¥ì´ ìˆìœ¼ë©´ ë§ˆìš°ìŠ¤ íƒ€ê²Ÿ ì·¨ì†Œ
        if velocity.length_squared() > 0:
            self.mouse_target = None

        # ë§ˆìš°ìŠ¤ ì´ë™ ëª©í‘œê°€ ìˆê³  í‚¤ë³´ë“œ ì…ë ¥ì´ ì—†ìœ¼ë©´ ë§ˆìš°ìŠ¤ ì´ë™
        if self.mouse_target is not None and velocity.length_squared() == 0:
            to_target = self.mouse_target - self.pos
            dist = to_target.length()

            if dist > self.mouse_arrival_threshold:
                # ëª©í‘œ ë°©í–¥ìœ¼ë¡œ ì´ë™
                velocity = to_target.normalize()
            else:
                # ëª©í‘œì— ë„ë‹¬ - íƒ€ê²Ÿ í´ë¦¬ì–´
                self.mouse_target = None

        # ë³´ìŠ¤ ì›¨ì´ë¸Œ ì†ë„ ë²„í”„ ê³„ì‚° (20% ì¦ê°€)
        speed_multiplier = 1.0
        if game_data and game_data.get('current_wave') in config.BOSS_WAVES:
            speed_multiplier = 1.2  # ë³´ìŠ¤ ì›¨ì´ë¸Œì—ì„œ 20% ì†ë„ ì¦ê°€

        # ëŒ€ê°ì„  ì´ë™ ì‹œ ì†ë„ ë³´ì • (ì •ê·œí™”)
        if velocity.length_squared() > 0:
            effective_speed = self.speed * speed_multiplier * self.mouse_move_speed_mult
            velocity = velocity.normalize() * effective_speed * dt
            self.velocity = velocity / dt  # ì´ˆë‹¹ ì†ë„ ë²¡í„° ì €ì¥
            self.pos += velocity

            # ì´ë™ íš¨ê³¼ ìƒì„± (ì†ë„ì— ë”°ë¼)
            self._create_movement_effects(current_time)
        else:
            self.velocity = pygame.math.Vector2(0, 0)

        # í™”ë©´ ê²½ê³„ ì œí•œ
        SCREEN_WIDTH, SCREEN_HEIGHT = screen_size
        half_width = self.image_rect.width / 2
        half_height = self.image_rect.height / 2

        self.pos.x = max(half_width, min(self.pos.x, SCREEN_WIDTH - half_width))
        self.pos.y = max(half_height, min(self.pos.y, SCREEN_HEIGHT - half_height))

        # rect ë° hitbox ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        self.image_rect.center = (int(self.pos.x), int(self.pos.y))
        self.hitbox.center = self.image_rect.center

    def set_mouse_target(self, pos: Tuple[int, int]):
        """ë§ˆìš°ìŠ¤ í´ë¦­ ìœ„ì¹˜ë¥¼ ì´ë™ ëª©í‘œë¡œ ì„¤ì •í•©ë‹ˆë‹¤."""
        self.mouse_target = pygame.math.Vector2(pos[0], pos[1])

    def clear_mouse_target(self):
        """ë§ˆìš°ìŠ¤ ì´ë™ ëª©í‘œë¥¼ ì·¨ì†Œí•©ë‹ˆë‹¤."""
        self.mouse_target = None

    # =========================================================
    # ë§ˆìš°ìŠ¤ ìš°í´ë¦­ ê³µê²© ì‹œìŠ¤í…œ (ê°€ê¹Œìš´ ì  íƒ€ê²ŸíŒ…)
    # =========================================================
    def find_nearest_enemy(self, enemies: list) -> object:
        """
        ê°€ì¥ ê°€ê¹Œìš´ ì ì„ ì°¾ì•„ ë°˜í™˜í•©ë‹ˆë‹¤.

        Args:
            enemies: ì  ê°ì²´ ë¦¬ìŠ¤íŠ¸

        Returns:
            ê°€ì¥ ê°€ê¹Œìš´ ì  ê°ì²´ ë˜ëŠ” None
        """
        if not enemies:
            return None

        closest_enemy = None
        closest_dist = float('inf')

        for enemy in enemies:
            if not hasattr(enemy, 'pos'):
                continue
            dist = (enemy.pos - self.pos).length()
            if dist < closest_dist:
                closest_dist = dist
                closest_enemy = enemy

        return closest_enemy

    def get_direction_to_enemy(self, enemy) -> pygame.math.Vector2:
        """
        ì  ë°©í–¥ìœ¼ë¡œì˜ ë‹¨ìœ„ ë²¡í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

        Args:
            enemy: ì  ê°ì²´

        Returns:
            ì  ë°©í–¥ ë‹¨ìœ„ ë²¡í„° ë˜ëŠ” (0, -1) (ìœ„ìª½)
        """
        if enemy is None or not hasattr(enemy, 'pos'):
            return pygame.math.Vector2(0, -1)  # ê¸°ë³¸: ìœ„ìª½

        to_enemy = enemy.pos - self.pos
        if to_enemy.length() > 0:
            return to_enemy.normalize()
        return pygame.math.Vector2(0, -1)

    '''
    def _create_movement_effects(self, current_time: float):
        """ì´ë™ ì†ë„ì™€ ë°©í–¥ì— ë”°ë¥¸ ì‹œê° íš¨ê³¼ ìƒì„±"""
        import random

        # ì†ë„ì— ë”°ë¥¸ íš¨ê³¼ ê°•ë„ ê³„ì‚°
        speed_magnitude = self.velocity.length()
        speed_ratio = speed_magnitude / self.speed  # 0.0 ~ 1.0+

        # ìµœì†Œ ì†ë„ ì„ê³„ê°’ (ë„ˆë¬´ ëŠë¦¬ë©´ íš¨ê³¼ ì•ˆ ë‚˜ì˜´)
        if speed_ratio < 0.3:
            return

        # íŠ¸ë ˆì¼ ìƒì„± ì£¼ê¸° ì²´í¬
        if current_time - self.last_trail_spawn < self.trail_spawn_interval:
            return

        self.last_trail_spawn = current_time

        # ì´ë™ ë°©í–¥ì˜ ë°˜ëŒ€ë¡œ íŒŒí‹°í´ ìƒì„±
        if self.velocity.length_squared() > 0:
            direction = self.velocity.normalize()
            # í”Œë ˆì´ì–´ ë’¤ìª½ì—ì„œ íŒŒí‹°í´ ìƒì„±
            offset = -direction * (self.image_rect.width * 0.3)
            spawn_pos = self.pos + offset

            # ì†ë„ì— ë”°ë¥¸ íŒŒí‹°í´ ìˆ˜ (ë¹ ë¥¼ìˆ˜ë¡ ë§ì´)
            particle_count = int(2 + speed_ratio * 3)

            for _ in range(particle_count):
                # ì•½ê°„ì˜ ëœë¤ ë¶„ì‚°
                spread = pygame.math.Vector2(
                    random.uniform(-10, 10),
                    random.uniform(-10, 10)
                )
                particle_pos = spawn_pos + spread


                if speed_ratio < 0.5: # 0.3ì„ 0.5ë¡œ ë³€ê²½í•˜ì—¬ íŠ¸ë ˆì¼ ìƒ‰ìƒ ë³€í™” êµ¬ê°„ í™•ëŒ€
                    color = (150, 200, 255)  # ì—°í•œ í•˜ëŠ˜ìƒ‰
                elif speed_ratio < 0.98:
                    color = (100, 100, 255)  # í‘¸ë¥¸ ë³´ë¼ìƒ‰
                else:
                    color = (100, 255, 255)  # ê³ ì—´ì˜ ë§ˆì  íƒ€ (ê°€ì¥ ê³ ì†)if 
                    
                # ì†ë„ì— ë”°ë¥¸ íŒŒí‹°í´ í¬ê¸°
                base_size = 3 + speed_ratio * 5
                size = int(base_size + random.uniform(-1, 2))
                size = max(1, size) # ìµœì†Œ í¬ê¸° ë³´ì¥
            
            



                # íŒŒí‹°í´ ìˆ˜ëª… (ì†ë„ê°€ ë¹ ë¥¼ìˆ˜ë¡ ê¸¸ê²Œ)
                lifetime = 0.3 + speed_ratio * 0.3

                self.trail_particles.append({
                    'pos': particle_pos.copy(),
                    'lifetime': lifetime,
                    'max_lifetime': lifetime,
                    'color': color,
                    'size': size
                })

        # ê³ ì† ì´ë™ ì‹œ ì”ìƒ íš¨ê³¼ ì¶”ê°€
        if speed_ratio > 0.5:
            # ì”ìƒ ìƒì„± (íˆ¬ëª…ë„ ìˆëŠ” í”Œë ˆì´ì–´ ì´ë¯¸ì§€)
            afterimage = self.image.copy()
            
            # ğŸŒŸ ì²­ë¡ìƒ‰ í”Œë¼ì¦ˆë§ˆ í•„í„° ì¶”ê°€
            PLASMA_COLOR = (100, 255, 255) 
            afterimage.fill(PLASMA_COLOR, special_flags=pygame.BLEND_RGB_MULT)
            
            
            alpha = int(150 * speed_ratio)  # ì†ë„ì— ë”°ë¼ íˆ¬ëª…ë„ ì¡°ì ˆ
            afterimage.set_alpha(min(alpha, 255)) # 255 ì´ˆê³¼ ë°©ì§€
            afterimage.set_alpha(alpha)

            # ì”ìƒì— í˜„ì¬ ê¸°ìš¸ê¸° ì ìš©
            if abs(self.current_tilt) > 0.5:
                afterimage = pygame.transform.rotate(afterimage, self.current_tilt)

            self.afterimages.append({
                'image': afterimage,
                'pos': self.pos.copy(),
                'alpha': alpha,
                'lifetime': 0.3,  # ì”ìƒ ì§€ì† ì‹œê°„
                'max_lifetime': 0.3
            })
            '''     

    def _create_movement_effects(self, current_time: float):
        """ì´ë™ ì†ë„ì™€ ë°©í–¥ì— ë”°ë¥¸ ì‹œê° íš¨ê³¼ ìƒì„±"""
        import random

        # ì†ë„ì— ë”°ë¥¸ íš¨ê³¼ ê°•ë„ ê³„ì‚°
        speed_magnitude = self.velocity.length()
        speed_ratio = speed_magnitude / self.speed  # 0.0 ~ 1.0+

        # ìµœì†Œ ì†ë„ ì„ê³„ê°’ (ë„ˆë¬´ ëŠë¦¬ë©´ íš¨ê³¼ ì•ˆ ë‚˜ì˜´)
        if speed_ratio < 0.3:
            return

        # íŠ¸ë ˆì¼ ìƒì„± ì£¼ê¸° ì²´í¬
        if current_time - self.last_trail_spawn < self.trail_spawn_interval:
            return

        self.last_trail_spawn = current_time

        # ì´ë™ ë°©í–¥ì˜ ë°˜ëŒ€ë¡œ íŒŒí‹°í´ ìƒì„±
        if self.velocity.length_squared() > 0:
            direction = self.velocity.normalize()
            # í”Œë ˆì´ì–´ ë’¤ìª½ì—ì„œ íŒŒí‹°í´ ìƒì„±
            offset = -direction * (self.image_rect.width * 0.3)
            spawn_pos = self.pos + offset

            # ì†ë„ì— ë”°ë¥¸ íŒŒí‹°í´ ìˆ˜ (ë¹ ë¥¼ìˆ˜ë¡ ë§ì´)
            particle_count = int(2 + speed_ratio * 3)

            for _ in range(particle_count):
            # ì•½ê°„ì˜ ëœë¤ ë¶„ì‚°
                spread = pygame.math.Vector2(
                random.uniform(-10, 10),
                random.uniform(-10, 10)
            )
            particle_pos = spawn_pos + spread


        if speed_ratio < 0.5:
            color = (100, 150, 255)  # íŒŒë€ìƒ‰
        elif speed_ratio < 0.8:
            color = (150, 200, 255)  # í•˜ëŠ˜ìƒ‰
        else:
            color = (255, 215, 0)  # ì£¼í™©ìƒ‰


            # ì†ë„ì— ë”°ë¥¸ íŒŒí‹°í´ í¬ê¸°
            size = int(3 + speed_ratio * 5)

            # íŒŒí‹°í´ ìˆ˜ëª… (ì†ë„ê°€ ë¹ ë¥¼ìˆ˜ë¡ ê¸¸ê²Œ)
            lifetime = 0.3 + speed_ratio * 0.3

            self.trail_particles.append({
            'pos': particle_pos.copy(),
            'lifetime': lifetime,
            'max_lifetime': lifetime,
            'color': color,
            'size': size
            })

            # ê³ ì† ì´ë™ ì‹œ ì”ìƒ íš¨ê³¼ ì¶”ê°€ (ê³µì„± ëª¨ë“œì—ì„œëŠ” ë¹„í™œì„±í™”)
            if speed_ratio > 0.7 and not self.disable_afterimages:
                # ì”ìƒ ìƒì„± (íˆ¬ëª…ë„ ìˆëŠ” í”Œë ˆì´ì–´ ì´ë¯¸ì§€)
                afterimage = self.image.copy()
                alpha = int(100 * speed_ratio)  # ì†ë„ì— ë”°ë¼ íˆ¬ëª…ë„ ì¡°ì ˆ
                afterimage.set_alpha(alpha)

                # ì”ìƒì— í˜„ì¬ ê¸°ìš¸ê¸° ì ìš©
                if abs(self.current_tilt) > 0.5:
                    afterimage = pygame.transform.rotate(afterimage, self.current_tilt)

                self.afterimages.append({
                    'image': afterimage,
                    'pos': self.pos.copy(),
                    'alpha': alpha,
                    'lifetime': 0.15,  # ì”ìƒ ì§€ì† ì‹œê°„
                    'max_lifetime': 0.15
                })    









    def activate_ultimate(self, enemies: List):
        """ê¶ê·¹ê¸°ë¥¼ ë°œë™í•©ë‹ˆë‹¤ (Q í‚¤)

        Args:
            enemies: í˜„ì¬ ì  ë¦¬ìŠ¤íŠ¸

        Returns:
            bool: ê¶ê·¹ê¸° ë°œë™ ì„±ê³µ ì—¬ë¶€
        """
        # ì¶©ì „ í™•ì¸
        if self.ultimate_charge < config.ULTIMATE_SETTINGS["charge_time"]:
            return False

        # ì¿¨ë‹¤ìš´ í™•ì¸
        if self.ultimate_cooldown_timer > 0:
            return False

        # ê¶ê·¹ê¸° íƒ€ì…ë³„ íš¨ê³¼ ë°œë™
        if self.ultimate_type == "NOVA_BLAST":
            self._activate_nova_blast(enemies)
        elif self.ultimate_type == "TIME_FREEZE":
            self._activate_time_freeze(enemies)
        elif self.ultimate_type == "ORBITAL_STRIKE":
            self._activate_orbital_strike(enemies)

        # ì¿¨ë‹¤ìš´ ì‹œì‘
        self.ultimate_cooldown_timer = config.ULTIMATE_SETTINGS["cooldown"]
        self.ultimate_charge = 0.0

        print(f"INFO: Ultimate '{self.ultimate_type}' activated!")
        return True

    def _activate_nova_blast(self, enemies: List):
        """Nova Blast ê¶ê·¹ê¸° - ì£¼ë³€ ëŒ€ê·œëª¨ í­ë°œ"""
        settings = config.ULTIMATE_SETTINGS["NOVA_BLAST"]

        # í­ë°œ íš¨ê³¼ ì¶”ê°€
        self.ultimate_effects.append({
            "type": "NOVA_BLAST",
            "pos": self.pos.copy(),
            "radius": 0,
            "max_radius": settings["radius"],
            "timer": settings["duration"],
            "color": settings["color"],
        })

        # ë²”ìœ„ ë‚´ ëª¨ë“  ì ì—ê²Œ ë°ë¯¸ì§€ ë° ë„‰ë°±
        for enemy in enemies:
            dist = (enemy.pos - self.pos).length()
            if dist <= settings["radius"]:
                # ë°ë¯¸ì§€ ì ìš©
                enemy.take_damage(settings["damage"])

                # ë„‰ë°± ì ìš©
                if dist > 0:
                    knockback_dir = (enemy.pos - self.pos).normalize()
                    enemy.pos += knockback_dir * settings["knockback"] * (1 - dist / settings["radius"])

    def _activate_time_freeze(self, enemies: List):
        """Time Freeze ê¶ê·¹ê¸° - ëª¨ë“  ì  ì‹œê°„ ì •ì§€"""
        settings = config.ULTIMATE_SETTINGS["TIME_FREEZE"]

        self.time_freeze_active = True
        self.time_freeze_timer = settings["duration"]

    def _activate_orbital_strike(self, enemies: List):
        """Orbital Strike ê¶ê·¹ê¸° - ë ˆì´ì € ê³µê²©"""
        settings = config.ULTIMATE_SETTINGS["ORBITAL_STRIKE"]

        # ëª¨ë“  ì  ìœ„ì¹˜ì— ë ˆì´ì € íƒ€ê²Ÿ ì„¤ì •
        import random
        targets = []
        for i in range(min(settings["strike_count"], len(enemies) * 2)):
            if enemies:
                target_enemy = random.choice(enemies)
                targets.append({
                    "pos": target_enemy.pos.copy(),
                    "delay": i * settings["strike_interval"],
                    "timer": 0.0,
                    "active": False,
                })

        self.orbital_strikes = targets
        self.orbital_strike_timer = 0.0

    def take_damage(self, damage: float):
        """í”Œë ˆì´ì–´ê°€ í”¼í•´ë¥¼ ì…ìŠµë‹ˆë‹¤."""
        # ì´ë¯¸ ì‚¬ë§ ìƒíƒœë©´ ì¶”ê°€ ë°ë¯¸ì§€ ë¬´ì‹œ
        if self.hp <= 0:
            return

        # Second Chance ìŠ¤í‚¬: ì¹˜ëª…íƒ€ íšŒí”¼ (ì‚¬ë§ ì§ì „ì—ë§Œ ë°œë™)
        if hasattr(self, 'second_chance_rate') and self.second_chance_rate > 0:
            would_die = (self.hp - damage * (1.0 - self.damage_reduction)) <= 0
            if would_die and random.random() < self.second_chance_rate:
                print(f"INFO: Second Chance! Dodged lethal damage!")
                return  # í”¼í•´ ë¬´ì‹œ

        # í”¼í•´ ê°ì†Œ ì ìš©
        actual_damage = damage * (1.0 - self.damage_reduction)
        self.hp -= actual_damage
        self.hp = max(0, self.hp)

        # ì‚¬ë§ ì‹œ í”Œë˜ê·¸ ì„¤ì •
        if self.hp <= 0:
            self.is_dead = True

        # íˆíŠ¸ í”Œë˜ì‹œ íŠ¸ë¦¬ê±°
        self.hit_flash_timer = config.HIT_FLASH_DURATION
        self.is_flashing = True

        # í”¼ê²© í”Œë˜ê·¸ ì„¤ì • (CombatMotionEffect ì´ë™ ì‹œê°„ ë¦¬ì…‹ìš©)
        self.was_hit_recently = True

    def heal(self, amount: float):
        """í”Œë ˆì´ì–´ì˜ ì²´ë ¥ì„ íšŒë³µí•©ë‹ˆë‹¤."""
        # ì‚¬ë§ ìƒíƒœë©´ íšŒë³µí•˜ì§€ ì•ŠìŒ (ê²Œì„ ì˜¤ë²„ ìƒíƒœ)
        if self.is_dead or self.hp <= 0:
            return
        self.hp += amount
        self.hp = min(self.hp, self.max_hp)

    def increase_max_hp(self, amount: int):
        """ìµœëŒ€ ì²´ë ¥ì„ ì¦ê°€ì‹œí‚¤ê³  í˜„ì¬ ì²´ë ¥ì„ ë¹„ë¡€ì ìœ¼ë¡œ ì¡°ì •í•©ë‹ˆë‹¤."""
        if amount <= 0: return

        # HPê°€ 0 ì´í•˜ë©´ max_hpë§Œ ì¦ê°€ (ê²Œì„ ì˜¤ë²„ ìƒíƒœì—ì„œëŠ” íšŒë³µ ì•ˆ í•¨)
        if self.hp <= 0:
            self.max_hp += amount
            print(f"INFO: Max HP increased to {self.max_hp}, HP remains at 0 (game over state)")
            return

        # í˜„ì¬ ì²´ë ¥ ë¹„ìœ¨ ìœ ì§€
        health_ratio = self.hp / self.max_hp if self.max_hp > 0 else 1.0

        # ìµœëŒ€ ì²´ë ¥ ì¦ê°€
        self.max_hp += amount

        # í˜„ì¬ ì²´ë ¥ì„ ë¹„ë¡€ì ìœ¼ë¡œ ì¦ê°€ (ì²´ë ¥ ë¹„ìœ¨ ìœ ì§€)
        self.hp = self.max_hp * health_ratio

        print(f"INFO: Max HP increased to {self.max_hp}, current HP: {self.hp}")

    def increase_speed(self, amount: int):
        """ì´ë™ ì†ë„ë¥¼ ì¦ê°€ì‹œí‚µë‹ˆë‹¤."""
        if amount <= 0: return
        self.speed += amount
        print(f"INFO: Speed increased to {self.speed}")

    def add_damage_reduction(self, ratio: float):
        """í”¼í•´ ê°ì†Œ ë¹„ìœ¨ì„ ì¶”ê°€í•©ë‹ˆë‹¤."""
        if ratio <= 0: return
        self.damage_reduction = min(0.75, self.damage_reduction + ratio)  # ìµœëŒ€ 75%
        print(f"INFO: Damage reduction: {self.damage_reduction * 100:.0f}%")

    def add_regeneration(self, rate: float):
        """ì´ˆë‹¹ ì²´ë ¥ íšŒë³µëŸ‰ì„ ì¶”ê°€í•©ë‹ˆë‹¤."""
        if rate <= 0: return
        self.regeneration_rate += rate
        print(f"INFO: Regeneration rate: {self.regeneration_rate} HP/s")

    def update_regeneration(self, current_time: float):
        """ì‹œê°„ì— ë”°ë¼ ì²´ë ¥ì„ íšŒë³µí•©ë‹ˆë‹¤."""
        # ì‚¬ë§ ìƒíƒœë©´ íšŒë³µí•˜ì§€ ì•ŠìŒ (ê²Œì„ ì˜¤ë²„ ìƒíƒœ)
        if self.is_dead or self.hp <= 0:
            return
        if self.regeneration_rate > 0 and self.hp < self.max_hp:
            # 1ì´ˆë§ˆë‹¤ íšŒë³µ
            if current_time - self.last_regen_time >= 1.0:
                self.heal(self.regeneration_rate)
                self.last_regen_time = current_time

    def update(self, dt: float, screen_size: Tuple[int, int], current_time: float):
        """í”Œë ˆì´ì–´ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤."""
        # ë¬´ê¸° ì¿¨íƒ€ì„ ì—…ë°ì´íŠ¸
        self.weapon.update(dt)

        # ì²´ë ¥ ì¬ìƒ ì—…ë°ì´íŠ¸
        self.update_regeneration(current_time)

        # íˆíŠ¸ í”Œë˜ì‹œ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
        if self.is_flashing:
            self.hit_flash_timer -= dt
            if self.hit_flash_timer <= 0:
                self.is_flashing = False
                self.image = self.original_image.copy()

        # ê¶ê·¹ê¸° ì¶©ì „ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
        if self.ultimate_charge < config.ULTIMATE_SETTINGS["charge_time"]:
            self.ultimate_charge += dt
            self.ultimate_charge = min(self.ultimate_charge, config.ULTIMATE_SETTINGS["charge_time"])

        # ê¶ê·¹ê¸° ì¿¨ë‹¤ìš´ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
        if self.ultimate_cooldown_timer > 0:
            self.ultimate_cooldown_timer -= dt
            self.ultimate_cooldown_timer = max(0, self.ultimate_cooldown_timer)

        # Time Freeze íš¨ê³¼ íƒ€ì´ë¨¸
        if self.time_freeze_active:
            self.time_freeze_timer -= dt
            if self.time_freeze_timer <= 0:
                self.time_freeze_active = False
                self.time_freeze_timer = 0.0

        # Orbital Strike íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
        if self.orbital_strikes:
            self.orbital_strike_timer += dt
            for strike in self.orbital_strikes:
                if not strike["active"] and self.orbital_strike_timer >= strike["delay"]:
                    strike["active"] = True
                    strike["timer"] = config.ULTIMATE_SETTINGS["ORBITAL_STRIKE"]["beam_duration"]

                if strike["active"]:
                    strike["timer"] -= dt

            # ì™„ë£Œëœ ìŠ¤íŠ¸ë¼ì´í¬ ì œê±°
            self.orbital_strikes = [s for s in self.orbital_strikes if s["timer"] > 0 or not s["active"]]

        # ê¶ê·¹ê¸° ì‹œê° íš¨ê³¼ ì—…ë°ì´íŠ¸
        for effect in self.ultimate_effects:
            effect["timer"] -= dt
            if effect["type"] == "NOVA_BLAST":
                # í­ë°œ ë°˜ê²½ í™•ì¥
                progress = 1 - (effect["timer"] / config.ULTIMATE_SETTINGS["NOVA_BLAST"]["duration"])
                effect["radius"] = effect["max_radius"] * progress

        # ì™„ë£Œëœ íš¨ê³¼ ì œê±°
        self.ultimate_effects = [e for e in self.ultimate_effects if e["timer"] > 0]

        # í•¨ì„  íŠ¹ìˆ˜ ëŠ¥ë ¥ ì—…ë°ì´íŠ¸
        self._update_ship_ability(dt)

        # ì´ë™ ë°©í–¥ ê¸°ìš¸ê¸°(í‹¸íŠ¸) ì—…ë°ì´íŠ¸
        self._update_tilt(dt)

    def _update_tilt(self, dt: float):
        """ì´ë™ ë°©í–¥ì— ë”°ë¥¸ ê¸°ìš¸ê¸° ì—…ë°ì´íŠ¸"""
        # ì†ë„ ë²¡í„°ê°€ ìˆìœ¼ë©´ ê¸°ìš¸ê¸° ëª©í‘œ ê³„ì‚°
        if self.velocity.length() > 0.1:
            # ì¢Œìš° ì´ë™ì— ë”°ë¥¸ ê¸°ìš¸ê¸° (Xì¶• ì†ë„ ê¸°ë°˜)
            horizontal_ratio = self.velocity.x / self.speed if self.speed > 0 else 0
            # ìµœëŒ€ ê¸°ìš¸ê¸° ê°ë„ë¡œ í´ë¨í•‘
            self.target_tilt = -horizontal_ratio * self.max_tilt_angle

            # ì¶”ê°€: ìœ„/ì•„ë˜ ì´ë™ ì‹œ ì•½ê°„ì˜ í”¼ì¹˜ íš¨ê³¼ (ì„ íƒì )
            # vertical_ratio = self.velocity.y / self.speed if self.speed > 0 else 0
            # ìœ„ë¡œ ì´ë™ ì‹œ ì•½ê°„ ì•ìœ¼ë¡œ ê¸°ìš¸ê¸° íš¨ê³¼ëŠ” 2Dì—ì„œ í‘œí˜„í•˜ê¸° ì–´ë ¤ìš°ë¯€ë¡œ ìƒëµ
        else:
            # ì´ë™í•˜ì§€ ì•Šìœ¼ë©´ ì›ìœ„ì¹˜ë¡œ ë³µê·€
            self.target_tilt = 0.0

        # ë¶€ë“œëŸ¬ìš´ ë³´ê°„ (í˜„ì¬ ê¸°ìš¸ê¸° â†’ ëª©í‘œ ê¸°ìš¸ê¸°)
        tilt_diff = self.target_tilt - self.current_tilt

        if abs(tilt_diff) > 0.1:
            # ì´ë™ ì¤‘ì¼ ë•ŒëŠ” ë¹ ë¥´ê²Œ, ì •ì§€ ì‹œì—ëŠ” ì²œì²œíˆ ë³µê·€
            if self.velocity.length() > 0.1:
                interpolation_speed = self.tilt_speed
            else:
                interpolation_speed = self.tilt_return_speed

            self.current_tilt += tilt_diff * interpolation_speed * dt
        else:
            self.current_tilt = self.target_tilt

        # ê°ë„ í´ë¨í•‘
        self.current_tilt = max(-self.max_tilt_angle, min(self.max_tilt_angle, self.current_tilt))

    def _update_ship_ability(self, dt: float):
        """í•¨ì„  íŠ¹ìˆ˜ ëŠ¥ë ¥ ìƒíƒœ ì—…ë°ì´íŠ¸"""
        # ì¿¨ë‹¤ìš´ ê°ì†Œ
        if self.ship_ability_cooldown > 0:
            self.ship_ability_cooldown -= dt
            self.ship_ability_cooldown = max(0, self.ship_ability_cooldown)

        # ëŠ¥ë ¥ í™œì„±í™” ì‹œ íƒ€ì´ë¨¸ ê°ì†Œ
        if self.ship_ability_active:
            self.ship_ability_timer -= dt

            # INTERCEPTOR: Evasion Boost
            if self.ship_ability_type == "evasion_boost":
                if self.ship_ability_timer <= 0:
                    self.evasion_active = False
                    self.ship_ability_active = False
                    self.ship_ability_cooldown = self.evasion_cooldown_max
                    print("INFO: Evasion Boost ended")

            # STEALTH: Cloaking
            elif self.ship_ability_type == "cloaking":
                if self.ship_ability_timer <= 0:
                    self.cloak_active = False
                    self.ship_ability_active = False
                    self.ship_ability_cooldown = self.cloak_cooldown_max
                    self.cloak_alpha = 255
                    print("INFO: Cloaking ended")
                else:
                    # ì€ì‹  ì¤‘ íˆ¬ëª…ë„ ì¡°ì ˆ (ê¹œë¹¡ì„ íš¨ê³¼)
                    import math
                    flicker = 0.3 + 0.2 * math.sin(self.ship_ability_timer * 10)
                    self.cloak_alpha = int(255 * flicker)

            # TITAN: Shield
            elif self.ship_ability_type == "shield":
                if self.ship_ability_timer <= 0 or self.shield_hp <= 0:
                    self.shield_active = False
                    self.ship_ability_active = False
                    self.ship_ability_cooldown = self.shield_cooldown_max
                    print("INFO: Shield ended")

    def use_ship_ability(self, enemies: list = None, effects: list = None) -> bool:
        """í•¨ì„  íŠ¹ìˆ˜ ëŠ¥ë ¥ ì‚¬ìš© (E í‚¤)"""
        # ì¿¨ë‹¤ìš´ ì¤‘ì´ë©´ ì‚¬ìš© ë¶ˆê°€
        if self.ship_ability_cooldown > 0:
            return False

        # ëŠ¥ë ¥ì´ ì—†ìœ¼ë©´ ì‚¬ìš© ë¶ˆê°€
        if self.ship_ability_type is None:
            return False

        # ì´ë¯¸ í™œì„±í™” ì¤‘ì´ë©´ ì‚¬ìš© ë¶ˆê°€
        if self.ship_ability_active:
            return False

        print(f"INFO: Using ship ability: {self.ship_ability_type}")

        # INTERCEPTOR: Evasion Boost (2ì´ˆ ë¬´ì  ëŒ€ì‹œ)
        if self.ship_ability_type == "evasion_boost":
            self.evasion_active = True
            self.ship_ability_active = True
            self.ship_ability_timer = self.evasion_duration
            # ì†ë„ ì¼ì‹œì ìœ¼ë¡œ 2ë°° ì¦ê°€
            self.speed *= 2.0
            return True

        # BOMBER: Bomb Drop (AoE í­íƒ„) - ì¦‰ì‹œ ë°œë™
        elif self.ship_ability_type == "bomb_drop":
            self.ship_ability_cooldown = self.bomb_cooldown_max
            # í­íƒ„ íš¨ê³¼ ìƒì„± (effects ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€)
            if effects is not None:
                bomb_effect = {
                    "type": "bomb_drop",
                    "pos": self.pos.copy(),
                    "radius": self.bomb_radius,
                    "damage": self.bomb_damage,
                    "timer": 0.5,  # í­ë°œ ì§€ì† ì‹œê°„
                    "max_timer": 0.5,
                }
                effects.append(bomb_effect)
            # ë²”ìœ„ ë‚´ ì ì—ê²Œ í”¼í•´
            if enemies:
                for enemy in enemies:
                    dist = (enemy.pos - self.pos).length()
                    if dist <= self.bomb_radius:
                        # ê±°ë¦¬ì— ë”°ë¥¸ ë°ë¯¸ì§€ ê°ì†Œ
                        damage_ratio = 1.0 - (dist / self.bomb_radius) * 0.5
                        enemy.take_damage(int(self.bomb_damage * damage_ratio))
            return True

        # STEALTH: Cloaking (3ì´ˆ ì€ì‹ )
        elif self.ship_ability_type == "cloaking":
            self.cloak_active = True
            self.ship_ability_active = True
            self.ship_ability_timer = self.cloak_duration
            return True

        # TITAN: Shield (í”¼í•´ í¡ìˆ˜)
        elif self.ship_ability_type == "shield":
            self.shield_active = True
            self.shield_hp = self.shield_max_hp
            self.ship_ability_active = True
            self.ship_ability_timer = self.shield_duration
            return True

        return False

    def get_ship_ability_info(self) -> dict:
        """í•¨ì„  íŠ¹ìˆ˜ ëŠ¥ë ¥ ì •ë³´ ë°˜í™˜ (UI í‘œì‹œìš©)"""
        if self.ship_ability_type is None:
            return {"name": "None", "ready": False, "cooldown": 0, "max_cooldown": 0}

        ability_names = {
            "evasion_boost": "Evasion Boost",
            "bomb_drop": "Bomb Drop",
            "cloaking": "Cloaking",
            "shield": "Shield",
        }

        max_cooldowns = {
            "evasion_boost": self.evasion_cooldown_max,
            "bomb_drop": self.bomb_cooldown_max,
            "cloaking": self.cloak_cooldown_max,
            "shield": self.shield_cooldown_max,
        }

        return {
            "name": ability_names.get(self.ship_ability_type, "Unknown"),
            "ready": self.ship_ability_cooldown <= 0 and not self.ship_ability_active,
            "active": self.ship_ability_active,
            "cooldown": self.ship_ability_cooldown,
            "max_cooldown": max_cooldowns.get(self.ship_ability_type, 10.0),
            "timer": self.ship_ability_timer if self.ship_ability_active else 0,
        }

    def is_invulnerable(self) -> bool:
        """ë¬´ì  ìƒíƒœ í™•ì¸ (Evasion Boost ë˜ëŠ” Cloaking)"""
        return self.evasion_active or self.cloak_active

    def take_damage_with_shield(self, damage: float) -> float:
        """ì‹¤ë“œ ì ìš© í›„ ì‹¤ì œ í”¼í•´ëŸ‰ ë°˜í™˜"""
        if self.shield_active and self.shield_hp > 0:
            # ì‹¤ë“œë¡œ í¡ìˆ˜í•  í”¼í•´ëŸ‰
            absorbed = int(damage * self.shield_absorption)
            self.shield_hp -= absorbed
            if self.shield_hp < 0:
                self.shield_hp = 0
            return damage - absorbed
        return damage

    def update_movement_effects(self, dt: float):
        """ì´ë™ íš¨ê³¼ ì—…ë°ì´íŠ¸ (íŒŒí‹°í´ íŠ¸ë ˆì¼ê³¼ ì”ìƒ)"""
        # íŠ¸ë ˆì¼ íŒŒí‹°í´ ì—…ë°ì´íŠ¸
        for particle in self.trail_particles[:]:
            particle['lifetime'] -= dt
            if particle['lifetime'] <= 0:
                self.trail_particles.remove(particle)

        # ì”ìƒ ì—…ë°ì´íŠ¸
        for afterimage in self.afterimages[:]:
            afterimage['lifetime'] -= dt
            if afterimage['lifetime'] <= 0:
                self.afterimages.remove(afterimage)
            else:
                # í˜ì´ë“œ ì•„ì›ƒ íš¨ê³¼
                fade_ratio = afterimage['lifetime'] / afterimage['max_lifetime']
                afterimage['image'].set_alpha(int(afterimage['alpha'] * fade_ratio))

    def _calculate_perspective_scale(self, screen_height: int) -> float:
        """Y ìœ„ì¹˜ ê¸°ë°˜ ì›ê·¼ê° ìŠ¤ì¼€ì¼ ê³„ì‚°"""
        if not config.PERSPECTIVE_ENABLED or not config.PERSPECTIVE_APPLY_TO_PLAYER:
            return 1.0

        # Y ìœ„ì¹˜ ë¹„ìœ¨ ê³„ì‚° (0.0 = ìƒë‹¨, 1.0 = í•˜ë‹¨)
        depth_ratio = self.pos.y / screen_height
        depth_ratio = max(0.0, min(1.0, depth_ratio))

        # ìŠ¤ì¼€ì¼ ê³„ì‚°
        scale = config.PERSPECTIVE_SCALE_MIN + (depth_ratio * (config.PERSPECTIVE_SCALE_MAX - config.PERSPECTIVE_SCALE_MIN))
        return scale

    def draw(self, screen: pygame.Surface):
        """í”Œë ˆì´ì–´ ê°ì²´ë¥¼ í™”ë©´ì— ê·¸ë¦½ë‹ˆë‹¤."""
        # ì›ê·¼ê° ìŠ¤ì¼€ì¼ ê³„ì‚°
        perspective_scale = self._calculate_perspective_scale(screen.get_height())

        # 1. ì”ìƒ íš¨ê³¼ ê·¸ë¦¬ê¸° (í”Œë ˆì´ì–´ ë’¤ì—)
        for afterimage in self.afterimages:
            # ì”ìƒì—ë„ ì›ê·¼ê° ì ìš©
            if config.PERSPECTIVE_ENABLED and config.PERSPECTIVE_APPLY_TO_PLAYER and perspective_scale != 1.0:
                afterimage_scale = self._calculate_perspective_scale(screen.get_height())
                scaled_afterimage = pygame.transform.smoothscale(
                    afterimage['image'],
                    (int(afterimage['image'].get_width() * afterimage_scale),
                     int(afterimage['image'].get_height() * afterimage_scale))
                )
                rect = scaled_afterimage.get_rect(center=(int(afterimage['pos'].x), int(afterimage['pos'].y)))
                screen.blit(scaled_afterimage, rect)
            else:
                rect = afterimage['image'].get_rect(center=(int(afterimage['pos'].x), int(afterimage['pos'].y)))
                screen.blit(afterimage['image'], rect)

        # 2. íŠ¸ë ˆì¼ íŒŒí‹°í´ ê·¸ë¦¬ê¸°
        for particle in self.trail_particles:
            # í˜ì´ë“œ ì•„ì›ƒ íš¨ê³¼
            fade_ratio = particle['lifetime'] / particle['max_lifetime']
            alpha = int(255 * fade_ratio)

            # íŒŒí‹°í´ í¬ê¸°ë„ ì ì  ì‘ì•„ì§
            current_size = max(1, int(particle['size'] * fade_ratio * perspective_scale))

            # íˆ¬ëª…ë„ë¥¼ ê°€ì§„ ì„œí˜ì´ìŠ¤ ìƒì„±
            particle_surface = pygame.Surface((current_size * 2, current_size * 2), pygame.SRCALPHA)
            pygame.draw.circle(particle_surface, (*particle['color'], alpha),
                             (current_size, current_size), current_size)

            # íŒŒí‹°í´ ìœ„ì¹˜ì— ê·¸ë¦¬ê¸°
            rect = particle_surface.get_rect(center=(int(particle['pos'].x), int(particle['pos'].y)))
            screen.blit(particle_surface, rect)

        # 3. ê·¸ë¦´ ì´ë¯¸ì§€ ê²°ì • (íˆíŠ¸ í”Œë˜ì‹œ ì ìš© + ëŠ¥ë ¥ íš¨ê³¼)
        if self.is_flashing:
            # í°ìƒ‰ìœ¼ë¡œ ê¹œë¹¡ì„
            flash_surface = self.original_image.copy()
            flash_surface.fill(config.HIT_FLASH_COLOR, special_flags=pygame.BLEND_RGB_ADD)
            draw_image = flash_surface
        elif getattr(self, 'cloak_active', False):
            # í´ë¡œí‚¹: ë°˜íˆ¬ëª… + ë³´ë¼ìƒ‰ í‹´íŠ¸
            cloak_surface = self.image.copy()
            cloak_surface.set_alpha(80)  # ë°˜íˆ¬ëª…
            # ë³´ë¼ìƒ‰ í‹´íŠ¸
            tint_surface = pygame.Surface(cloak_surface.get_size(), pygame.SRCALPHA)
            tint_surface.fill((100, 50, 150, 50))
            cloak_surface.blit(tint_surface, (0, 0), special_flags=pygame.BLEND_RGBA_ADD)
            draw_image = cloak_surface
        elif getattr(self, 'evasion_active', False):
            # íšŒí”¼ ë¶€ìŠ¤íŠ¸: ë…¸ë€ìƒ‰ ê¸€ë¡œìš°
            evasion_surface = self.image.copy()
            glow_surface = pygame.Surface(evasion_surface.get_size(), pygame.SRCALPHA)
            glow_surface.fill((255, 255, 100, 60))
            evasion_surface.blit(glow_surface, (0, 0), special_flags=pygame.BLEND_RGBA_ADD)
            draw_image = evasion_surface
        else:
            draw_image = self.image

        # 3-1. ì´ë™ ë°©í–¥ ê¸°ìš¸ê¸°(í‹¸íŠ¸) ì ìš©
        if abs(self.current_tilt) > 0.5:
            # ì´ë¯¸ì§€ íšŒì „ (ê¸°ìš¸ê¸° ê°ë„ ì ìš©)
            draw_image = pygame.transform.rotate(draw_image, self.current_tilt)

        # 4. í”Œë ˆì´ì–´ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° (ì›ê·¼ê° + í‹¸íŠ¸ ì ìš©)
        if config.PERSPECTIVE_ENABLED and config.PERSPECTIVE_APPLY_TO_PLAYER and perspective_scale != 1.0:
            scaled_image = pygame.transform.smoothscale(
                draw_image,
                (int(draw_image.get_width() * perspective_scale),
                 int(draw_image.get_height() * perspective_scale))
            )
            scaled_rect = scaled_image.get_rect(center=self.image_rect.center)
            screen.blit(scaled_image, scaled_rect)
        else:
            # ê¸°ìš¸ê¸°ê°€ ìˆì„ ê²½ìš° ì¤‘ì‹¬ì  ìœ ì§€
            draw_rect = draw_image.get_rect(center=self.image_rect.center)
            screen.blit(draw_image, draw_rect)

        # 5. ê¶ê·¹ê¸° ì‹œê° íš¨ê³¼ ë Œë”ë§
        for effect in self.ultimate_effects:
            if effect["type"] == "NOVA_BLAST":
                # í™•ì¥í•˜ëŠ” ì›í˜• í­ë°œ ì´í™íŠ¸
                pygame.draw.circle(screen, effect["color"],
                                   (int(effect["pos"].x), int(effect["pos"].y)),
                                   int(effect["radius"]), 5)

        # 6. Time Freeze í™”ë©´ í‹´íŠ¸
        if self.time_freeze_active:
            settings = config.ULTIMATE_SETTINGS["TIME_FREEZE"]
            tint = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
            tint.fill(settings["screen_tint"])
            screen.blit(tint, (0, 0))

        # 7. Orbital Strike ë ˆì´ì € ë Œë”ë§
        for strike in self.orbital_strikes:
            if strike["active"] and strike["timer"] > 0:
                settings = config.ULTIMATE_SETTINGS["ORBITAL_STRIKE"]
                # ë ˆì´ì € ë¹” (ë¹¨ê°„ ì›)
                pygame.draw.circle(screen, settings["color"],
                                   (int(strike["pos"].x), int(strike["pos"].y)),
                                   settings["strike_radius"], 3)
                # ë‚´ë¶€ ë¹›ë‚˜ëŠ” íš¨ê³¼
                pygame.draw.circle(screen, (255, 200, 200),
                                   (int(strike["pos"].x), int(strike["pos"].y)),
                                   settings["strike_radius"] // 2)

        # 8. Ship Ability: Shield ì‹œê° íš¨ê³¼
        if getattr(self, 'shield_active', False):
            shield_hp = getattr(self, 'shield_hp', 0)
            shield_max = getattr(self, 'shield_max_hp', 1)
            shield_ratio = shield_hp / shield_max if shield_max > 0 else 0

            # ë³´í˜¸ë§‰ ë°˜ì§€ë¦„ (í”Œë ˆì´ì–´ í¬ê¸° ê¸°ë°˜)
            shield_radius = int(max(self.image.get_width(), self.image.get_height()) * 0.8)

            # í„ìŠ¤ íš¨ê³¼ (ì‹œê°„ì— ë”°ë¼ í¬ê¸° ë³€í™”)
            import math
            pulse = 1.0 + 0.05 * math.sin(pygame.time.get_ticks() * 0.01)
            shield_radius = int(shield_radius * pulse)

            # ì‰´ë“œ ìƒ‰ìƒ (HPì— ë”°ë¼ ë³€í™”)
            if shield_ratio > 0.5:
                shield_color = (100, 180, 255)  # íŒŒë‘
            elif shield_ratio > 0.25:
                shield_color = (255, 200, 100)  # ë…¸ë‘
            else:
                shield_color = (255, 100, 100)  # ë¹¨ê°•

            # ì™¸ê³½ ì› (ë‘êº¼ìš´ í…Œë‘ë¦¬)
            pygame.draw.circle(screen, shield_color,
                             (int(self.pos.x), int(self.pos.y)),
                             shield_radius, 4)

            # ë‚´ë¶€ ë°˜íˆ¬ëª… ì›
            shield_surface = pygame.Surface((shield_radius * 2, shield_radius * 2), pygame.SRCALPHA)
            pygame.draw.circle(shield_surface, (*shield_color, 40),
                             (shield_radius, shield_radius), shield_radius)
            screen.blit(shield_surface, (int(self.pos.x) - shield_radius, int(self.pos.y) - shield_radius))


# =========================================================
# 3. ì  í´ë˜ìŠ¤
# =========================================================

class Enemy:
    """ì  ìš°ì£¼ì„  í´ë˜ìŠ¤"""

    def __init__(self, pos: pygame.math.Vector2, screen_height: int, chase_probability: float = 1.0, enemy_type: str = "NORMAL"):

        # 0. ì  íƒ€ì… ì„¤ì •
        self.enemy_type = enemy_type
        self.type_config = config.ENEMY_TYPES.get(enemy_type, config.ENEMY_TYPES["NORMAL"])

        # 1. ìœ„ì¹˜ ë° ì´ë™
        self.pos = pos
        self.speed = config.ENEMY_BASE_SPEED * self.type_config["speed_mult"]
        self.chase_probability = chase_probability  # í”Œë ˆì´ì–´ ì¶”ì  í™•ë¥  (0.0 ~ 1.0)
        self.wander_direction = pygame.math.Vector2(random.uniform(-1, 1), random.uniform(-1, 1)).normalize()
        self.wander_timer = 0.0
        self.wander_change_interval = 2.0  # ë°©í™© ë°©í–¥ ë³€ê²½ ê°„ê²© (ì´ˆ)

        # 2. ìŠ¤íƒ¯ (íƒ€ì… ë°°ìœ¨ ì ìš©)
        self.max_hp = config.ENEMY_BASE_HP * self.type_config["hp_mult"]
        self.hp = self.max_hp
        self.damage = config.ENEMY_ATTACK_DAMAGE * self.type_config["damage_mult"]
        self.last_attack_time = 0.0
        self.coin_multiplier = self.type_config["coin_mult"]  # ì½”ì¸ ë“œë¡­ ë°°ìœ¨

        # 3. ì´ë¯¸ì§€ ë° íˆíŠ¸ë°•ìŠ¤ (íƒ€ì…ë³„ í¬ê¸° ì ìš©)
        size_ratio = config.IMAGE_SIZE_RATIOS["ENEMY"]
        image_size = int(screen_height * size_ratio * self.type_config["size_mult"])

        # ì´ë¯¸ì§€ ë¡œë“œ ë° ìƒ‰ìƒ tint ì ìš©
        original_image = AssetManager.get_image(config.ENEMY_SHIP_IMAGE_PATH, (image_size, image_size))
        self.color = self.type_config["color_tint"]  # ì‚¬ë§ íš¨ê³¼ìš© ìƒ‰ìƒ ì €ì¥
        self.size = image_size // 2  # ì‚¬ë§ íš¨ê³¼ìš© í¬ê¸° ì €ì¥ (ë°˜ì§€ë¦„)
        self.image = self._apply_color_tint(original_image, self.color)
        self.image_rect = self.image.get_rect(center=(self.pos.x, self.pos.y))

        hitbox_size = int(image_size * config.ENEMY_HITBOX_RATIO)
        self.hitbox = pygame.Rect(0, 0, hitbox_size, hitbox_size)
        self.hitbox.center = (int(self.pos.x), int(self.pos.y))

        self.is_alive = True
        self.is_boss = False  # ë³´ìŠ¤ ì—¬ë¶€

        # 4. íˆíŠ¸ í”Œë˜ì‹œ íš¨ê³¼ ì†ì„±
        self.hit_flash_timer = 0.0
        self.is_flashing = False
        self.original_image = self.image.copy()

        # 5. ì†ì„± ìŠ¤í‚¬ ìƒíƒœ ì´í™íŠ¸
        self.is_frozen = False  # ì™„ì „ ë™ê²° ìƒíƒœ
        self.freeze_timer = 0.0
        self.is_slowed = False  # ìŠ¬ë¡œìš° ìƒíƒœ
        self.slow_timer = 0.0
        self.slow_ratio = 0.0  # ìŠ¬ë¡œìš° ë¹„ìœ¨ (0.0 ~ 1.0)
        self.base_speed = self.speed  # ê¸°ë³¸ ì†ë„ ì €ì¥

        # 6. í¬ìœ„ ê³µê²©ìš© ê³ ìœ  ID (í•´ì‹œê°’ ì‚¬ìš©)
        self.enemy_id = id(self)  # ê°ì²´ì˜ ê³ ìœ  ID

        # 7. íƒ€ì…ë³„ íŠ¹ìˆ˜ ëŠ¥ë ¥
        # SHIELDED: ì¬ìƒ ë³´í˜¸ë§‰
        self.has_shield = self.type_config.get("has_shield", False)
        self.shield_regen_rate = self.type_config.get("shield_regen_rate", 0.0)
        self.last_regen_time = 0.0

        # SUMMONER: ì‚¬ë§ ì‹œ ì†Œí™˜
        self.summon_on_death = self.type_config.get("summon_on_death", False)
        self.summon_count = self.type_config.get("summon_count", 0)

        # KAMIKAZE: ìí­
        self.explode_on_contact = self.type_config.get("explode_on_contact", False)
        self.explosion_damage = self.type_config.get("explosion_damage", 0.0)
        self.explosion_radius = self.type_config.get("explosion_radius", 0)
        self.has_exploded = False  # ìí­ ì—¬ë¶€ (í•œ ë²ˆë§Œ í­ë°œ)

        # 8. ì›¨ì´ë¸Œ ì „í™˜ AI ëª¨ë“œ
        self.is_respawned = self.type_config.get("is_respawned", False)  # ë¦¬ìŠ¤í° ì  ì—¬ë¶€
        self.is_retreating = False  # í‡´ê° ëª¨ë“œ (ê¸°ì¡´ ì )
        self.is_circling = False    # íšŒì „ ê³µê²© ëª¨ë“œ (ë¹¨ê°„ ì )
        self.circle_angle = random.uniform(0, 2 * math.pi)  # íšŒì „ ì‹œì‘ ê°ë„ (ëœë¤)
        self.retreat_target = None  # í‡´ê° ëª©í‘œ ìœ„ì¹˜
        self.escaped = False  # í™”ë©´ ë°–ìœ¼ë¡œ ë„ë§ ì„±ê³µ ì—¬ë¶€ (í‚¬ ì¹´ìš´íŠ¸ ì œì™¸ìš©)

    def _apply_color_tint(self, image: pygame.Surface, tint_color: tuple) -> pygame.Surface:
        """ì´ë¯¸ì§€ì— ìƒ‰ìƒ tintë¥¼ ì ìš©í•©ë‹ˆë‹¤."""
        if tint_color == (255, 255, 255):
            return image  # ì›ë³¸ ìƒ‰ìƒ ê·¸ëŒ€ë¡œ

        # ìƒˆ surface ìƒì„± (ì•ŒíŒŒ ì±„ë„ ìœ ì§€)
        tinted = image.copy()

        # ìƒ‰ìƒ overlay ì ìš© (BLEND_RGB_MULT ëŒ€ì‹  BLEND_RGBA_MULT ì‚¬ìš©)
        color_overlay = pygame.Surface(image.get_size(), pygame.SRCALPHA)
        color_overlay.fill((*tint_color, 128))  # ë°˜íˆ¬ëª… ìƒ‰ìƒ
        tinted.blit(color_overlay, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)

        return tinted

    def move_towards_player(self, player_pos: pygame.math.Vector2, dt: float, other_enemies: list = None):
        """í”Œë ˆì´ì–´ë¥¼ í–¥í•´ ì´ë™í•˜ë˜, ë‹¤ë¥¸ ì ë“¤ê³¼ ê±°ë¦¬ë¥¼ ìœ ì§€í•˜ê³  í¬ìœ„ ê³µê²©í•©ë‹ˆë‹¤."""

        direction = player_pos - self.pos
        distance_to_player = direction.length()

        if direction.length_squared() > 0:
            direction = direction.normalize()

            # í¬ìœ„ ê³µê²©: í”Œë ˆì´ì–´ ì£¼ë³€ì— ì›í˜•ìœ¼ë¡œ ë¶„ì‚°
            flank_force = pygame.math.Vector2(0, 0)
            if config.ENEMY_FLANK_ENABLED and distance_to_player < config.ENEMY_FLANK_DISTANCE:
                # ì ì˜ IDë¥¼ ê¸°ë°˜ìœ¼ë¡œ ëª©í‘œ ê°ë„ ê³„ì‚° (ê° ì ë§ˆë‹¤ ê³ ìœ í•œ ê°ë„)
                import math
                base_angle = (self.enemy_id % 360) * (math.pi / 180)  # ID ê¸°ë°˜ ê°ë„

                # í”Œë ˆì´ì–´ ì¤‘ì‹¬ìœ¼ë¡œ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
                target_offset_x = math.cos(base_angle) * config.ENEMY_FLANK_DISTANCE
                target_offset_y = math.sin(base_angle) * config.ENEMY_FLANK_DISTANCE
                target_pos = pygame.math.Vector2(player_pos.x + target_offset_x, player_pos.y + target_offset_y)

                # ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™í•˜ëŠ” í˜
                to_target = target_pos - self.pos
                if to_target.length_squared() > 0:
                    flank_force = to_target.normalize() * 0.5  # í¬ìœ„ í˜

            # ê¸°ë³¸ ì¶”ì  ë°©í–¥ì— í¬ìœ„ í˜ ì¶”ê°€
            direction = direction + flank_force
            if direction.length_squared() > 0:
                direction = direction.normalize()

            # ë¶„ë¦¬ í–‰ë™ (Separation): ë‹¤ë¥¸ ì ë“¤ê³¼ ê±°ë¦¬ ìœ ì§€ - ê°•í™” ë²„ì „
            separation_force = pygame.math.Vector2(0, 0)
            if other_enemies:
                # ë³´ìŠ¤ëŠ” ë” í° ë¶„ë¦¬ ë°˜ê²½ ì‚¬ìš©
                if hasattr(self, 'is_boss') and self.is_boss:
                    separation_radius = config.ENEMY_SEPARATION_RADIUS * 3.0  # ë³´ìŠ¤ëŠ” 3ë°°
                    separation_strength = config.ENEMY_SEPARATION_STRENGTH * 2.0  # ë³´ìŠ¤ëŠ” 2ë°° ê°•ë„
                else:
                    separation_radius = config.ENEMY_SEPARATION_RADIUS
                    separation_strength = config.ENEMY_SEPARATION_STRENGTH

                separation_count = 0
                for other in other_enemies:
                    if other is not self and other.is_alive:
                        diff = self.pos - other.pos
                        distance = diff.length()

                        # ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë°€ì–´ë‚´ê¸°
                        if 0 < distance < separation_radius:
                            # ê±°ë¦¬ì— ë°˜ë¹„ë¡€í•˜ëŠ” í˜ (ê°€ê¹Œìš¸ìˆ˜ë¡ ê°•í•¨)
                            # ì œê³± ë°˜ë¹„ë¡€ë¡œ ë³€ê²½í•˜ì—¬ ê°€ê¹Œìš¸ìˆ˜ë¡ í›¨ì”¬ ê°•í•˜ê²Œ
                            force_magnitude = ((separation_radius - distance) / separation_radius) ** 2
                            if distance > 0:
                                diff_normalized = diff.normalize()
                                separation_force += diff_normalized * force_magnitude
                                separation_count += 1

                # ë¶„ë¦¬ í˜ ì ìš© (ì •ê·œí™”í•˜ì§€ ì•Šê³  ê°•ë„ë§Œ ê³±í•¨)
                if separation_force.length_squared() > 0:
                    # ì—¬ëŸ¬ ì ê³¼ ê²¹ì¹ ìˆ˜ë¡ ë” ê°•í•œ ë¶„ë¦¬ í˜
                    separation_force = separation_force * separation_strength

            # ìµœì¢… ì´ë™ ë°©í–¥ = í”Œë ˆì´ì–´ ì¶”ì  + ë¶„ë¦¬ í–‰ë™
            # ë¶„ë¦¬ í˜ì´ ê°•í•  ë•ŒëŠ” ì¶”ì ë³´ë‹¤ ë¶„ë¦¬ ìš°ì„ 
            separation_magnitude = separation_force.length()
            if separation_magnitude > 1.0:
                # ë¶„ë¦¬ í˜ì´ ê°•í•˜ë©´ ì¶”ì  ë°©í–¥ì˜ ì˜í–¥ì„ ì¤„ì„
                direction_weight = max(0.3, 1.0 - (separation_magnitude * 0.3))
                final_direction = direction * direction_weight + separation_force
            else:
                final_direction = direction + separation_force

            if final_direction.length_squared() > 0:
                final_direction = final_direction.normalize()

            self.pos += final_direction * self.speed * dt

            # rect ë° hitbox ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            self.image_rect.center = (int(self.pos.x), int(self.pos.y))
            self.hitbox.center = self.image_rect.center

    def take_damage(self, damage: float, player=None):
        """í”¼í•´ë¥¼ ì…ìŠµë‹ˆë‹¤."""
        # Execute ìŠ¤í‚¬: ì²´ë ¥ ì„ê³„ê°’ ì´í•˜ ì  ì¦‰ì‚¬
        if player and hasattr(player, 'execute_threshold') and player.execute_threshold > 0:
            hp_ratio = self.hp / self.max_hp
            if hp_ratio <= player.execute_threshold:
                self.hp = 0
                self.is_alive = False
                return  # ì¦‰ì‹œ ì¢…ë£Œ

        self.hp -= damage
        if self.hp <= 0:
            self.is_alive = False
        else:
            # íˆíŠ¸ í”Œë˜ì‹œ íŠ¸ë¦¬ê±°
            self.hit_flash_timer = config.HIT_FLASH_DURATION
            self.is_flashing = True

    def attack(self, player: 'Player', current_time: float) -> bool:
        """í”Œë ˆì´ì–´ë¥¼ ê³µê²©í•©ë‹ˆë‹¤. ê³µê²© ì„±ê³µ ì‹œ True ë°˜í™˜"""
        if current_time - self.last_attack_time >= config.ENEMY_ATTACK_COOLDOWN:
            player.take_damage(self.damage)
            self.last_attack_time = current_time
            return True
        return False

    def update(self, player_pos: pygame.math.Vector2, dt: float, other_enemies: list = None, screen_size: tuple = None, current_time: float = 0.0):
        """ì ì˜ ìƒíƒœë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤."""
        if self.is_alive:
            # SHIELDED íƒ€ì…: ë³´í˜¸ë§‰ ì¬ìƒ
            if self.has_shield and self.hp < self.max_hp:
                regen_amount = self.max_hp * self.shield_regen_rate * dt
                self.hp = min(self.max_hp, self.hp + regen_amount)

            # ìƒíƒœ ì´í™íŠ¸ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
            # í”„ë¦¬ì¦ˆ ìƒíƒœ ì—…ë°ì´íŠ¸
            if self.is_frozen:
                self.freeze_timer -= dt
                if self.freeze_timer <= 0:
                    self.is_frozen = False
                # í”„ë¦¬ì¦ˆ ìƒíƒœë©´ ì´ë™ ì•ˆí•¨
                return

            # ìŠ¬ë¡œìš° ìƒíƒœ ì—…ë°ì´íŠ¸
            if self.is_slowed:
                self.slow_timer -= dt
                if self.slow_timer <= 0:
                    self.is_slowed = False
                    self.speed = self.base_speed  # ì†ë„ ë³µêµ¬

            # === ì›¨ì´ë¸Œ ì „í™˜ AI ëª¨ë“œ ===
            # 1. í‡´ê° ëª¨ë“œ (ê¸°ì¡´ ì  - ì™¸ê³½ìœ¼ë¡œ ì´ë™)
            if self.is_retreating:
                self._retreat_to_edge(dt, screen_size)
                return

            # 2. íšŒì „ ê³µê²© ëª¨ë“œ (ë¹¨ê°„ ì  - í”Œë ˆì´ì–´ ì£¼ìœ„ íšŒì „)
            if self.is_circling:
                self._circle_around_player(player_pos, dt)
                # íˆíŠ¸ í”Œë˜ì‹œ ì—…ë°ì´íŠ¸ í›„ ë¦¬í„´
                if self.is_flashing:
                    self.hit_flash_timer -= dt
                    if self.hit_flash_timer <= 0:
                        self.is_flashing = False
                        self.image = self.original_image.copy()
                return

            # === ì¼ë°˜ AI ëª¨ë“œ ===
            # ì¶”ì  í™•ë¥ ì— ë”°ë¼ í”Œë ˆì´ì–´ë¥¼ ì¶”ì í• ì§€ ê²°ì •
            if random.random() < self.chase_probability:
                # í”Œë ˆì´ì–´ë¥¼ ì¶”ì  (ë‹¤ë¥¸ ì ë“¤ ì •ë³´ ì „ë‹¬)
                self.move_towards_player(player_pos, dt, other_enemies)
            else:
                # ë°©í™© ëª¨ë“œ: ëœë¤ ë°©í–¥ìœ¼ë¡œ ì´ë™
                self.wander_timer += dt
                if self.wander_timer >= self.wander_change_interval:
                    # ìƒˆë¡œìš´ ëœë¤ ë°©í–¥ ì„¤ì •
                    self.wander_direction = pygame.math.Vector2(random.uniform(-1, 1), random.uniform(-1, 1)).normalize()
                    self.wander_timer = 0.0

                # ë°©í™© ë°©í–¥ìœ¼ë¡œ ì´ë™
                self.pos += self.wander_direction * self.speed * dt * 0.5  # ë°©í™© ì‹œ ì†ë„ 50%
                self.image_rect.center = (int(self.pos.x), int(self.pos.y))
                self.hitbox.center = self.image_rect.center

            # íˆíŠ¸ í”Œë˜ì‹œ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
            if self.is_flashing:
                self.hit_flash_timer -= dt
                if self.hit_flash_timer <= 0:
                    self.is_flashing = False
                    self.image = self.original_image.copy()

    def _retreat_to_edge(self, dt: float, screen_size: tuple = None):
        """í™”ë©´ ìƒë¶€ë¡œ ì„œì„œíˆ í‡´ê°"""
        if screen_size is None:
            screen_size = (1920, 1080)  # ê¸°ë³¸ê°’

        # í‡´ê° ëª©í‘œ: í•­ìƒ í™”ë©´ ìƒë¶€ (í˜„ì¬ x ìœ„ì¹˜ ìœ ì§€)
        if self.retreat_target is None:
            margin = 100  # í™”ë©´ ë°– ì—¬ìœ 
            self.retreat_target = pygame.math.Vector2(self.pos.x, -margin)

        # ëª©í‘œë¥¼ í–¥í•´ ì„œì„œíˆ ì´ë™
        direction = self.retreat_target - self.pos
        distance = direction.length()

        if distance > 5:  # ì•„ì§ ë„ì°© ì•ˆí•¨
            direction = direction.normalize()
            # ì„œì„œíˆ ì´ë™ (ì†ë„ 0.5ë°°)
            self.pos += direction * self.speed * 0.5 * dt
            self.image_rect.center = (int(self.pos.x), int(self.pos.y))
            self.hitbox.center = self.image_rect.center
        else:
            # í™”ë©´ ë°– ë„ë‹¬ - ì œê±° ëŒ€ìƒìœ¼ë¡œ í‘œì‹œ (ë„ë§ ì„±ê³µ)
            self.escaped = True  # ê³µê²©ì´ ì•„ë‹Œ ë„ë§ìœ¼ë¡œ ì‚¬ë¼ì§
            self.is_alive = False

    def _circle_around_player(self, player_pos: pygame.math.Vector2, dt: float):
        """í”Œë ˆì´ì–´ ì£¼ìœ„ 80í”½ì…€ì—ì„œ íšŒì „í•˜ë©° ê³µê²© ê¸°íšŒë¥¼ ë…¸ë¦¼"""
        orbit_radius = 80  # íšŒì „ ë°˜ê²½
        orbit_speed = 2.0  # íšŒì „ ì†ë„ (rad/s)

        # íšŒì „ ê°ë„ ì—…ë°ì´íŠ¸
        self.circle_angle += orbit_speed * dt

        # ëª©í‘œ ìœ„ì¹˜ ê³„ì‚° (í”Œë ˆì´ì–´ ì£¼ìœ„ ì›í˜• ê¶¤ë„)
        target_x = player_pos.x + math.cos(self.circle_angle) * orbit_radius
        target_y = player_pos.y + math.sin(self.circle_angle) * orbit_radius
        target_pos = pygame.math.Vector2(target_x, target_y)

        # í˜„ì¬ ìœ„ì¹˜ì—ì„œ ëª©í‘œ ìœ„ì¹˜ë¡œ ë¶€ë“œëŸ½ê²Œ ì´ë™
        direction = target_pos - self.pos
        distance = direction.length()

        if distance > 1:
            # ë¹ ë¥´ê²Œ ê¶¤ë„ë¡œ ì§„ì…, ê¶¤ë„ ë„ë‹¬ í›„ íšŒì „ ìœ ì§€
            move_speed = self.speed * 2 if distance > orbit_radius else self.speed
            direction = direction.normalize()
            self.pos += direction * move_speed * dt

        self.image_rect.center = (int(self.pos.x), int(self.pos.y))
        self.hitbox.center = self.image_rect.center

    def _calculate_perspective_scale(self, screen_height: int) -> float:
        """Y ìœ„ì¹˜ ê¸°ë°˜ ì›ê·¼ê° ìŠ¤ì¼€ì¼ ê³„ì‚°"""
        if not config.PERSPECTIVE_ENABLED or not config.PERSPECTIVE_APPLY_TO_ENEMIES:
            return 1.0

        # Y ìœ„ì¹˜ ë¹„ìœ¨ ê³„ì‚° (0.0 = ìƒë‹¨, 1.0 = í•˜ë‹¨)
        depth_ratio = self.pos.y / screen_height
        depth_ratio = max(0.0, min(1.0, depth_ratio))  # 0~1 ë²”ìœ„ë¡œ ì œí•œ

        # ìŠ¤ì¼€ì¼ ê³„ì‚° (ìƒë‹¨ = ì‘ê²Œ, í•˜ë‹¨ = í¬ê²Œ)
        scale = config.PERSPECTIVE_SCALE_MIN + (depth_ratio * (config.PERSPECTIVE_SCALE_MAX - config.PERSPECTIVE_SCALE_MIN))
        return scale

    # âœ… [ì¶”ê°€] í™”ë©´ì— ê°ì²´ë¥¼ ê·¸ë¦¬ëŠ” draw ë©”ì„œë“œ
    def draw(self, screen: pygame.Surface):
        """ì  ê°ì²´ë¥¼ í™”ë©´ì— ê·¸ë¦¬ê³  ì²´ë ¥ ë°”ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."""
        # ì›ê·¼ê° ìŠ¤ì¼€ì¼ ê³„ì‚°
        perspective_scale = self._calculate_perspective_scale(screen.get_height())

        # íˆíŠ¸ í”Œë˜ì‹œ ì ìš©
        if self.is_flashing:
            flash_surface = self.original_image.copy()
            flash_surface.fill(config.HIT_FLASH_COLOR, special_flags=pygame.BLEND_RGB_ADD)
            current_image = flash_surface
        else:
            current_image = self.image

        # ì›ê·¼ê° ì ìš©ëœ ì´ë¯¸ì§€ ìƒì„±
        if config.PERSPECTIVE_ENABLED and config.PERSPECTIVE_APPLY_TO_ENEMIES and perspective_scale != 1.0:
            scaled_image = pygame.transform.smoothscale(
                current_image,
                (int(current_image.get_width() * perspective_scale),
                 int(current_image.get_height() * perspective_scale))
            )
            scaled_rect = scaled_image.get_rect(center=self.image_rect.center)
        else:
            scaled_image = current_image
            scaled_rect = self.image_rect

        # ìƒíƒœ ì´í™íŠ¸ ì‹œê° íš¨ê³¼ (ì´ë¯¸ì§€ ë’¤ì— ê´‘ì„  íš¨ê³¼)
        if self.is_frozen:
            # í”„ë¦¬ì¦ˆ: ë°ì€ ì²­ë°±ìƒ‰ ê´‘ì„  íš¨ê³¼
            self._draw_glow_effect(screen, (180, 220, 255), intensity=3, layers=3, scale=perspective_scale)
        elif self.is_slowed:
            # ìŠ¬ë¡œìš°: íŒŒë€ìƒ‰ ê´‘ì„  íš¨ê³¼
            self._draw_glow_effect(screen, (100, 150, 255), intensity=2, layers=2, scale=perspective_scale)

        # ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        screen.blit(scaled_image, scaled_rect)

        # ì²´ë ¥ ë°” ê·¸ë¦¬ê¸°
        self.draw_health_bar(screen, perspective_scale)

    def draw_health_bar(self, screen: pygame.Surface, perspective_scale: float = 1.0):
        """ì ì˜ í˜„ì¬ ì²´ë ¥ì„ ì´ë¯¸ì§€ ìœ„ì— ì‘ì€ ë°”ë¡œ í‘œì‹œí•©ë‹ˆë‹¤."""

        # ì²´ë ¥ ë°”ë¥¼ ì´ë¯¸ì§€ ë„ˆë¹„ì˜ 35%ë¡œ ì¶•ì†Œ (1/2 í¬ê¸°, ì›ê·¼ê° ìŠ¤ì¼€ì¼ ì ìš©)
        bar_width = int(self.image_rect.width * 0.35 * perspective_scale)
        bar_height = max(2, int(3 * perspective_scale))  # ìµœì†Œ 2í”½ì…€
        # ì²´ë ¥ ë°”ë¥¼ ì´ë¯¸ì§€ ìƒë‹¨ ì •ì¤‘ì•™ì— ë°°ì¹˜
        bar_x = self.image_rect.centerx - bar_width // 2
        # ì´ë¯¸ì§€ ìƒë‹¨ì— ë°”ë¡œ ë¶™ì„ (ì´ë¯¸ì§€ ë‚´ë¶€ ìƒë‹¨)
        bar_y = self.image_rect.top + 2

        # ë°°ê²½ (ê²€ì€ìƒ‰)
        pygame.draw.rect(screen, config.BLACK, (bar_x, bar_y, bar_width, bar_height))

        # í˜„ì¬ ì²´ë ¥ (ì´ˆë¡ìƒ‰)
        health_ratio = self.hp / self.max_hp
        current_health_width = int(bar_width * health_ratio)
        pygame.draw.rect(screen, config.GREEN, (bar_x, bar_y, current_health_width, bar_height))

    def _draw_glow_effect(self, screen: pygame.Surface, color: tuple, intensity: int = 2, layers: int = 2, scale: float = 1.0):
        """ì´ë¯¸ì§€ ìœ¤ê³½ì„  ê¸°ë°˜ ê´‘ì„  íš¨ê³¼ (Glow Effect)"""
        # ì´ë¯¸ì§€ì˜ ì•ŒíŒŒ ì±„ë„ì„ ì´ìš©í•œ ë§ˆìŠ¤í¬ ìƒì„±
        try:
            # ì´ë¯¸ì§€ë¥¼ ë³µì‚¬í•˜ì—¬ ë§ˆìŠ¤í¬ ìƒì„±
            glow_surface = pygame.Surface(self.image.get_size(), pygame.SRCALPHA)

            # ì—¬ëŸ¬ ë ˆì´ì–´ë¡œ ê´‘ì„  íš¨ê³¼ ìƒì„±
            for layer in range(layers, 0, -1):
                # ê° ë ˆì´ì–´ë§ˆë‹¤ í¬ê¸°ì™€ íˆ¬ëª…ë„ ì¡°ì •
                scale_factor = 1.0 + (layer * intensity * 0.02)  # 2%ì”© í™•ëŒ€
                scale_factor *= scale  # ì›ê·¼ê° ìŠ¤ì¼€ì¼ ì ìš©
                alpha = int(80 / layer)  # ë ˆì´ì–´ë§ˆë‹¤ íˆ¬ëª…ë„ ê°ì†Œ

                # í™•ëŒ€ëœ ì´ë¯¸ì§€ ìƒì„±
                scaled_size = (
                    int(self.image.get_width() * scale_factor),
                    int(self.image.get_height() * scale_factor)
                )
                scaled_image = pygame.transform.scale(self.image, scaled_size)

                # ìƒ‰ìƒ ì ìš©
                colored_surface = scaled_image.copy()
                colored_surface.fill(color + (0,), special_flags=pygame.BLEND_RGBA_MULT)
                colored_surface.fill((255, 255, 255, alpha), special_flags=pygame.BLEND_RGBA_MIN)

                # ì¤‘ì•™ ì •ë ¬í•˜ì—¬ ê·¸ë¦¬ê¸°
                offset_x = (scaled_size[0] - self.image.get_width()) // 2
                offset_y = (scaled_size[1] - self.image.get_height()) // 2
                glow_rect = colored_surface.get_rect(center=self.image_rect.center)
                screen.blit(colored_surface, glow_rect)
        except:
            # ê´‘ì„  íš¨ê³¼ ì‹¤íŒ¨ ì‹œ ì›í˜• ê´‘ì„ ìœ¼ë¡œ í´ë°±
            for layer in range(layers, 0, -1):
                radius = self.image_rect.width // 2 + layer * intensity
                alpha = int(60 / layer)

                glow_surf = pygame.Surface((radius * 2, radius * 2), pygame.SRCALPHA)
                pygame.draw.circle(glow_surf, color + (alpha,), (radius, radius), radius)
                glow_rect = glow_surf.get_rect(center=self.image_rect.center)
                screen.blit(glow_surf, glow_rect)

# =========================================================
# 4. ì´ì•Œ í´ë˜ìŠ¤
# =========================================================

class Bullet:
    """ì´ì•Œ í´ë˜ìŠ¤"""

    def __init__(self, pos: pygame.math.Vector2, direction: pygame.math.Vector2, damage: float, piercing: bool = False):

        # 1. ìœ„ì¹˜ ë° ì´ë™
        self.pos = pos
        self.direction = direction.normalize()
        self.speed = config.BULLET_SPEED

        # 2. ìŠ¤íƒ¯
        self.damage = damage
        self.is_alive = True

        # 3. í”¼ì–´ì‹± ê¸°ëŠ¥
        self.is_piercing = piercing
        self.pierce_count = 0  # ê´€í†µí•œ ì  ìˆ˜ (ìµœëŒ€ê°’ ë„ë‹¬ ì‹œ ì œê±°)
        self.hit_enemies = set()  # ì´ë¯¸ ë§ì¶˜ ì  ID ì§‘í•© (ì¤‘ë³µ í”¼ê²© ë°©ì§€)

        # 4. ì´ì•Œ íŠ¸ë ˆì¼ (ì”ìƒ)
        self.trail_positions = []  # ì´ì „ ìœ„ì¹˜ë“¤ ì €ì¥

        # 5. ìŠ¤í° ì‹œê°„ (ë²½ ì¶©ëŒ ìœ ì˜ˆ ê¸°ê°„ìš©)
        self.spawn_time = pygame.time.get_ticks()

        # 6. ì´ë¯¸ì§€ ë° íˆíŠ¸ë°•ìŠ¤
        # bullet_imageëŠ” asset_managerì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©í•˜ë¯€ë¡œ ìµœì´ˆ 1íšŒë§Œ ë¡œë“œ

    def initialize_image(self, screen_height: int):
        """í™”ë©´ í¬ê¸°ì— ë§ê²Œ ì´ì•Œ ì´ë¯¸ì§€ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."""

        size_ratio = config.IMAGE_SIZE_RATIOS["BULLET"]
        image_size = int(screen_height * size_ratio)

        self.image = AssetManager.get_image(config.PLAYER_BULLET_IMAGE_PATH, (image_size, image_size))
        self.image_rect = self.image.get_rect(center=(self.pos.x, self.pos.y))

        hitbox_size = int(image_size * config.BULLET_HITBOX_RATIO)
        self.hitbox = pygame.Rect(0, 0, hitbox_size, hitbox_size)
        self.hitbox.center = (int(self.pos.x), int(self.pos.y))

    def update(self, dt: float, screen_size: Tuple[int, int]):
        """ì´ì•Œ ìœ„ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•˜ê³ , í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±°í•©ë‹ˆë‹¤."""

        if not hasattr(self, 'image'):
            # ì²« update ì‹œ ì´ë¯¸ì§€ ì´ˆê¸°í™”
            self.initialize_image(screen_size[1])

        if self.is_alive:
            # í˜„ì¬ ìœ„ì¹˜ë¥¼ íŠ¸ë ˆì¼ì— ì¶”ê°€
            self.trail_positions.append(self.pos.copy())

            # íŠ¸ë ˆì¼ ê¸¸ì´ ì œí•œ
            if len(self.trail_positions) > config.BULLET_TRAIL_LENGTH:
                self.trail_positions.pop(0)

            self.pos += self.direction * self.speed * dt
            self.image_rect.center = (int(self.pos.x), int(self.pos.y))
            self.hitbox.center = self.image_rect.center

            # í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±°
            SCREEN_WIDTH, SCREEN_HEIGHT = screen_size
            if (self.pos.x < -50 or self.pos.x > SCREEN_WIDTH + 50 or
                self.pos.y < -50 or self.pos.y > SCREEN_HEIGHT + 50):
                self.is_alive = False

    def draw(self, screen: pygame.Surface):
        """ì´ì•Œ ê°ì²´ì™€ íŠ¸ë ˆì¼ì„ í™”ë©´ì— ê·¸ë¦½ë‹ˆë‹¤."""
        if self.is_alive:
            # ì´ë¯¸ì§€ê°€ ì•„ì§ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ë‹¤ë©´ í´ë°± ë Œë”ë§
            if not hasattr(self, 'image') or self.image is None:
                # ê°„ë‹¨í•œ ì›ìœ¼ë¡œ ê·¸ë¦¬ê¸° (í´ë°±)
                pygame.draw.circle(screen, (255, 0, 0), (int(self.pos.x), int(self.pos.y)), 20, 0)
                pygame.draw.circle(screen, (255, 255, 0), (int(self.pos.x), int(self.pos.y)), 20, 3)
                return

            # ì›ê·¼ê° ìŠ¤ì¼€ì¼ ê³„ì‚°
            perspective_scale = self._calculate_perspective_scale(screen.get_height())

            # ì›ê·¼ê° ì ìš©ëœ ì´ë¯¸ì§€
            if config.PERSPECTIVE_ENABLED and config.PERSPECTIVE_APPLY_TO_BULLETS and perspective_scale != 1.0:
                scaled_image = pygame.transform.scale(
                    self.image,
                    (int(self.image.get_width() * perspective_scale),
                     int(self.image.get_height() * perspective_scale))
                )
                scaled_rect = scaled_image.get_rect(center=self.image_rect.center)
            else:
                scaled_image = self.image
                scaled_rect = self.image_rect

            # íŠ¸ë ˆì¼ ê·¸ë¦¬ê¸° (ë’¤ì—ì„œë¶€í„° ì•ìœ¼ë¡œ, ì ì  íˆ¬ëª…í•˜ê²Œ)
            for i, trail_pos in enumerate(self.trail_positions):
                alpha = int(255 * (i + 1) / len(self.trail_positions) * config.BULLET_TRAIL_ALPHA_DECAY)
                alpha = max(0, min(255, alpha))

                # íŠ¸ë ˆì¼ìš© ë°˜íˆ¬ëª… ì„œí”¼ìŠ¤ ìƒì„±
                trail_surf = scaled_image.copy()
                trail_surf.set_alpha(alpha)
                trail_rect = trail_surf.get_rect(center=(int(trail_pos.x), int(trail_pos.y)))
                screen.blit(trail_surf, trail_rect)

            # ì´ì•Œ ë³¸ì²´ ê·¸ë¦¬ê¸°
            screen.blit(scaled_image, scaled_rect)

    def _calculate_perspective_scale(self, screen_height: int) -> float:
        """Y ìœ„ì¹˜ ê¸°ë°˜ ì›ê·¼ê° ìŠ¤ì¼€ì¼ ê³„ì‚°"""
        if not config.PERSPECTIVE_ENABLED or not config.PERSPECTIVE_APPLY_TO_BULLETS:
            return 1.0

        # Y ìœ„ì¹˜ ë¹„ìœ¨ ê³„ì‚° (0.0 = ìƒë‹¨, 1.0 = í•˜ë‹¨)
        depth_ratio = self.pos.y / screen_height
        depth_ratio = max(0.0, min(1.0, depth_ratio))

        # ìŠ¤ì¼€ì¼ ê³„ì‚°
        scale = config.PERSPECTIVE_SCALE_MIN + (depth_ratio * (config.PERSPECTIVE_SCALE_MAX - config.PERSPECTIVE_SCALE_MIN))
        return scale

# =========================================================
# 5. ì•„ì´í…œ í´ë˜ìŠ¤
# =========================================================

class CoinGem:
    """ì½”ì¸/ì ¬ í´ë˜ìŠ¤ (ì ì„ ì£½ì´ë©´ ë“œë¡­)"""

    COIN_AMOUNT = config.BASE_COIN_DROP_PER_KILL # ì½”ì¸ íšë“ ì‹œ ì ìˆ˜

    def __init__(self, pos: Tuple[float, float], screen_height: int):

        # 1. ìœ„ì¹˜
        self.pos = pygame.math.Vector2(pos)

        # 2. ìƒíƒœ
        self.collected = False

        # 3. ì´ë¯¸ì§€ ë° íˆíŠ¸ë°•ìŠ¤
        size_ratio = config.IMAGE_SIZE_RATIOS["COINGEM"]
        image_size = int(screen_height * size_ratio)

        self.image = AssetManager.get_image(config.COIN_GEM_IMAGE_PATH, (image_size, image_size))
        self.image_rect = self.image.get_rect(center=(self.pos.x, self.pos.y))

        hitbox_size = int(image_size * config.GEM_HITBOX_RATIO)
        self.hitbox = pygame.Rect(0, 0, hitbox_size, hitbox_size)
        self.hitbox.center = (int(self.pos.x), int(self.pos.y))

    def update(self, dt: float, player):
        """
        ìì„ íš¨ê³¼ê°€ ìˆìœ¼ë©´ í”Œë ˆì´ì–´ì—ê²Œ ëŒì–´ë‹¹ê¹ë‹ˆë‹¤.
        """
        # ìì„ íš¨ê³¼ í™•ì¸ (playerì— has_coin_magnet ì†ì„±ì´ ìˆë‹¤ë©´)
        has_coin_magnet = getattr(player, 'has_coin_magnet', False)

        if not self.collected and has_coin_magnet:
            # í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ ê³„ì‚°
            direction = player.pos - self.pos
            distance = direction.length()

            # ìì„ íš¨ê³¼ ë²”ìœ„ (í”Œë ˆì´ì–´ ì´ë¯¸ì§€ í¬ê¸°ì˜ 10ë°° ì •ë„ë¡œ ê°€ì •)
            MAGNET_RANGE = player.image_rect.width * 10

            if distance < MAGNET_RANGE:
                # í”Œë ˆì´ì–´ì—ê²Œ ëŒì–´ë‹¹ê¸°ëŠ” ì†ë„ (ê±°ë¦¬ì™€ ë¹„ë¡€)
                MAGNET_SPEED = 500.0
                if distance > 0:
                    direction = direction.normalize()
                    # ì´ë™ ì†ë„ë¥¼ dtì™€ MAGNET_SPEEDë¡œ ê³„ì‚°
                    self.pos += direction * MAGNET_SPEED * dt
                    self.image_rect.center = (int(self.pos.x), int(self.pos.y))
                    self.hitbox.center = self.image_rect.center

    def collect(self, game_data: Dict) -> bool:
        """ì ¬ ìˆ˜ì§‘ íš¨ê³¼ ì ìš© (ì ìˆ˜ ì¦ê°€)"""
        if not self.collected:
            # ì˜êµ¬ ì½”ì¸ê³¼ ë ˆë²¨ì—… ì ìˆ˜ ëª¨ë‘ ì¦ê°€
            game_data['score'] += self.COIN_AMOUNT
            game_data['uncollected_score'] += self.COIN_AMOUNT
            self.collected = True
            return True
        return False

    def draw(self, screen: pygame.Surface):
        """ì ¬ ê°ì²´ë¥¼ í™”ë©´ì— ê·¸ë¦½ë‹ˆë‹¤."""
        if not self.collected:
            # ì›ê·¼ê° ìŠ¤ì¼€ì¼ ê³„ì‚°
            perspective_scale = self._calculate_perspective_scale(screen.get_height())

            # ì›ê·¼ê° ì ìš©ëœ ì´ë¯¸ì§€
            if config.PERSPECTIVE_ENABLED and config.PERSPECTIVE_APPLY_TO_GEMS and perspective_scale != 1.0:
                scaled_image = pygame.transform.scale(
                    self.image,
                    (int(self.image.get_width() * perspective_scale),
                     int(self.image.get_height() * perspective_scale))
                )
                scaled_rect = scaled_image.get_rect(center=self.image_rect.center)
                screen.blit(scaled_image, scaled_rect)
            else:
                screen.blit(self.image, self.image_rect)

    def _calculate_perspective_scale(self, screen_height: int) -> float:
        """Y ìœ„ì¹˜ ê¸°ë°˜ ì›ê·¼ê° ìŠ¤ì¼€ì¼ ê³„ì‚°"""
        if not config.PERSPECTIVE_ENABLED or not config.PERSPECTIVE_APPLY_TO_GEMS:
            return 1.0

        # Y ìœ„ì¹˜ ë¹„ìœ¨ ê³„ì‚° (0.0 = ìƒë‹¨, 1.0 = í•˜ë‹¨)
        depth_ratio = self.pos.y / screen_height
        depth_ratio = max(0.0, min(1.0, depth_ratio))

        # ìŠ¤ì¼€ì¼ ê³„ì‚°
        scale = config.PERSPECTIVE_SCALE_MIN + (depth_ratio * (config.PERSPECTIVE_SCALE_MAX - config.PERSPECTIVE_SCALE_MIN))
        return scale


class HealItem:
    """ì²´ë ¥ íšŒë³µ ì•„ì´í…œ í´ë˜ìŠ¤"""

    HEAL_AMOUNT = config.HEAL_AMOUNT # íšŒë³µëŸ‰

    def __init__(self, pos: Tuple[float, float], screen_height: int):

        # 1. ìœ„ì¹˜
        self.pos = pygame.math.Vector2(pos)

        # 2. ìƒíƒœ
        self.collected = False

        # 3. ì´ë¯¸ì§€ ë° íˆíŠ¸ë°•ìŠ¤
        size_ratio = config.IMAGE_SIZE_RATIOS["GEMHP"]
        image_size = int(screen_height * size_ratio)

        self.image = AssetManager.get_image(config.GEM_HP_IMAGE_PATH, (image_size, image_size))
        self.image_rect = self.image.get_rect(center=(self.pos.x, self.pos.y))

        hitbox_size = int(image_size * config.GEM_HITBOX_RATIO)
        self.hitbox = pygame.Rect(0, 0, hitbox_size, hitbox_size)
        self.hitbox.center = (int(self.pos.x), int(self.pos.y))

    def update(self, dt: float, player):
        """
        ìì„ íš¨ê³¼ê°€ ìˆìœ¼ë©´ í”Œë ˆì´ì–´ì—ê²Œ ëŒì–´ë‹¹ê¹ë‹ˆë‹¤.
        """
        # ìì„ íš¨ê³¼ í™•ì¸ (playerì— has_coin_magnet ì†ì„±ì´ ìˆë‹¤ë©´)
        has_coin_magnet = getattr(player, 'has_coin_magnet', False)

        if not self.collected and has_coin_magnet:
            # í”Œë ˆì´ì–´ì™€ì˜ ê±°ë¦¬ ê³„ì‚°
            direction = player.pos - self.pos
            distance = direction.length()

            # ìì„ íš¨ê³¼ ë²”ìœ„ (í”Œë ˆì´ì–´ ì´ë¯¸ì§€ í¬ê¸°ì˜ 10ë°° ì •ë„ë¡œ ê°€ì •)
            MAGNET_RANGE = player.image_rect.width * 10

            if distance < MAGNET_RANGE:
                # í”Œë ˆì´ì–´ì—ê²Œ ëŒì–´ë‹¹ê¸°ëŠ” ì†ë„ (ê±°ë¦¬ì™€ ë¹„ë¡€)
                MAGNET_SPEED = 500.0
                if distance > 0:
                    direction = direction.normalize()
                    # ì´ë™ ì†ë„ë¥¼ dtì™€ MAGNET_SPEEDë¡œ ê³„ì‚°
                    self.pos += direction * MAGNET_SPEED * dt
                    self.image_rect.center = (int(self.pos.x), int(self.pos.y))
                    self.hitbox.center = self.image_rect.center

    def collect(self, player) -> bool:
        """ì²´ë ¥ íšŒë³µ ì•„ì´í…œ ìˆ˜ì§‘ íš¨ê³¼ ì ìš© (í”Œë ˆì´ì–´ HP íšŒë³µ)"""
        if not self.collected:
            # í”Œë ˆì´ì–´ ì²´ë ¥ íšŒë³µ
            player.heal(self.HEAL_AMOUNT)
            self.collected = True
            return True
        return False

    def draw(self, screen: pygame.Surface):
        """ì ¬ ê°ì²´ë¥¼ í™”ë©´ì— ê·¸ë¦½ë‹ˆë‹¤."""
        if not self.collected:
            screen.blit(self.image, self.image_rect)


# =========================================================
# 6. ë³´ìŠ¤ í´ë˜ìŠ¤
# =========================================================

class Boss(Enemy):
    """ë³´ìŠ¤ ì  í´ë˜ìŠ¤ - Enemyë¥¼ ìƒì†ë°›ë˜ í¬ê¸°ì™€ ì²´ë ¥ì´ í›¨ì”¬ í¼"""

    def __init__(self, pos: pygame.math.Vector2, screen_height: int, boss_name: str = "Boss", wave_number: int = 5):
        # Enemy ì´ˆê¸°í™”ë¥¼ í˜¸ì¶œí•˜ë˜, ì´ë¯¸ì§€ í¬ê¸°ë¥¼ ì¬ì„¤ì •í•˜ê¸° ìœ„í•´ super() í˜¸ì¶œ ì „ì— ì¤€ë¹„

        # 1. ìœ„ì¹˜ ë° ì´ë™
        self.pos = pos
        self.speed = config.ENEMY_BASE_SPEED
        self.chase_probability = 1.0  # ë³´ìŠ¤ëŠ” í•­ìƒ ì¶”ì 
        self.wander_direction = pygame.math.Vector2(0, 0)
        self.wander_timer = 0.0
        self.wander_change_interval = 2.0

        # 2. ìŠ¤íƒ¯
        self.max_hp = config.ENEMY_BASE_HP
        self.hp = self.max_hp
        self.damage = config.ENEMY_ATTACK_DAMAGE
        self.last_attack_time = 0.0

        # 3. ë³´ìŠ¤ ì „ìš© ì†ì„±
        self.is_boss = True
        self.boss_name = boss_name
        self.wave_number = wave_number

        # 4. ì´ë¯¸ì§€ ë° íˆíŠ¸ë°•ìŠ¤ (ë³´ìŠ¤ ì´ë¦„ì— ë”°ë¼ í¬ê¸° ë‹¤ë¥´ê²Œ)
        if boss_name == "The Swarm Queen":
            size_multiplier = 2.0  # ì›¨ì´ë¸Œ 5 ë³´ìŠ¤: 2ë°° í¬ê¸°
        elif boss_name == "The Void Core":
            size_multiplier = 5.0  # ì›¨ì´ë¸Œ 10 ë³´ìŠ¤: 5ë°° í¬ê¸°
        else:
            size_multiplier = 3.0  # ê¸°ë³¸ ë³´ìŠ¤: 3ë°° í¬ê¸°

        size_ratio = config.IMAGE_SIZE_RATIOS["ENEMY"] * size_multiplier
        image_size = int(screen_height * size_ratio)

        self.color = (255, 50, 50)  # ë³´ìŠ¤ ìƒ‰ìƒ (ë¹¨ê°„ìƒ‰)
        self.size = image_size // 2  # ì‚¬ë§ íš¨ê³¼ìš© í¬ê¸° ì €ì¥ (ë°˜ì§€ë¦„)
        self.image = AssetManager.get_image(config.ENEMY_SHIP_IMAGE_PATH, (image_size, image_size))
        self.image_rect = self.image.get_rect(center=(self.pos.x, self.pos.y))

        hitbox_size = int(image_size * config.ENEMY_HITBOX_RATIO)
        self.hitbox = pygame.Rect(0, 0, hitbox_size, hitbox_size)
        self.hitbox.center = (int(self.pos.x), int(self.pos.y))

        self.is_alive = True

        # 5. íˆíŠ¸ í”Œë˜ì‹œ íš¨ê³¼ ì†ì„± (Enemyì—ì„œë„ ìˆì§€ë§Œ ì´ë¯¸ì§€ê°€ ì¬ì„¤ì •ë˜ë¯€ë¡œ ë‹¤ì‹œ ì €ì¥)
        self.hit_flash_timer = 0.0
        self.is_flashing = False
        self.original_image = self.image.copy()

        # 6. ì†ì„± ìŠ¤í‚¬ ìƒíƒœ ì´í™íŠ¸ (ë³´ìŠ¤ëŠ” ì˜í–¥ë°›ì§€ ì•Šì§€ë§Œ ì†ì„±ì€ í•„ìš”)
        self.is_frozen = False
        self.freeze_timer = 0.0
        self.is_slowed = False
        self.slow_timer = 0.0
        self.slow_ratio = 0.0
        self.base_speed = self.speed

        # 7. í¬ìœ„ ê³µê²©ìš© ê³ ìœ  ID
        self.enemy_id = id(self)

        # 8. ë³´ìŠ¤ íŒ¨í„´ ì‹œìŠ¤í…œ
        self.current_phase = 0  # í˜„ì¬ í˜ì´ì¦ˆ (0, 1, 2)
        self.current_pattern = None  # í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ íŒ¨í„´
        self.pattern_timer = 0.0  # íŒ¨í„´ íƒ€ì´ë¨¸

        # Circle Strafe íŒ¨í„´
        self.orbit_angle = 0.0  # í˜„ì¬ ê¶¤ë„ ê°ë„

        # Charge Attack íŒ¨í„´
        self.is_charging = False
        self.charge_direction = pygame.math.Vector2(0, 0)
        self.last_charge_time = 0.0

        # Berserk ëª¨ë“œ
        self.is_berserk = False

        # Summon íŒ¨í„´
        self.last_summon_time = 0.0
        self.summoned_enemies = []  # ì†Œí™˜ëœ ì  ì°¸ì¡° ë¦¬ìŠ¤íŠ¸

        # Burn Attack íŒ¨í„´
        self.last_burn_attack_time = 0.0
        self.burn_projectiles = []  # ë°œì‚¬ëœ burn ë°œì‚¬ì²´ ë¦¬ìŠ¤íŠ¸

    def update(self, player_pos: pygame.math.Vector2, dt: float, other_enemies: list = None, screen_size: tuple = None, current_time: float = 0.0):
        """ë³´ìŠ¤ì˜ ìƒíƒœì™€ íŒ¨í„´ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤."""
        if not self.is_alive:
            return

        # í˜ì´ì¦ˆ ì²´í¬ ë° ì—…ë°ì´íŠ¸
        hp_ratio = self.hp / self.max_hp
        if hp_ratio <= 0.33 and self.current_phase < 2:
            self.current_phase = 2
        elif hp_ratio <= 0.66 and self.current_phase < 1:
            self.current_phase = 1

        # Berserk ëª¨ë“œ ì²´í¬ (HP 25% ì´í•˜)
        if hp_ratio <= config.BOSS_PATTERN_SETTINGS["BERSERK"]["hp_threshold"] and not self.is_berserk:
            self.is_berserk = True
            self.speed = self.base_speed * config.BOSS_PATTERN_SETTINGS["BERSERK"]["speed_mult"]
            self.damage = config.ENEMY_ATTACK_DAMAGE * config.BOSS_PATTERN_SETTINGS["BERSERK"]["damage_mult"]

        # íŒ¨í„´ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
        self.pattern_timer += dt

        # ì†Œí™˜ íŒ¨í„´ (ì¿¨ë‹¤ìš´ ì²´í¬)
        if current_time - self.last_summon_time >= config.BOSS_PATTERN_SETTINGS["SUMMON_MINIONS"]["summon_cooldown"]:
            if random.random() < 0.3:  # 30% í™•ë¥ ë¡œ ì†Œí™˜ ì‹œë„
                self._summon_minions(other_enemies)
                self.last_summon_time = current_time

        # ëŒì§„ íŒ¨í„´ (ì¿¨ë‹¤ìš´ ì²´í¬)
        if current_time - self.last_charge_time >= config.BOSS_PATTERN_SETTINGS["CHARGE_ATTACK"]["cooldown"]:
            if random.random() < 0.4:  # 40% í™•ë¥ ë¡œ ëŒì§„ ì‹œë„
                self._start_charge(player_pos)
                self.last_charge_time = current_time

        # Burn ë°œì‚¬ì²´ ê³µê²© íŒ¨í„´ (ì¼ì • ì£¼ê¸°ë¡œ ë°œì‚¬)
        burn_settings = config.BOSS_PATTERN_SETTINGS["BURN_ATTACK"]
        if current_time - self.last_burn_attack_time >= burn_settings["fire_interval"]:
            self._fire_burn_projectiles()
            self.last_burn_attack_time = current_time

        # Burn ë°œì‚¬ì²´ ì—…ë°ì´íŠ¸
        for proj in self.burn_projectiles[:]:
            proj.update(dt, screen_size)
            if not proj.is_alive:
                self.burn_projectiles.remove(proj)

        # í˜„ì¬ íŒ¨í„´ì— ë”°ë¼ ì´ë™
        if self.is_charging:
            self._update_charge(dt)
        elif self.current_pattern == "CIRCLE_STRAFE":
            self._update_circle_strafe(player_pos, dt)
        else:
            # ê¸°ë³¸ ì¶”ì  (Enemyì˜ move_towards_player ì‚¬ìš©)
            super().move_towards_player(player_pos, dt, other_enemies)

        # íˆíŠ¸ í”Œë˜ì‹œ íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
        if self.is_flashing:
            self.hit_flash_timer -= dt
            if self.hit_flash_timer <= 0:
                self.is_flashing = False
                self.image = self.original_image.copy()

    def _summon_minions(self, enemy_list: list):
        """ë¯¸ë‹ˆì–¸ì„ ì†Œí™˜í•©ë‹ˆë‹¤."""
        if enemy_list is None:
            return

        summon_count = config.BOSS_PATTERN_SETTINGS["SUMMON_MINIONS"]["summon_count"].get(self.wave_number, 2)
        minion_hp_ratio = config.BOSS_PATTERN_SETTINGS["SUMMON_MINIONS"]["minion_hp_ratio"]

        for i in range(summon_count):
            # ë³´ìŠ¤ ì£¼ë³€ì— ëœë¤ ìœ„ì¹˜ ìƒì„±
            offset_x = random.uniform(-100, 100)
            offset_y = random.uniform(-100, 100)
            spawn_pos = pygame.math.Vector2(self.pos.x + offset_x, self.pos.y + offset_y)

            # ë¯¸ë‹ˆì–¸ ìƒì„± (NORMAL íƒ€ì…)
            from objects import Enemy  # ìˆœí™˜ ì°¸ì¡° ë°©ì§€
            minion = Enemy(spawn_pos, self.image_rect.height * 10, 1.0, "NORMAL")  # screen_height ê·¼ì‚¬ê°’
            minion.hp = self.max_hp * minion_hp_ratio
            minion.max_hp = minion.hp

            enemy_list.append(minion)
            self.summoned_enemies.append(minion)

    def _fire_burn_projectiles(self):
        """Burn ë°œì‚¬ì²´ë¥¼ ì‚¬ë°©ìœ¼ë¡œ ë°œì‚¬í•©ë‹ˆë‹¤."""
        burn_settings = config.BOSS_PATTERN_SETTINGS["BURN_ATTACK"]
        projectile_count = burn_settings["projectile_count"]

        # ì‚¬ë°©ìœ¼ë¡œ ê· ë“±í•˜ê²Œ ë°œì‚¬ (ì›í˜• ë°°ì¹˜)
        for i in range(projectile_count):
            angle = (2 * math.pi / projectile_count) * i
            direction = pygame.math.Vector2(math.cos(angle), math.sin(angle))

            projectile = BurnProjectile(self.pos.copy(), direction)
            self.burn_projectiles.append(projectile)

    def draw_burn_projectiles(self, screen: pygame.Surface):
        """Burn ë°œì‚¬ì²´ë“¤ì„ ê·¸ë¦½ë‹ˆë‹¤."""
        for proj in self.burn_projectiles:
            proj.draw(screen)

    def check_burn_collision_with_player(self, player) -> float:
        """ëª¨ë“  Burn ë°œì‚¬ì²´ì™€ í”Œë ˆì´ì–´ì˜ ì¶©ëŒì„ ê²€ì‚¬í•˜ê³  ì´ ë°ë¯¸ì§€ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
        total_damage = 0.0
        for proj in self.burn_projectiles[:]:
            if proj.check_collision_with_player(player):
                total_damage += proj.damage
                proj.is_alive = False  # ì¶©ëŒí•œ ë°œì‚¬ì²´ ì œê±°
        return total_damage

    def _start_charge(self, player_pos: pygame.math.Vector2):
        """ëŒì§„ ê³µê²© ì‹œì‘."""
        self.is_charging = True
        direction = player_pos - self.pos
        if direction.length_squared() > 0:
            self.charge_direction = direction.normalize()
        self.pattern_timer = 0.0

    def _update_charge(self, dt: float):
        """ëŒì§„ ê³µê²© ì—…ë°ì´íŠ¸."""
        charge_duration = config.BOSS_PATTERN_SETTINGS["CHARGE_ATTACK"]["charge_duration"]

        if self.pattern_timer >= charge_duration:
            self.is_charging = False
            return

        charge_speed = self.base_speed * config.BOSS_PATTERN_SETTINGS["CHARGE_ATTACK"]["charge_speed_mult"]
        self.pos += self.charge_direction * charge_speed * dt

        # ìœ„ì¹˜ ë° hitbox ì—…ë°ì´íŠ¸
        self.image_rect.center = (int(self.pos.x), int(self.pos.y))
        self.hitbox.center = self.image_rect.center

    def _update_circle_strafe(self, player_pos: pygame.math.Vector2, dt: float):
        """ì›í˜• ê¶¤ë„ ì´ë™ íŒ¨í„´."""
        orbit_radius = config.BOSS_PATTERN_SETTINGS["CIRCLE_STRAFE"]["orbit_radius"]
        orbit_speed = config.BOSS_PATTERN_SETTINGS["CIRCLE_STRAFE"]["orbit_speed"]

        # ê°ë„ ì—…ë°ì´íŠ¸
        self.orbit_angle += orbit_speed * dt

        # í”Œë ˆì´ì–´ ì£¼ë³€ ê¶¤ë„ ìœ„ì¹˜ ê³„ì‚°
        target_x = player_pos.x + math.cos(self.orbit_angle) * orbit_radius
        target_y = player_pos.y + math.sin(self.orbit_angle) * orbit_radius
        target_pos = pygame.math.Vector2(target_x, target_y)

        # ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
        direction = target_pos - self.pos
        if direction.length_squared() > 0:
            direction = direction.normalize()
            self.pos += direction * self.speed * dt

        # ìœ„ì¹˜ ë° hitbox ì—…ë°ì´íŠ¸
        self.image_rect.center = (int(self.pos.x), int(self.pos.y))
        self.hitbox.center = self.image_rect.center

    def draw(self, screen: pygame.Surface):
        """ë³´ìŠ¤ë¥¼ í™”ë©´ì— ê·¸ë¦½ë‹ˆë‹¤. (í¬ë¡œë§ˆí‹± ì–´ë²„ë ˆì´ì…˜ íš¨ê³¼ í¬í•¨)"""
        # íˆíŠ¸ í”Œë˜ì‹œ ì ìš©
        if self.is_flashing:
            flash_surface = self.original_image.copy()
            flash_surface.fill(config.HIT_FLASH_COLOR, special_flags=pygame.BLEND_RGB_ADD)
            self.image = flash_surface

        # í¬ë¡œë§ˆí‹± ì–´ë²„ë ˆì´ì…˜ íš¨ê³¼ (RGB ë¶„ë¦¬) - íˆ¬ëª…ë„ ìœ ì§€
        if config.CHROMATIC_ABERRATION_SETTINGS["BOSS"]["enabled"]:
            offset = config.CHROMATIC_ABERRATION_SETTINGS["BOSS"]["offset"]

            # ì›ë³¸ ì´ë¯¸ì§€ì˜ ì•ŒíŒŒ ì±„ë„ ë³´ì¡´
            width, height = self.image.get_size()

            # ë¹¨ê°„ ì±„ë„ ì´ë¯¸ì§€ ìƒì„± (íˆ¬ëª…ë„ ìœ ì§€)
            red_surface = self.image.copy()
            red_array = pygame.surfarray.pixels3d(red_surface)
            red_alpha = pygame.surfarray.pixels_alpha(red_surface)

            # Green, Blue ì±„ë„ ì œê±°
            red_array[:, :, 1] = 0
            red_array[:, :, 2] = 0

            # ì•ŒíŒŒ ì±„ë„ ìœ ì§€í•˜ë©´ì„œ ì „ì²´ íˆ¬ëª…ë„ ì¡°ì •
            red_alpha[:] = (red_alpha[:] * 0.6).astype('uint8')  # 60% íˆ¬ëª…ë„
            del red_array, red_alpha  # ë°°ì—´ ì ê¸ˆ í•´ì œ
            screen.blit(red_surface, (self.image_rect.x - offset, self.image_rect.y))

            # íŒŒë€ ì±„ë„ ì´ë¯¸ì§€ ìƒì„± (íˆ¬ëª…ë„ ìœ ì§€)
            blue_surface = self.image.copy()
            blue_array = pygame.surfarray.pixels3d(blue_surface)
            blue_alpha = pygame.surfarray.pixels_alpha(blue_surface)

            # Red, Green ì±„ë„ ì œê±°
            blue_array[:, :, 0] = 0
            blue_array[:, :, 1] = 0

            # ì•ŒíŒŒ ì±„ë„ ìœ ì§€í•˜ë©´ì„œ ì „ì²´ íˆ¬ëª…ë„ ì¡°ì •
            blue_alpha[:] = (blue_alpha[:] * 0.6).astype('uint8')  # 60% íˆ¬ëª…ë„
            del blue_array, blue_alpha  # ë°°ì—´ ì ê¸ˆ í•´ì œ
            screen.blit(blue_surface, (self.image_rect.x + offset, self.image_rect.y))

        # ì›ë³¸ ì´ë¯¸ì§€ (ì¤‘ì•™)
        screen.blit(self.image, self.image_rect)

    def _draw_glow_effect(self, screen: pygame.Surface, color: tuple, intensity: int = 2, layers: int = 2):
        """ì´ë¯¸ì§€ ìœ¤ê³½ì„  ê¸°ë°˜ ê´‘ì„  íš¨ê³¼ (Glow Effect) - Bossìš©"""
        # ë³´ìŠ¤ëŠ” í¬ë¡œë§ˆí‹± ì–´ë²„ë ˆì´ì…˜ì´ ìˆì–´ ê´‘ì„  íš¨ê³¼ ë‹¨ìˆœí™”
        for layer in range(layers, 0, -1):
            radius = self.image_rect.width // 2 + layer * intensity * 2
            alpha = int(60 / layer)

            glow_surf = pygame.Surface((radius * 2, radius * 2), pygame.SRCALPHA)
            pygame.draw.circle(glow_surf, color + (alpha,), (radius, radius), radius)
            glow_rect = glow_surf.get_rect(center=self.image_rect.center)
            screen.blit(glow_surf, glow_rect)


# =========================================================
# 6.5. ë³´ìŠ¤ Burn ë°œì‚¬ì²´ í´ë˜ìŠ¤ (Boss Burn Projectile)
# =========================================================

class BurnProjectile:
    """ë³´ìŠ¤ê°€ ë°œì‚¬í•˜ëŠ” Burn ë°œì‚¬ì²´ í´ë˜ìŠ¤ - í”Œë ˆì´ì–´ì™€ ì¶©ëŒ ì‹œ ë°ë¯¸ì§€"""

    def __init__(self, pos: pygame.math.Vector2, direction: pygame.math.Vector2):
        """
        Args:
            pos: ë°œì‚¬ ìœ„ì¹˜ (ë³´ìŠ¤ ìœ„ì¹˜)
            direction: ë°œì‚¬ ë°©í–¥ (ì •ê·œí™”ëœ ë²¡í„°)
        """
        self.pos = pygame.math.Vector2(pos)
        self.direction = direction.normalize() if direction.length_squared() > 0 else pygame.math.Vector2(1, 0)

        # ì„¤ì •ê°’ ë¡œë“œ
        burn_settings = config.BOSS_PATTERN_SETTINGS["BURN_ATTACK"]
        self.speed = burn_settings["projectile_speed"]
        self.damage = burn_settings["damage"]
        self.lifetime = burn_settings["lifetime"]
        self.age = 0.0
        self.is_alive = True

        # ì´ë¯¸ì§€ ë¡œë“œ
        image_size = burn_settings["projectile_size"]
        try:
            self.image = AssetManager.get_image(config.ENEMY_SHIP_BURN_IMAGE_PATH, (image_size, image_size))
        except Exception:
            # ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì„œí”¼ìŠ¤ ìƒì„±
            self.image = pygame.Surface((image_size, image_size), pygame.SRCALPHA)
            pygame.draw.circle(self.image, (255, 100, 50), (image_size // 2, image_size // 2), image_size // 2)

        self.image_rect = self.image.get_rect(center=(int(self.pos.x), int(self.pos.y)))

        # íˆíŠ¸ë°•ìŠ¤ (ì´ë¯¸ì§€ë³´ë‹¤ ì•½ê°„ ì‘ê²Œ)
        hitbox_size = int(image_size * 0.7)
        self.hitbox = pygame.Rect(0, 0, hitbox_size, hitbox_size)
        self.hitbox.center = (int(self.pos.x), int(self.pos.y))

    def update(self, dt: float, screen_size: tuple = None):
        """ë°œì‚¬ì²´ ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        # ìˆ˜ëª… ì²´í¬
        self.age += dt
        if self.age >= self.lifetime:
            self.is_alive = False
            return

        # ì´ë™
        self.pos += self.direction * self.speed * dt

        # ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        self.image_rect.center = (int(self.pos.x), int(self.pos.y))
        self.hitbox.center = self.image_rect.center

        # í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±°
        if screen_size:
            margin = 100
            if (self.pos.x < -margin or self.pos.x > screen_size[0] + margin or
                self.pos.y < -margin or self.pos.y > screen_size[1] + margin):
                self.is_alive = False

    def draw(self, screen: pygame.Surface):
        """ë°œì‚¬ì²´ ê·¸ë¦¬ê¸°"""
        if not self.is_alive:
            return

        # íšŒì „ íš¨ê³¼ (ë‚˜ì´ì— ë”°ë¼ íšŒì „)
        rotation_angle = self.age * 180  # ì´ˆë‹¹ 180ë„ íšŒì „
        rotated_image = pygame.transform.rotate(self.image, rotation_angle)
        rotated_rect = rotated_image.get_rect(center=self.image_rect.center)

        screen.blit(rotated_image, rotated_rect)

    def check_collision_with_player(self, player) -> bool:
        """í”Œë ˆì´ì–´ì™€ ì¶©ëŒ ê²€ì‚¬"""
        if not self.is_alive:
            return False
        # Player í´ë˜ìŠ¤ëŠ” is_dead ì†ì„± ì‚¬ìš© (is_aliveê°€ ì•„ë‹˜)
        if hasattr(player, 'is_dead') and player.is_dead:
            return False

        return self.hitbox.colliderect(player.hitbox)


# =========================================================
# 7. ì‹œê° íš¨ê³¼ í´ë˜ìŠ¤ë“¤ (Visual Effects)
# =========================================================

class Particle:
    """íŒŒí‹°í´ íš¨ê³¼ í´ë˜ìŠ¤ - í­ë°œ, ì¶©ëŒ ë“±ì— ì‚¬ìš©"""

    def __init__(self, pos: Tuple[float, float], velocity: pygame.math.Vector2,
                 color: Tuple[int, int, int], size: int, lifetime: float, gravity: bool = True):
        self.pos = pygame.math.Vector2(pos)
        self.velocity = velocity
        self.color = color
        self.size = size
        self.lifetime = lifetime
        self.age = 0.0
        self.gravity = gravity
        self.is_alive = True

    def update(self, dt: float):
        """íŒŒí‹°í´ ì—…ë°ì´íŠ¸"""
        self.age += dt
        if self.age >= self.lifetime:
            self.is_alive = False
            return

        # ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        self.pos += self.velocity * dt

        # ì¤‘ë ¥ íš¨ê³¼
        if self.gravity:
            self.velocity.y += 300 * dt  # ì¤‘ë ¥ ê°€ì†ë„

        # ê°ì† (ê³µê¸° ì €í•­)
        self.velocity *= 0.98

    def draw(self, screen: pygame.Surface):
        """íŒŒí‹°í´ ê·¸ë¦¬ê¸°"""
        if not self.is_alive:
            return

        # ì•ŒíŒŒê°’ ê³„ì‚° (ì‹œê°„ì— ë”°ë¼ í˜ì´ë“œ ì•„ì›ƒ)
        alpha = int(255 * (1 - self.age / self.lifetime))
        alpha = max(0, min(255, alpha))

        # í¬ê¸° ê°ì†Œ
        current_size = max(1, int(self.size * (1 - self.age / self.lifetime)))

        # ë°˜íˆ¬ëª… ì„œí”¼ìŠ¤ ìƒì„±
        surf = pygame.Surface((current_size * 2, current_size * 2), pygame.SRCALPHA)
        color_with_alpha = self.color + (alpha,)
        pygame.draw.circle(surf, color_with_alpha, (current_size, current_size), current_size)

        screen.blit(surf, (int(self.pos.x - current_size), int(self.pos.y - current_size)))


class Shockwave:
    """ì¶©ê²©íŒŒ íš¨ê³¼ - ì¤‘ì‹¬ì—ì„œ í™•ì¥ë˜ëŠ” ì›í˜• ë§ (ì§€ì—° ì‹œê°„ ì§€ì›)"""

    def __init__(self, center: Tuple[float, float], max_radius: float,
                 duration: float, color: Tuple[int, int, int], width: int = 3, delay: float = 0.0):
        self.center = pygame.math.Vector2(center)
        self.max_radius = max_radius
        self.duration = duration
        self.color = color
        self.width = width
        self.delay = delay  # ì‹œì‘ ì§€ì—° ì‹œê°„
        self.age = -delay  # ì§€ì—° ì‹œê°„ë§Œí¼ ìŒìˆ˜ë¡œ ì‹œì‘
        self.is_alive = True

    def update(self, dt: float):
        """ì¶©ê²©íŒŒ ì—…ë°ì´íŠ¸"""
        self.age += dt
        if self.age >= self.duration:
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        """ì¶©ê²©íŒŒ ê·¸ë¦¬ê¸°"""
        if not self.is_alive or self.age < 0:
            # ì•„ì§ ì§€ì—° ì‹œê°„ì´ ë‚¨ì•˜ìœ¼ë©´ ê·¸ë¦¬ì§€ ì•ŠìŒ
            return

        # ì§„í–‰ë„ ê³„ì‚°
        progress = self.age / self.duration
        current_radius = int(self.max_radius * progress)

        # ì•ŒíŒŒê°’ ê³„ì‚° (ì‹œê°„ì— ë”°ë¼ í˜ì´ë“œ ì•„ì›ƒ)
        alpha = int(255 * (1 - progress))
        alpha = max(0, min(255, alpha))

        # ë°˜íˆ¬ëª… ì„œí”¼ìŠ¤ ìƒì„±
        size = current_radius * 2 + 10
        surf = pygame.Surface((size, size), pygame.SRCALPHA)
        color_with_alpha = self.color + (alpha,)
        pygame.draw.circle(surf, color_with_alpha, (size // 2, size // 2), current_radius, self.width)

        screen.blit(surf, (int(self.center.x - size // 2), int(self.center.y - size // 2)))


class ScreenFlash:
    """í™”ë©´ í”Œë˜ì‹œ íš¨ê³¼ - ì „ì²´ í™”ë©´ì— ìƒ‰ìƒ ì˜¤ë²„ë ˆì´"""

    def __init__(self, screen_size: Tuple[int, int], color: Tuple[int, int, int] = (255, 255, 255), duration: float = 0.3):
        self.screen_size = screen_size
        self.color = color
        self.duration = duration
        self.age = 0.0
        self.is_alive = True

    def update(self, dt: float):
        """í”Œë˜ì‹œ ì—…ë°ì´íŠ¸"""
        self.age += dt
        if self.age >= self.duration:
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        """í”Œë˜ì‹œ ê·¸ë¦¬ê¸°"""
        if not self.is_alive:
            return

        # ì§„í–‰ë„ ê³„ì‚° (0 â†’ 1)
        progress = self.age / self.duration

        # ì•ŒíŒŒê°’ ê³„ì‚° (ì²˜ìŒ ë°ì•˜ë‹¤ê°€ ì ì  ì‚¬ë¼ì§)
        alpha = int(150 * (1 - progress))
        alpha = max(0, min(255, alpha))

        # ë°˜íˆ¬ëª… ì˜¤ë²„ë ˆì´
        surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        surf.fill((*self.color, alpha))
        screen.blit(surf, (0, 0))


class WaveTransitionEffect:
    """ì›¨ì´ë¸Œ ì „í™˜ íš¨ê³¼ - í™”ë©´ ì–´ë‘ì›Œì§ê³¼ ë™ì‹œì— ì´ë¯¸ì§€ê°€ ì¤‘ì•™ì—ì„œ ì„œì„œíˆ ë“±ì¥ (ì™¸ê³½ í˜ì´ë“œ ì ìš©)"""

    # í˜ì´ì¦ˆ ìƒìˆ˜
    PHASE_DARKEN = 0      # í™”ë©´ ì–´ë‘ì›Œì§€ë©´ì„œ ì´ë¯¸ì§€ ë“±ì¥
    PHASE_SHOW_IMAGE = 1  # ì´ë¯¸ì§€ ìœ ì§€
    PHASE_BRIGHTEN = 2    # í™”ë©´ ë°ì•„ì§€ë©´ì„œ ì´ë¯¸ì§€ ì‚¬ë¼ì§
    PHASE_DONE = 3        # ì™„ë£Œ

    def __init__(self, screen_size: Tuple[int, int], image_path: str = None,
                 darken_duration: float = 3.5, image_duration: float = 2.0, brighten_duration: float = 3.0):
        self.screen_size = screen_size
        self.darken_duration = darken_duration  # ì•„ì£¼ ëŠë¦¬ê²Œ: 3.5ì´ˆ
        self.image_duration = image_duration    # ìœ ì§€: 2ì´ˆ
        self.brighten_duration = brighten_duration  # ì•„ì£¼ ëŠë¦¬ê²Œ: 3ì´ˆ
        self.total_duration = darken_duration + image_duration + brighten_duration

        self.age = 0.0
        self.is_alive = True
        self.phase = self.PHASE_DARKEN
        self.on_darken_complete = None

        # ì´ë¯¸ì§€ ë¡œë“œ
        self.image = None
        self.original_image = None  # ì›ë³¸ ì´ë¯¸ì§€ ì €ì¥
        if image_path:
            try:
                from pathlib import Path
                path = Path(image_path)
                if path.exists():
                    loaded_img = pygame.image.load(str(path)).convert_alpha()
                    # í™”ë©´ í¬ê¸°ì— ë§ê²Œ ìŠ¤ì¼€ì¼ (ë¹„ìœ¨ ìœ ì§€, 85% í¬ê¸° - ë” í¬ê²Œ)
                    img_w, img_h = loaded_img.get_size()
                    scale = min(screen_size[0] * 0.85 / img_w, screen_size[1] * 0.85 / img_h)
                    new_size = (int(img_w * scale), int(img_h * scale))
                    self.original_image = pygame.transform.smoothscale(loaded_img, new_size)
                    # ì™¸ê³½ í˜ì´ë“œ ë§ˆìŠ¤í¬ ì ìš©
                    self.image = self._apply_edge_fade(self.original_image)
                    print(f"INFO: Loaded wave transition image: {path}")
                else:
                    print(f"WARNING: Wave transition image not found: {path}")
            except Exception as e:
                print(f"WARNING: Failed to load wave transition image: {e}")

    def _apply_edge_fade(self, surface: pygame.Surface) -> pygame.Surface:
        """ì´ë¯¸ì§€ ì™¸ê³½ì— í˜ì´ë“œ íš¨ê³¼ ì ìš© (ë¹„ë„¤íŠ¸)"""
        w, h = surface.get_size()
        result = surface.copy()

        # í˜ì´ë“œ ì˜ì—­ í¬ê¸° (ì™¸ê³½ì—ì„œ ì•ˆìª½ìœ¼ë¡œ)
        fade_size = min(w, h) // 6  # ì™¸ê³½ 1/6 ì˜ì—­ í˜ì´ë“œ

        # ì•ŒíŒŒ ë§ˆìŠ¤í¬ ìƒì„±
        mask = pygame.Surface((w, h), pygame.SRCALPHA)
        mask.fill((255, 255, 255, 255))

        # ê° í”½ì…€ì˜ ì•ŒíŒŒê°’ ì¡°ì ˆ (ì™¸ê³½ìœ¼ë¡œ ê°ˆìˆ˜ë¡ íˆ¬ëª…)
        for x in range(w):
            for y in range(h):
                # ê° ë³€ê¹Œì§€ì˜ ê±°ë¦¬
                dist_left = x
                dist_right = w - 1 - x
                dist_top = y
                dist_bottom = h - 1 - y

                # ê°€ì¥ ê°€ê¹Œìš´ ë³€ê¹Œì§€ì˜ ê±°ë¦¬
                min_dist = min(dist_left, dist_right, dist_top, dist_bottom)

                if min_dist < fade_size:
                    # ì™¸ê³½ ì˜ì—­: ê±°ë¦¬ì— ë”°ë¼ ì•ŒíŒŒê°’ ê°ì†Œ
                    alpha = int(255 * (min_dist / fade_size))
                    # ë¶€ë“œëŸ¬ìš´ ê³¡ì„  ì ìš© (ease-in)
                    alpha = int(255 * ((min_dist / fade_size) ** 1.5))
                    mask.set_at((x, y), (255, 255, 255, alpha))

        # ë§ˆìŠ¤í¬ ì ìš©
        result.blit(mask, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
        return result

    def update(self, dt: float):
        """ì „í™˜ íš¨ê³¼ ì—…ë°ì´íŠ¸"""
        self.age += dt

        # í˜ì´ì¦ˆ ê²°ì •
        if self.age < self.darken_duration:
            if self.phase != self.PHASE_DARKEN:
                self.phase = self.PHASE_DARKEN
        elif self.age < self.darken_duration + self.image_duration:
            if self.phase == self.PHASE_DARKEN:
                self.phase = self.PHASE_SHOW_IMAGE
                if self.on_darken_complete:
                    self.on_darken_complete()
        elif self.age < self.total_duration:
            if self.phase != self.PHASE_BRIGHTEN:
                self.phase = self.PHASE_BRIGHTEN
        else:
            self.phase = self.PHASE_DONE
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        """ì „í™˜ íš¨ê³¼ ê·¸ë¦¬ê¸°"""
        if not self.is_alive:
            return

        # ì–´ë‘ìš´ ì˜¤ë²„ë ˆì´
        overlay = pygame.Surface(self.screen_size, pygame.SRCALPHA)

        if self.phase == self.PHASE_DARKEN:
            # ì ì  ì–´ë‘ì›Œì§ (0 â†’ 180) - easing ì ìš©
            progress = self.age / self.darken_duration
            eased_progress = progress ** 0.7  # ease-out
            alpha = int(180 * eased_progress)
        elif self.phase == self.PHASE_SHOW_IMAGE:
            alpha = 180
        elif self.phase == self.PHASE_BRIGHTEN:
            # ì ì  ë°ì•„ì§ (180 â†’ 0) - easing ì ìš©
            brighten_age = self.age - self.darken_duration - self.image_duration
            progress = brighten_age / self.brighten_duration
            eased_progress = 1 - ((1 - progress) ** 0.7)  # ease-in
            alpha = int(180 * (1 - eased_progress))
        else:
            alpha = 0

        alpha = max(0, min(255, alpha))
        overlay.fill((0, 0, 0, alpha))
        screen.blit(overlay, (0, 0))

        # ì´ë¯¸ì§€ í‘œì‹œ - ì–´ë‘ì›Œì§€ëŠ” ë™ì•ˆ ì„œì„œíˆ ë“±ì¥ (í˜ì´ë“œì¸ + ìŠ¤ì¼€ì¼)
        if self.image:
            img_alpha = 0
            scale_factor = 1.0

            if self.phase == self.PHASE_DARKEN:
                # ì–´ë‘ì›Œì§€ë©´ì„œ ë™ì‹œì— ì´ë¯¸ì§€ê°€ ì²œì²œíˆ ë“±ì¥
                progress = self.age / self.darken_duration
                eased_progress = progress ** 0.5  # ë” ì²œì²œíˆ ì‹œì‘
                img_alpha = int(255 * eased_progress)
                # ìŠ¤ì¼€ì¼: 0.6 â†’ 1.0 (ë” í¬ê²Œ ì‹œì‘)
                scale_factor = 0.6 + 0.4 * eased_progress

            elif self.phase == self.PHASE_SHOW_IMAGE:
                img_alpha = 255
                scale_factor = 1.0

            elif self.phase == self.PHASE_BRIGHTEN:
                # ë°ì•„ì§€ë©´ì„œ ì´ë¯¸ì§€ ì²œì²œíˆ ì‚¬ë¼ì§
                brighten_age = self.age - self.darken_duration - self.image_duration
                progress = brighten_age / self.brighten_duration
                eased_progress = progress ** 2  # ì²œì²œíˆ ì‚¬ë¼ì§
                img_alpha = int(255 * (1 - eased_progress))
                scale_factor = 1.0

            if img_alpha > 0:
                img_alpha = max(0, min(255, img_alpha))

                # ìŠ¤ì¼€ì¼ ì ìš©
                if scale_factor != 1.0:
                    orig_w, orig_h = self.image.get_size()
                    new_w = int(orig_w * scale_factor)
                    new_h = int(orig_h * scale_factor)
                    if new_w > 0 and new_h > 0:
                        scaled_img = pygame.transform.smoothscale(self.image, (new_w, new_h))
                    else:
                        scaled_img = self.image
                else:
                    scaled_img = self.image

                # ì´ë¯¸ì§€ ì¤‘ì•™ ë°°ì¹˜
                img_rect = scaled_img.get_rect(center=(self.screen_size[0] // 2, self.screen_size[1] // 2))
                img_copy = scaled_img.copy()
                img_copy.set_alpha(img_alpha)
                screen.blit(img_copy, img_rect)


class PlayerVictoryAnimation:
    """í”Œë ˆì´ì–´ ìŠ¹ë¦¬ ì• ë‹ˆë©”ì´ì…˜ - í™”ë©´ ì™¸ê³½ì„ ì‹œê³„ë°©í–¥ìœ¼ë¡œ íšŒì „ í›„ í•˜ë‹¨ ì¤‘ì•™ìœ¼ë¡œ ì´ë™"""

    PHASE_ORBIT = 0       # í™”ë©´ ì™¸ê³½ ì‹œê³„ë°©í–¥ íšŒì „
    PHASE_MOVE_DOWN = 1   # í•˜ë‹¨ ì¤‘ì•™ìœ¼ë¡œ ì´ë™
    PHASE_DONE = 2        # ì™„ë£Œ

    def __init__(self, player, screen_size: Tuple[int, int], orbit_duration: float = 2.5, move_duration: float = 1.5):
        self.player = player
        self.screen_size = screen_size
        self.orbit_duration = orbit_duration  # íšŒì „ ì‹œê°„: 2.5ì´ˆ (ì•„ì£¼ ì²œì²œíˆ)
        self.move_duration = move_duration    # ì´ë™ ì‹œê°„: 1.5ì´ˆ

        self.age = 0.0
        self.is_alive = True
        self.phase = self.PHASE_ORBIT
        self.on_complete = None  # ì™„ë£Œ ì‹œ ì½œë°±

        # ì‹œì‘ ìœ„ì¹˜ ì €ì¥
        self.start_pos = pygame.math.Vector2(player.pos.x, player.pos.y)

        # í™”ë©´ ì¤‘ì‹¬
        self.center = pygame.math.Vector2(screen_size[0] // 2, screen_size[1] // 2)

        # íƒ€ì› ê¶¤ë„ ë°˜ê²½ (í™”ë©´ ì™¸ê³½)
        self.orbit_radius_x = screen_size[0] * 0.45
        self.orbit_radius_y = screen_size[1] * 0.45

        # ì‹œì‘ ê°ë„ ê³„ì‚° (í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì¤‘ì‹¬ê¹Œì§€ì˜ ê°ë„)
        diff = self.start_pos - self.center
        self.start_angle = math.atan2(diff.y, diff.x)

        # ëª©í‘œ ìœ„ì¹˜ (ì¿¨íƒ€ì„ UI ìƒë¶€, í™”ë©´ í•˜ë‹¨ ì¤‘ì•™)
        self.target_pos = pygame.math.Vector2(screen_size[0] // 2, screen_size[1] - 150)

        # íšŒì „ ì™„ë£Œ ì‹œ ìœ„ì¹˜ (íšŒì „ ì¢…ë£Œ ì§€ì )
        self.orbit_end_pos = None

    def update(self, dt: float):
        """ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸"""
        if not self.is_alive or not self.player:
            return

        self.age += dt

        if self.phase == self.PHASE_ORBIT:
            # í™”ë©´ ì™¸ê³½ ì‹œê³„ë°©í–¥ íšŒì „ (ë¹ ë¥´ê²Œ)
            if self.age < self.orbit_duration:
                progress = self.age / self.orbit_duration
                # easing: ease-in-out
                eased = progress * progress * (3 - 2 * progress)

                # ì‹œê³„ë°©í–¥ íšŒì „ (2Ï€ = í•œ ë°”í€´)
                current_angle = self.start_angle + (2 * math.pi * eased)

                # íƒ€ì› ê¶¤ë„ ìœ„ì¹˜ ê³„ì‚°
                new_x = self.center.x + math.cos(current_angle) * self.orbit_radius_x
                new_y = self.center.y + math.sin(current_angle) * self.orbit_radius_y

                self.player.pos.x = new_x
                self.player.pos.y = new_y
            else:
                # íšŒì „ ì™„ë£Œ â†’ ì´ë™ í˜ì´ì¦ˆë¡œ ì „í™˜
                self.orbit_end_pos = pygame.math.Vector2(self.player.pos.x, self.player.pos.y)
                self.phase = self.PHASE_MOVE_DOWN
                self.age = 0.0  # ì‹œê°„ ë¦¬ì…‹

        elif self.phase == self.PHASE_MOVE_DOWN:
            # í•˜ë‹¨ ì¤‘ì•™ìœ¼ë¡œ ì„œì„œíˆ ì´ë™
            if self.age < self.move_duration:
                progress = self.age / self.move_duration
                # easing: ease-out
                eased = 1 - ((1 - progress) ** 2)

                # ì„ í˜• ë³´ê°„
                self.player.pos.x = self.orbit_end_pos.x + (self.target_pos.x - self.orbit_end_pos.x) * eased
                self.player.pos.y = self.orbit_end_pos.y + (self.target_pos.y - self.orbit_end_pos.y) * eased
            else:
                # ì™„ë£Œ
                self.player.pos.x = self.target_pos.x
                self.player.pos.y = self.target_pos.y
                self.phase = self.PHASE_DONE
                self.is_alive = False

                if self.on_complete:
                    self.on_complete()

        # í”Œë ˆì´ì–´ rect ì—…ë°ì´íŠ¸
        if self.player.image_rect:
            self.player.image_rect.center = (int(self.player.pos.x), int(self.player.pos.y))
        if self.player.hitbox:
            self.player.hitbox.center = (int(self.player.pos.x), int(self.player.pos.y))


class ScreenShake:
    """í™”ë©´ ë–¨ë¦¼ íš¨ê³¼ ê´€ë¦¬ í´ë˜ìŠ¤"""

    def __init__(self):
        self.intensity = 0.0  # í˜„ì¬ ë–¨ë¦¼ ê°•ë„ (í”½ì…€)
        self.duration = 0     # ë‚¨ì€ ì§€ì† ì‹œê°„ (í”„ë ˆì„)
        self.offset = pygame.math.Vector2(0, 0)  # í˜„ì¬ ì ìš©í•  ì˜¤í”„ì…‹

    def start_shake(self, intensity: float, duration_frames: int):
        """ë–¨ë¦¼ ì‹œì‘ (ê°•ë„: í”½ì…€ ë‹¨ìœ„, ì§€ì† ì‹œê°„: í”„ë ˆì„ ë‹¨ìœ„)"""
        # ê¸°ì¡´ ë–¨ë¦¼ë³´ë‹¤ ê°•í•˜ë©´ ë®ì–´ì“°ê¸°
        if intensity > self.intensity:
            self.intensity = intensity
            self.duration = duration_frames

    def update(self):
        """ë§¤ í”„ë ˆì„ í˜¸ì¶œ: ë–¨ë¦¼ ìƒíƒœ ì—…ë°ì´íŠ¸"""
        if self.duration > 0:
            # ê°•ë„ ë‚´ì—ì„œ ë¬´ì‘ìœ„ ì˜¤í”„ì…‹ ê³„ì‚°
            self.offset.x = self.intensity * (2 * random.random() - 1)
            self.offset.y = self.intensity * (2 * random.random() - 1)

            # ë§¤ í”„ë ˆì„ë§ˆë‹¤ ê°•ë„ì™€ ì§€ì† ì‹œê°„ ê°ì†Œ
            self.intensity *= 0.9
            self.duration -= 1

            if self.duration <= 0:
                self.offset = pygame.math.Vector2(0, 0)
                self.intensity = 0
        else:
            self.offset = pygame.math.Vector2(0, 0)

        return self.offset


class DynamicTextEffect:
    """ì§„ë™, ìƒ‰ìƒ ë³€í™”, í˜ì´ë“œ ì•„ì›ƒ ê¸°ëŠ¥ì„ ê°€ì§„ ë™ì  í…ìŠ¤íŠ¸"""

    def __init__(self, text: str, size: int, color: Tuple[int, int, int],
                 pos: Tuple[float, float], duration_frames: int, shake_intensity: int = 3):
        self.text = text
        self.pos = pygame.math.Vector2(pos)
        self.base_color = color
        self.shake_intensity = shake_intensity
        self.duration = duration_frames
        self.frames_passed = 0
        self.is_alive = True

        # í°íŠ¸ ë¡œë“œ
        self.font = pygame.font.Font(None, size)

    def update(self, dt: float = None):
        """í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return
        self.frames_passed += 1
        if self.frames_passed >= self.duration:
            self.is_alive = False

    def draw(self, screen: pygame.Surface, screen_offset: pygame.math.Vector2 = None):
        """í™”ë©´ì— ê·¸ë¦¬ê¸°"""
        if not self.is_alive:
            return

        if screen_offset is None:
            screen_offset = pygame.math.Vector2(0, 0)

        # ì§„ë™ íš¨ê³¼
        offset_x = random.randint(-self.shake_intensity, self.shake_intensity)
        offset_y = random.randint(-self.shake_intensity, self.shake_intensity)

        draw_x = self.pos.x + offset_x + screen_offset.x
        draw_y = self.pos.y + offset_y + screen_offset.y

        # ìƒ‰ìƒ ë³€í™” (ë§ˆì§€ë§‰ì— ê°•ì¡°)
        current_color = self.base_color
        if self.duration - self.frames_passed < 15:
            if self.frames_passed % 6 < 3:
                current_color = (255, 255, 0)  # ë…¸ë€ìƒ‰

        # íˆ¬ëª…ë„ (Fade Out)
        alpha = 255
        if self.frames_passed > self.duration * 0.6:
            fade_progress = (self.frames_passed - self.duration * 0.6) / (self.duration * 0.4)
            alpha = 255 - int(255 * fade_progress)
            alpha = max(0, alpha)

        # í…ìŠ¤íŠ¸ ë Œë”ë§
        text_surface = self.font.render(self.text, True, current_color)
        text_surface.set_alpha(alpha)

        screen.blit(text_surface, (int(draw_x), int(draw_y)))


class ReviveTextEffect:
    """ë¶€í™œ í…ìŠ¤íŠ¸ ì´í™íŠ¸ - í™”ë©´ ì¤‘ì•™ì— ë¶€í™œ ë©”ì‹œì§€ í‘œì‹œ (í˜ì´ë“œ ì¸/ì•„ì›ƒ)"""

    def __init__(self, text: str, screen_size: Tuple[int, int],
                 color: Tuple[int, int, int] = (255, 215, 0), duration: float = 2.0):
        self.text = text
        self.screen_size = screen_size
        self.color = color
        self.duration = duration
        self.age = 0.0
        self.is_alive = True

        # í°íŠ¸ ì„¤ì • (í° ê¸€ì”¨)
        self.font = pygame.font.Font(None, 72)

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        self.age += dt
        if self.age >= self.duration:
            self.is_alive = False

    def draw(self, screen: pygame.Surface, screen_offset: pygame.math.Vector2 = None):
        """í™”ë©´ì— ê·¸ë¦¬ê¸°"""
        if not self.is_alive:
            return

        progress = self.age / self.duration

        # ì•ŒíŒŒê°’: ì²˜ìŒ 0.3ì´ˆ í˜ì´ë“œì¸, ë§ˆì§€ë§‰ 0.5ì´ˆ í˜ì´ë“œì•„ì›ƒ
        if progress < 0.15:  # í˜ì´ë“œ ì¸
            alpha = int(255 * (progress / 0.15))
        elif progress > 0.75:  # í˜ì´ë“œ ì•„ì›ƒ
            alpha = int(255 * (1 - (progress - 0.75) / 0.25))
        else:
            alpha = 255
        alpha = max(0, min(255, alpha))

        # í…ìŠ¤íŠ¸ ë Œë”ë§
        text_surface = self.font.render(self.text, True, self.color)
        text_surface.set_alpha(alpha)

        # í™”ë©´ ì¤‘ì•™ì— ë°°ì¹˜
        text_rect = text_surface.get_rect(center=(self.screen_size[0] // 2, self.screen_size[1] // 2 - 50))
        screen.blit(text_surface, text_rect)


class TimeSlowEffect:
    """íƒ€ì„ ìŠ¬ë¡œìš° íš¨ê³¼ - ê²Œì„ ì†ë„ë¥¼ ì¼ì‹œì ìœ¼ë¡œ ê°ì†Œ"""

    def __init__(self, slow_factor: float, duration: float):
        """
        slow_factor: ì†ë„ ê°ì†Œ ë°°ìœ¨ (0.5 = 50% ì†ë„)
        duration: ì§€ì† ì‹œê°„ (ì´ˆ)
        """
        self.slow_factor = slow_factor
        self.duration = duration
        self.age = 0.0
        self.is_active = True

    def update(self, dt: float):
        """íš¨ê³¼ ì—…ë°ì´íŠ¸"""
        self.age += dt
        if self.age >= self.duration:
            self.is_active = False

    def get_time_scale(self) -> float:
        """í˜„ì¬ ì‹œê°„ ìŠ¤ì¼€ì¼ ë°˜í™˜"""
        if not self.is_active:
            return 1.0

        # ì‹œì‘ê³¼ ëì— ë¶€ë“œëŸ¬ìš´ ì „í™˜
        progress = self.age / self.duration

        if progress < 0.1:  # ì²˜ìŒ 10%ëŠ” ê°ì†
            t = progress / 0.1
            return 1.0 + (self.slow_factor - 1.0) * t
        elif progress > 0.8:  # ë§ˆì§€ë§‰ 20%ëŠ” ê°€ì†
            t = (progress - 0.8) / 0.2
            return self.slow_factor + (1.0 - self.slow_factor) * t
        else:
            return self.slow_factor


class ParallaxLayer:
    """ë°°ê²½ íŒ¨ëŸ´ë™ìŠ¤ ë ˆì´ì–´ - ë³„ ë°°ê²½ (ë°˜ì§ì„ íš¨ê³¼ í¬í•¨)"""

    def __init__(self, screen_size: Tuple[int, int], star_count: int,
                 speed_factor: float, star_size: int, color: Tuple[int, int, int], twinkle: bool = False):
        self.screen_width, self.screen_height = screen_size
        self.speed_factor = speed_factor
        self.base_speed_factor = speed_factor  # ê¸°ë³¸ ì†ë„ ì €ì¥
        self.star_size = star_size
        self.color = color
        self.twinkle_enabled = twinkle
        self.stars = []

        # ë³„ ìƒì„± (ìœ„ì¹˜ + ë°˜ì§ì„ ì •ë³´)
        for _ in range(star_count):
            x = random.randint(0, self.screen_width)
            y = random.randint(0, self.screen_height)
            self.stars.append({
                'pos': pygame.math.Vector2(x, y),
                'brightness': 1.0,  # í˜„ì¬ ë°ê¸° (0.0 ~ 1.5)
                'twinkle_timer': 0.0,  # ë°˜ì§ì„ íƒ€ì´ë¨¸
                'twinkle_duration': 0.0,  # ë°˜ì§ì„ ì§€ì† ì‹œê°„
                'is_twinkling': False,  # ë°˜ì§ì´ê³  ìˆëŠ”ì§€
            })

    def update(self, dt: float, player_velocity: pygame.math.Vector2 = None, speed_multiplier: float = 1.0):
        """ë ˆì´ì–´ ì—…ë°ì´íŠ¸ - í”Œë ˆì´ì–´ ì†ë„ì— ë°˜ì‘ + ë°˜ì§ì„"""
        # ì†ë„ ë°°ìœ¨ ì ìš©
        current_speed_factor = self.base_speed_factor * speed_multiplier

        if player_velocity is None:
            # ê¸°ë³¸ ìŠ¤í¬ë¡¤
            scroll_speed = 50 * current_speed_factor * dt
            for star_data in self.stars:
                star_data['pos'].y += scroll_speed
        else:
            # í”Œë ˆì´ì–´ ì›€ì§ì„ì— ë°˜ì‘
            for star_data in self.stars:
                star_data['pos'].x -= player_velocity.x * current_speed_factor * dt
                star_data['pos'].y -= player_velocity.y * current_speed_factor * dt

        # í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ë³„ ì¬ë°°ì¹˜
        for star_data in self.stars:
            star = star_data['pos']
            if star.y > self.screen_height:
                star.y = 0
                star.x = random.randint(0, self.screen_width)
            elif star.y < 0:
                star.y = self.screen_height
                star.x = random.randint(0, self.screen_width)

            if star.x > self.screen_width:
                star.x = 0
                star.y = random.randint(0, self.screen_height)
            elif star.x < 0:
                star.x = self.screen_width
                star.y = random.randint(0, self.screen_height)

        # ë°˜ì§ì„ íš¨ê³¼ ì—…ë°ì´íŠ¸
        if self.twinkle_enabled and config.STAR_TWINKLE_SETTINGS["enabled"]:
            for star_data in self.stars:
                if star_data['is_twinkling']:
                    # ë°˜ì§ì„ ì§„í–‰
                    star_data['twinkle_timer'] += dt
                    progress = star_data['twinkle_timer'] / star_data['twinkle_duration']

                    if progress >= 1.0:
                        # ë°˜ì§ì„ ì¢…ë£Œ
                        star_data['is_twinkling'] = False
                        star_data['brightness'] = 1.0
                    else:
                        # ì‚¬ì¸íŒŒë¡œ ë°ê¸° ë³€í™”
                        import math
                        brightness_range = config.STAR_TWINKLE_SETTINGS["brightness_range"]
                        star_data['brightness'] = 1.0 + (brightness_range[1] - 1.0) * math.sin(progress * math.pi * 2)
                else:
                    # ë°˜ì§ì„ ì‹œì‘ í™•ë¥ 
                    if random.random() < config.STAR_TWINKLE_SETTINGS["twinkle_chance"]:
                        star_data['is_twinkling'] = True
                        star_data['twinkle_timer'] = 0.0
                        duration_range = config.STAR_TWINKLE_SETTINGS["twinkle_duration"]
                        star_data['twinkle_duration'] = random.uniform(duration_range[0], duration_range[1])

    def draw(self, screen: pygame.Surface):
        """ë ˆì´ì–´ ê·¸ë¦¬ê¸° (ë°˜ì§ì„ íš¨ê³¼ ì ìš©)"""
        for star_data in self.stars:
            star = star_data['pos']
            brightness = star_data['brightness']

            # ë°ê¸°ì— ë”°ë¼ ìƒ‰ìƒ ì¡°ì •
            adjusted_color = tuple(min(255, int(c * brightness)) for c in self.color)

            pygame.draw.circle(screen, adjusted_color,
                             (int(star.x), int(star.y)), self.star_size)


class SpawnEffect:
    """ì  ìŠ¤í° í¬í„¸ íš¨ê³¼"""

    def __init__(self, pos: Tuple[float, float], duration: float, max_size: int):
        self.pos = pygame.math.Vector2(pos)
        self.duration = duration
        self.max_size = max_size
        self.age = 0.0
        self.is_alive = True

    def update(self, dt: float):
        """íš¨ê³¼ ì—…ë°ì´íŠ¸"""
        self.age += dt
        if self.age >= self.duration:
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        """í¬í„¸ ê·¸ë¦¬ê¸°"""
        if not self.is_alive:
            return

        progress = self.age / self.duration

        # í¬ê¸° ì• ë‹ˆë©”ì´ì…˜ (0 â†’ max â†’ 0)
        if progress < 0.5:
            size_factor = progress * 2
        else:
            size_factor = 2 - progress * 2

        current_size = int(self.max_size * size_factor)

        # íšŒì „ ê°ë„
        rotation = self.age * 360 * 2  # 2íšŒì „/ì´ˆ

        # ì•ŒíŒŒê°’
        alpha = int(200 * (1 - progress))

        # ì—¬ëŸ¬ ê²¹ì˜ ì› ê·¸ë¦¬ê¸°
        for i in range(3):
            radius = current_size - i * 10
            if radius > 0:
                color = (100 + i * 50, 50 + i * 30, 255, alpha)
                surf = pygame.Surface((radius * 2 + 5, radius * 2 + 5), pygame.SRCALPHA)
                pygame.draw.circle(surf, color, (radius + 2, radius + 2), radius, 2)
                screen.blit(surf, (int(self.pos.x - radius - 2), int(self.pos.y - radius - 2)))


class Meteor:
    """ìœ ì„± íš¨ê³¼ - í™”ë©´ì„ ëŒ€ê°ì„ ìœ¼ë¡œ ê°€ë¡œì§€ë¥´ëŠ” ì‘ì€ ìœ ì„± (ì›¨ì´ë¸Œë‹¹ 1ê°œ)"""

    # í´ë˜ìŠ¤ ë³€ìˆ˜ë¡œ ì´ë¯¸ì§€ ë¡œë“œ (í•œ ë²ˆë§Œ ë¡œë“œ)
    _head_image = None
    _trail_image = None

    def __init__(self, screen_size: Tuple[int, int]):
        self.screen_width, self.screen_height = screen_size
        self.is_alive = True

        # ì´ë¯¸ì§€ ë¡œë“œ (ì²˜ìŒ í•œ ë²ˆë§Œ, use_imageê°€ Trueì¼ ë•Œë§Œ)
        if Meteor._head_image is None and config.METEOR_SETTINGS.get("use_image", False):
            try:
                # configì—ì„œ ì •ì˜ëœ ê²½ë¡œ ì‚¬ìš©
                if config.METEOR_HEAD_IMAGE_PATH.exists() and config.METEOR_TRAIL_IMAGE_PATH.exists():
                    # displayê°€ ì´ˆê¸°í™”ëœ ê²½ìš°ì—ë§Œ convert_alpha ì‚¬ìš©
                    if pygame.display.get_surface():
                        head_img = pygame.image.load(str(config.METEOR_HEAD_IMAGE_PATH)).convert_alpha()
                        trail_img = pygame.image.load(str(config.METEOR_TRAIL_IMAGE_PATH)).convert_alpha()
                    else:
                        head_img = pygame.image.load(str(config.METEOR_HEAD_IMAGE_PATH))
                        trail_img = pygame.image.load(str(config.METEOR_TRAIL_IMAGE_PATH))

                    # í¬ê¸° ì¡°ì • (ì„¤ì •ì— ë§ì¶°)
                    head_scale = config.METEOR_SETTINGS.get("head_scale", 1.5)
                    trail_scale = config.METEOR_SETTINGS.get("trail_scale", 1.2)

                    # ì›ë³¸ ì´ë¯¸ì§€ í¬ê¸° ê¸°ë°˜ìœ¼ë¡œ ìŠ¤ì¼€ì¼ë§
                    head_w = int(head_img.get_width() * head_scale)
                    head_h = int(head_img.get_height() * head_scale)
                    trail_w = int(trail_img.get_width() * trail_scale)
                    trail_h = int(trail_img.get_height() * trail_scale)

                    Meteor._head_image = pygame.transform.smoothscale(head_img, (head_w, head_h))
                    Meteor._trail_image = pygame.transform.smoothscale(trail_img, (trail_w, trail_h))
                    print(f"INFO: Meteor images loaded successfully (head: {head_w}x{head_h}, trail: {trail_w}x{trail_h})")
                else:
                    print(f"WARNING: Meteor image files not found at {config.METEOR_HEAD_IMAGE_PATH}")
                    Meteor._head_image = None
                    Meteor._trail_image = None
            except Exception as e:
                print(f"WARNING: Failed to load meteor images: {e}")
                Meteor._head_image = None
                Meteor._trail_image = None

        # ë‹¨ìˆœí™”ëœ ì„¤ì •
        self.speed = random.uniform(*config.METEOR_SETTINGS["speed"])
        self.size = random.randint(*config.METEOR_SETTINGS["size"])
        self.color = config.METEOR_SETTINGS["color"]
        self.trail_length = config.METEOR_SETTINGS["trail_length"]

        # ì‹œì‘ ìœ„ì¹˜ (í™”ë©´ ìƒë‹¨ ëœë¤ ë˜ëŠ” ì¢Œì¸¡)
        if random.random() < 0.5:
            # ìƒë‹¨ì—ì„œ ì‹œì‘
            self.pos = pygame.math.Vector2(random.randint(0, self.screen_width), -20)
            angle = random.uniform(30, 60)  # ì•„ë˜ìª½ ê°ë„
        else:
            # ì¢Œì¸¡ì—ì„œ ì‹œì‘
            self.pos = pygame.math.Vector2(-20, random.randint(0, self.screen_height // 2))
            angle = random.uniform(20, 45)  # ìš°í•˜í–¥ ê°ë„

        # ë°©í–¥ ë²¡í„°
        import math
        self.angle_degrees = angle
        self.velocity = pygame.math.Vector2(
            math.cos(math.radians(angle)),
            math.sin(math.radians(angle))
        ).normalize() * self.speed

        # íŠ¸ë ˆì¼ ìœ„ì¹˜ ì €ì¥
        self.trail_positions = []

    def update(self, dt: float):
        """ìœ ì„± ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        # í˜„ì¬ ìœ„ì¹˜ë¥¼ íŠ¸ë ˆì¼ì— ì¶”ê°€
        self.trail_positions.append(self.pos.copy())
        if len(self.trail_positions) > self.trail_length:
            self.trail_positions.pop(0)

        # ì´ë™
        self.pos += self.velocity * dt

        # í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±°
        if (self.pos.x > self.screen_width + 50 or
            self.pos.y > self.screen_height + 50):
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        """ìœ ì„± ê·¸ë¦¬ê¸° (ê¼¬ë¦¬ íŠ¸ë ˆì¼ í¬í•¨)"""
        if not self.is_alive:
            return

        # ì´ë¯¸ì§€ê°€ ë¡œë“œë˜ì—ˆê³  use_imageê°€ Trueì¸ ê²½ìš°ì—ë§Œ ì´ë¯¸ì§€ ì‚¬ìš©
        use_image = config.METEOR_SETTINGS.get("use_image", False)
        if use_image and Meteor._head_image is not None and Meteor._trail_image is not None:
            import math

            # íŠ¸ë ˆì¼ ê·¸ë¦¬ê¸° (ë’¤ì—ì„œ ì•ìœ¼ë¡œ, ì ì  íˆ¬ëª…í•˜ê²Œ)
            if len(self.trail_positions) > 1:
                for i, trail_pos in enumerate(self.trail_positions[:-1]):  # ë§ˆì§€ë§‰ ìœ„ì¹˜ ì œì™¸
                    alpha = int(255 * (i + 1) / len(self.trail_positions))
                    scale = (i + 1) / len(self.trail_positions)

                    # íŠ¸ë ˆì¼ ì´ë¯¸ì§€ íšŒì „ ë° í¬ê¸° ì¡°ì •
                    rotated_trail = pygame.transform.rotate(Meteor._trail_image, -self.angle_degrees)
                    scaled_trail = pygame.transform.scale(
                        rotated_trail,
                        (int(rotated_trail.get_width() * scale),
                         int(rotated_trail.get_height() * scale))
                    )

                    # ì•ŒíŒŒ ì ìš©
                    scaled_trail.set_alpha(alpha)

                    # íŠ¸ë ˆì¼ ê·¸ë¦¬ê¸°
                    rect = scaled_trail.get_rect(center=(int(trail_pos.x), int(trail_pos.y)))
                    screen.blit(scaled_trail, rect)

            # í˜œì„± ë³¸ì²´ ê·¸ë¦¬ê¸° (íšŒì „ ì ìš©)
            rotated_head = pygame.transform.rotate(Meteor._head_image, -self.angle_degrees)
            rect = rotated_head.get_rect(center=(int(self.pos.x), int(self.pos.y)))
            screen.blit(rotated_head, rect)

        else:
            # ì´ë¯¸ì§€ ë¡œë“œ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì› ê·¸ë¦¬ê¸° (í´ë°±)
            # íŠ¸ë ˆì¼ ê·¸ë¦¬ê¸° (ë’¤ì—ì„œ ì•ìœ¼ë¡œ, ì ì  íˆ¬ëª…í•˜ê²Œ)
            for i, trail_pos in enumerate(self.trail_positions):
                alpha = int(255 * (i + 1) / len(self.trail_positions))
                size = max(1, int(self.size * (i + 1) / len(self.trail_positions)))

                # íˆ¬ëª…ë„ë¥¼ ê°€ì§„ ì„œí˜ì´ìŠ¤ ìƒì„±
                trail_surf = pygame.Surface((size * 2, size * 2), pygame.SRCALPHA)
                pygame.draw.circle(trail_surf, (*self.color, alpha), (size, size), size)
                screen.blit(trail_surf, (int(trail_pos.x - size), int(trail_pos.y - size)))

            # ìœ ì„± ë³¸ì²´ ê·¸ë¦¬ê¸° (ë°ê²Œ)
            head_color = tuple(min(255, c + 50) for c in self.color)
            pygame.draw.circle(screen, head_color, (int(self.pos.x), int(self.pos.y)), self.size)


class NebulaParticle:
    """ì„±ìš´ íŒŒí‹°í´ - ëŠë¦¬ê²Œ íë¥´ëŠ” ê±°ëŒ€í•œ ìƒ‰ê¹” êµ¬ë¦„"""

    def __init__(self, screen_size: Tuple[int, int]):
        self.screen_width, self.screen_height = screen_size
        self.is_alive = True

        # ëœë¤ ì„¤ì •
        settings = config.NEBULA_SETTINGS
        self.pos = pygame.math.Vector2(
            random.randint(-100, self.screen_width + 100),
            random.randint(-100, self.screen_height + 100)
        )
        self.speed = random.uniform(*settings["speed"])
        self.size = random.randint(*settings["size"])
        self.base_alpha = random.randint(*settings["alpha"])
        self.current_alpha = self.base_alpha
        self.color = random.choice(settings["colors"])

        # í„ìŠ¤ íš¨ê³¼
        self.pulse_timer = random.uniform(0, 6.28)  # 0 ~ 2Ï€
        self.pulse_speed = settings["pulse_speed"]

        # ì´ë™ ë°©í–¥ (ì²œì²œíˆ ì•„ë˜ë¡œ)
        import math
        angle = random.uniform(70, 110)  # ëŒ€ë¶€ë¶„ ì•„ë˜ ë°©í–¥
        self.velocity = pygame.math.Vector2(
            math.cos(math.radians(angle)),
            math.sin(math.radians(angle))
        ).normalize() * self.speed

    def update(self, dt: float):
        """ì„±ìš´ íŒŒí‹°í´ ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        # ì´ë™
        self.pos += self.velocity * dt

        # í„ìŠ¤ íš¨ê³¼ (ë°ê¸° ë³€í™”)
        import math
        self.pulse_timer += self.pulse_speed * dt
        pulse_factor = 0.7 + 0.3 * math.sin(self.pulse_timer)  # 0.7 ~ 1.0
        self.current_alpha = int(self.base_alpha * pulse_factor)

        # í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì¬ë°°ì¹˜
        if self.pos.y > self.screen_height + 200:
            self.pos.y = -200
            self.pos.x = random.randint(-100, self.screen_width + 100)
        elif self.pos.y < -200:
            self.pos.y = self.screen_height + 200
            self.pos.x = random.randint(-100, self.screen_width + 100)

        if self.pos.x > self.screen_width + 200:
            self.pos.x = -200
            self.pos.y = random.randint(-100, self.screen_height + 100)
        elif self.pos.x < -200:
            self.pos.x = self.screen_width + 200
            self.pos.y = random.randint(-100, self.screen_height + 100)

    def draw(self, screen: pygame.Surface):
        """ì„±ìš´ íŒŒí‹°í´ ê·¸ë¦¬ê¸° (ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼)"""
        if not self.is_alive:
            return

        # ì—¬ëŸ¬ ê²¹ì˜ ì›ìœ¼ë¡œ ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼
        layers = 5
        for i in range(layers, 0, -1):
            layer_size = int(self.size * i / layers)
            layer_alpha = int(self.current_alpha * i / layers)

            # íˆ¬ëª…ë„ë¥¼ ê°€ì§„ ì„œí˜ì´ìŠ¤ ìƒì„±
            nebula_surf = pygame.Surface((layer_size * 2, layer_size * 2), pygame.SRCALPHA)
            pygame.draw.circle(nebula_surf, (*self.color, layer_alpha),
                             (layer_size, layer_size), layer_size)
            screen.blit(nebula_surf, (int(self.pos.x - layer_size), int(self.pos.y - layer_size)))


class BackgroundTransition:
    """ë°°ê²½ ì „í™˜ íš¨ê³¼ í´ë˜ìŠ¤ - ì›¨ì´ë¸Œ ì‹œì‘ ì‹œ ë°°ê²½ ì´ë¯¸ì§€ ì „í™˜"""

    def __init__(self, old_bg: pygame.Surface, new_bg: pygame.Surface,
                 screen_size: Tuple[int, int], effect_type: str, duration: float):
        """
        old_bg: ì´ì „ ë°°ê²½ ì´ë¯¸ì§€
        new_bg: ìƒˆ ë°°ê²½ ì´ë¯¸ì§€
        screen_size: í™”ë©´ í¬ê¸°
        effect_type: ì „í™˜ íš¨ê³¼ ì¢…ë¥˜
        duration: ì „í™˜ ì§€ì† ì‹œê°„ (ì´ˆ)
        """
        self.old_bg = old_bg
        self.new_bg = new_bg
        self.screen_width, self.screen_height = screen_size
        self.effect_type = effect_type
        self.duration = duration
        self.age = 0.0
        self.is_active = True

        # ì „í™˜ íš¨ê³¼ë³„ ì´ˆê¸°í™”
        if effect_type == "shake_fade":
            self.shake_intensity = 15.0

    def update(self, dt: float):
        """ì „í™˜ íš¨ê³¼ ì—…ë°ì´íŠ¸"""
        if not self.is_active:
            return

        self.age += dt
        if self.age >= self.duration:
            self.is_active = False
            self.age = self.duration

    def get_progress(self) -> float:
        """ì „í™˜ ì§„í–‰ë„ (0.0 ~ 1.0)"""
        return min(1.0, self.age / self.duration)

    def draw(self, screen: pygame.Surface):
        """ì „í™˜ íš¨ê³¼ ê·¸ë¦¬ê¸°"""
        if not self.is_active and self.age >= self.duration:
            # ì „í™˜ ì™„ë£Œ - ìƒˆ ë°°ê²½ë§Œ í‘œì‹œ
            screen.blit(self.new_bg, (0, 0))
            return

        progress = self.get_progress()

        # íš¨ê³¼ ì¢…ë¥˜ë³„ ì „í™˜ ë Œë”ë§
        if self.effect_type == "fade_in":
            self._draw_fade_in(screen, progress)
        elif self.effect_type == "slide_horizontal":
            self._draw_slide_horizontal(screen, progress)
        elif self.effect_type == "zoom_in":
            self._draw_zoom_in(screen, progress)
        elif self.effect_type == "cross_fade":
            self._draw_cross_fade(screen, progress)
        elif self.effect_type == "flash_zoom":
            self._draw_flash_zoom(screen, progress)
        elif self.effect_type == "vertical_wipe":
            self._draw_vertical_wipe(screen, progress)
        elif self.effect_type == "circular_reveal":
            self._draw_circular_reveal(screen, progress)
        elif self.effect_type == "pixelate":
            self._draw_pixelate(screen, progress)
        elif self.effect_type == "shake_fade":
            self._draw_shake_fade(screen, progress)
        elif self.effect_type == "multi_flash":
            self._draw_multi_flash(screen, progress)
        else:
            # ê¸°ë³¸: ì¦‰ì‹œ ì „í™˜
            screen.blit(self.new_bg, (0, 0))

    # ========== ì „í™˜ íš¨ê³¼ ë Œë”ë§ ë©”ì„œë“œë“¤ ==========

    def _draw_fade_in(self, screen: pygame.Surface, progress: float):
        """í˜ì´ë“œ ì¸ íš¨ê³¼"""
        screen.blit(self.old_bg, (0, 0))

        # ìƒˆ ë°°ê²½ì„ íˆ¬ëª…ë„ì™€ í•¨ê»˜ ê·¸ë¦¬ê¸°
        new_surf = self.new_bg.copy()
        alpha = int(255 * progress)
        new_surf.set_alpha(alpha)
        screen.blit(new_surf, (0, 0))

    def _draw_slide_horizontal(self, screen: pygame.Surface, progress: float):
        """ì¢Œâ†’ìš° ìŠ¬ë¼ì´ë“œ íš¨ê³¼"""
        offset_x = int(self.screen_width * (1 - progress))

        # ì´ì „ ë°°ê²½ (ì™¼ìª½ìœ¼ë¡œ ì´ë™)
        screen.blit(self.old_bg, (-int(self.screen_width * progress), 0))

        # ìƒˆ ë°°ê²½ (ì˜¤ë¥¸ìª½ì—ì„œ ë“¤ì–´ì˜´)
        screen.blit(self.new_bg, (offset_x, 0))

    def _draw_zoom_in(self, screen: pygame.Surface, progress: float):
        """ì¤‘ì‹¬ì—ì„œ í™•ëŒ€ íš¨ê³¼"""
        screen.blit(self.old_bg, (0, 0))

        # ì´ì§• í•¨ìˆ˜ ì ìš© (ê°€ì†)
        eased_progress = progress * progress

        # ìƒˆ ë°°ê²½ ìŠ¤ì¼€ì¼ë§ (0.5 â†’ 1.0)
        scale = 0.5 + 0.5 * eased_progress
        new_width = int(self.screen_width * scale)
        new_height = int(self.screen_height * scale)

        scaled_bg = pygame.transform.scale(self.new_bg, (new_width, new_height))

        # ì¤‘ì•™ ë°°ì¹˜
        x = (self.screen_width - new_width) // 2
        y = (self.screen_height - new_height) // 2

        alpha = int(255 * progress)
        scaled_bg.set_alpha(alpha)
        screen.blit(scaled_bg, (x, y))

    def _draw_cross_fade(self, screen: pygame.Surface, progress: float):
        """êµì°¨ í˜ì´ë“œ íš¨ê³¼"""
        # ì´ì „ ë°°ê²½ í˜ì´ë“œ ì•„ì›ƒ
        old_surf = self.old_bg.copy()
        old_alpha = int(255 * (1 - progress))
        old_surf.set_alpha(old_alpha)

        # ìƒˆ ë°°ê²½ í˜ì´ë“œ ì¸
        new_surf = self.new_bg.copy()
        new_alpha = int(255 * progress)
        new_surf.set_alpha(new_alpha)

        screen.fill((0, 0, 0))  # ê²€ì€ ë°°ê²½
        screen.blit(old_surf, (0, 0))
        screen.blit(new_surf, (0, 0))

    def _draw_flash_zoom(self, screen: pygame.Surface, progress: float):
        """ë²ˆì©ì„ + í™•ëŒ€ íš¨ê³¼ (ë³´ìŠ¤ ì „ìš©)"""
        # ì „ë°˜ë¶€ (0 ~ 0.2): í™”ì´íŠ¸ í”Œë˜ì‹œ
        if progress < 0.2:
            flash_alpha = int(255 * (1 - progress / 0.2))
            screen.blit(self.old_bg, (0, 0))
            flash_surf = pygame.Surface((self.screen_width, self.screen_height))
            flash_surf.fill((255, 255, 255))
            flash_surf.set_alpha(flash_alpha)
            screen.blit(flash_surf, (0, 0))
        # í›„ë°˜ë¶€ (0.2 ~ 1.0): ì¤Œ ì¸
        else:
            adj_progress = (progress - 0.2) / 0.8
            scale = 0.3 + 0.7 * adj_progress

            new_width = int(self.screen_width * scale)
            new_height = int(self.screen_height * scale)
            scaled_bg = pygame.transform.scale(self.new_bg, (new_width, new_height))

            x = (self.screen_width - new_width) // 2
            y = (self.screen_height - new_height) // 2

            screen.fill((0, 0, 0))
            screen.blit(scaled_bg, (x, y))

    def _draw_vertical_wipe(self, screen: pygame.Surface, progress: float):
        """ìœ„â†’ì•„ë˜ ë‹¦ì•„ë‚´ê¸° íš¨ê³¼"""
        wipe_y = int(self.screen_height * progress)

        # ì´ì „ ë°°ê²½ (ì•„ë˜ ë¶€ë¶„)
        screen.blit(self.old_bg, (0, 0))

        # ìƒˆ ë°°ê²½ (ìœ„ì—ì„œë¶€í„° ì ì§„ì ìœ¼ë¡œ)
        if wipe_y > 0:
            new_surf = pygame.Surface((self.screen_width, wipe_y))
            new_surf.blit(self.new_bg, (0, 0))
            screen.blit(new_surf, (0, 0))

    def _draw_circular_reveal(self, screen: pygame.Surface, progress: float):
        """ì›í˜• í™•ì¥ íš¨ê³¼"""
        screen.blit(self.old_bg, (0, 0))

        # ì›ì˜ ìµœëŒ€ ë°˜ì§€ë¦„ (í™”ë©´ ëŒ€ê°ì„ )
        max_radius = int(math.sqrt(self.screen_width**2 + self.screen_height**2) / 2)
        current_radius = int(max_radius * progress)

        # ë§ˆìŠ¤í¬ ìƒì„±
        mask = pygame.Surface((self.screen_width, self.screen_height), pygame.SRCALPHA)
        mask.fill((0, 0, 0, 0))

        center = (self.screen_width // 2, self.screen_height // 2)
        pygame.draw.circle(mask, (255, 255, 255, 255), center, current_radius)

        # ìƒˆ ë°°ê²½ì— ë§ˆìŠ¤í¬ ì ìš©
        new_surf = self.new_bg.copy()
        new_surf.blit(mask, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
        screen.blit(new_surf, (0, 0))

    def _draw_pixelate(self, screen: pygame.Surface, progress: float):
        """í”½ì…€ ë¶„í•´â†’ì¬ì¡°ë¦½ íš¨ê³¼"""
        # ì „ë°˜ë¶€: ì´ì „ ë°°ê²½ í”½ì…€í™”
        if progress < 0.5:
            pixel_progress = progress * 2
            pixel_size = int(1 + 20 * pixel_progress)

            # ë‹¤ìš´ìŠ¤ì¼€ì¼
            small_width = max(1, self.screen_width // pixel_size)
            small_height = max(1, self.screen_height // pixel_size)
            small_surf = pygame.transform.scale(self.old_bg, (small_width, small_height))

            # ì—…ìŠ¤ì¼€ì¼ (í”½ì…€í™” íš¨ê³¼)
            pixelated = pygame.transform.scale(small_surf, (self.screen_width, self.screen_height))
            screen.blit(pixelated, (0, 0))
        # í›„ë°˜ë¶€: ìƒˆ ë°°ê²½ ì—­í”½ì…€í™”
        else:
            pixel_progress = (progress - 0.5) * 2
            pixel_size = int(20 - 19 * pixel_progress)
            pixel_size = max(1, pixel_size)

            small_width = max(1, self.screen_width // pixel_size)
            small_height = max(1, self.screen_height // pixel_size)
            small_surf = pygame.transform.scale(self.new_bg, (small_width, small_height))

            pixelated = pygame.transform.scale(small_surf, (self.screen_width, self.screen_height))
            screen.blit(pixelated, (0, 0))

    def _draw_shake_fade(self, screen: pygame.Surface, progress: float):
        """í”ë“¤ë¦¼ + í˜ì´ë“œ íš¨ê³¼"""
        # í”ë“¤ë¦¼ ê³„ì‚°
        shake_x = int(self.shake_intensity * (1 - progress) * (2 * random.random() - 1))
        shake_y = int(self.shake_intensity * (1 - progress) * (2 * random.random() - 1))

        # í¬ë¡œìŠ¤ í˜ì´ë“œ
        old_surf = self.old_bg.copy()
        old_alpha = int(255 * (1 - progress))
        old_surf.set_alpha(old_alpha)

        new_surf = self.new_bg.copy()
        new_alpha = int(255 * progress)
        new_surf.set_alpha(new_alpha)

        screen.fill((0, 0, 0))
        screen.blit(old_surf, (shake_x, shake_y))
        screen.blit(new_surf, (0, 0))

    def _draw_multi_flash(self, screen: pygame.Surface, progress: float):
        """ë‹¤ì¤‘ ë²ˆì©ì„ íš¨ê³¼ (ìµœì¢… ë³´ìŠ¤)"""
        # 3íšŒ í”Œë˜ì‹œ (0-0.3, 0.35-0.5, 0.55-0.7)
        flash_times = [(0.0, 0.3), (0.35, 0.5), (0.55, 0.7)]

        is_flashing = False
        flash_intensity = 0

        for start, end in flash_times:
            if start <= progress < end:
                is_flashing = True
                flash_progress = (progress - start) / (end - start)
                # ì‚¼ê°íŒŒ: 0 â†’ 1 â†’ 0
                if flash_progress < 0.5:
                    flash_intensity = int(255 * (flash_progress * 2))
                else:
                    flash_intensity = int(255 * (2 - flash_progress * 2))
                break

        if is_flashing:
            screen.blit(self.old_bg, (0, 0))
            flash_surf = pygame.Surface((self.screen_width, self.screen_height))
            flash_surf.fill((255, 255, 255))
            flash_surf.set_alpha(flash_intensity)
            screen.blit(flash_surf, (0, 0))
        elif progress >= 0.7:
            # í”Œë˜ì‹œ ì´í›„ í˜ì´ë“œ
            fade_progress = (progress - 0.7) / 0.3

            old_surf = self.old_bg.copy()
            old_surf.set_alpha(int(255 * (1 - fade_progress)))

            new_surf = self.new_bg.copy()
            new_surf.set_alpha(int(255 * fade_progress))

            screen.fill((0, 0, 0))
            screen.blit(old_surf, (0, 0))
            screen.blit(new_surf, (0, 0))
        else:
            screen.blit(self.old_bg, (0, 0))


# =========================================================
# StaticField (ì •ì „ê¸°ì¥) - ì†ì„± ìŠ¤í‚¬
# =========================================================

class StaticField:
    """ì  ì‚¬ë§ ì‹œ ìƒì„±ë˜ëŠ” ì •ì „ê¸°ì¥ (Static Field ìŠ¤í‚¬)"""

    # í´ë˜ìŠ¤ ë³€ìˆ˜: ì´ë¯¸ì§€ ë¡œë“œ (í•œ ë²ˆë§Œ)
    _image_loaded = False
    _original_image = None

    def __init__(self, pos: Tuple[float, float], radius: float, duration: float, damage_per_sec: float):
        self.pos = pygame.math.Vector2(pos)
        self.radius = radius
        self.duration = duration
        self.damage_per_sec = damage_per_sec
        self.age = 0.0
        self.is_active = True

        # ì´ë¯¸ì§€ ë¡œë“œ (ì²« ì¸ìŠ¤í„´ìŠ¤ì—ì„œë§Œ)
        if not StaticField._image_loaded:
            self._load_image()

        # ì´ë¯¸ì§€ë¥¼ ë°˜ê²½ì— ë§ê²Œ ìŠ¤ì¼€ì¼ë§
        if StaticField._original_image is not None:
            size = int(self.radius * 2)
            self.image = pygame.transform.scale(StaticField._original_image, (size, size))
        else:
            self.image = None

    @classmethod
    def _load_image(cls):
        """Static Field ì´ë¯¸ì§€ ë¡œë“œ"""
        import config
        try:
            if config.STATIC_FIELD_IMAGE_PATH.exists():
                cls._original_image = pygame.image.load(str(config.STATIC_FIELD_IMAGE_PATH)).convert_alpha()
                print(f"INFO: Static Field image loaded from {config.STATIC_FIELD_IMAGE_PATH}")
            else:
                print(f"WARNING: Static Field image not found at {config.STATIC_FIELD_IMAGE_PATH}")
                cls._original_image = None
        except Exception as e:
            print(f"ERROR: Failed to load Static Field image: {e}")
            cls._original_image = None
        finally:
            cls._image_loaded = True

    def update(self, dt: float):
        """ì •ì „ê¸°ì¥ ì—…ë°ì´íŠ¸"""
        self.age += dt
        if self.age >= self.duration:
            self.is_active = False

    def apply_damage(self, enemies: List, dt: float):
        """ë²”ìœ„ ë‚´ ì ë“¤ì—ê²Œ ì§€ì† ë°ë¯¸ì§€"""
        for enemy in enemies:
            if enemy.is_alive:
                distance = (enemy.pos - self.pos).length()
                if distance <= self.radius:
                    enemy.take_damage(self.damage_per_sec * dt)

    def draw(self, screen: pygame.Surface):
        """ì •ì „ê¸°ì¥ ê·¸ë¦¬ê¸°"""
        if self.is_active:
            # ì‹œê°„ì— ë”°ë¼ íˆ¬ëª…ë„ ê°ì†Œ (100% â†’ 0%)
            alpha_ratio = 1 - (self.age / self.duration)
            alpha = int(255 * alpha_ratio)

            if self.image is not None:
                # ì´ë¯¸ì§€ë¥¼ ì‚¬ìš©í•˜ì—¬ ê·¸ë¦¬ê¸°
                temp_image = self.image.copy()
                temp_image.set_alpha(alpha)
                rect = temp_image.get_rect(center=(int(self.pos.x), int(self.pos.y)))
                screen.blit(temp_image, rect)
            else:
                # ì´ë¯¸ì§€ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ì›í˜•ìœ¼ë¡œ ê·¸ë¦¬ê¸° (í´ë°±)
                circle_surf = pygame.Surface((self.radius * 2, self.radius * 2), pygame.SRCALPHA)
                pygame.draw.circle(circle_surf, (150, 150, 255, alpha), (self.radius, self.radius), self.radius)
                pygame.draw.circle(circle_surf, (100, 200, 255, min(255, alpha + 50)), (self.radius, self.radius), self.radius, 2)
                rect = circle_surf.get_rect(center=(int(self.pos.x), int(self.pos.y)))
                screen.blit(circle_surf, rect)


# =========================================================
# 11. ë™ë£Œ ìœ ë‹› í´ë˜ìŠ¤ (Companion System)
# =========================================================

class Turret:
    """ê³ ì • ì„¤ì¹˜í˜• ìë™ í¬íƒ‘"""

    # í´ë˜ìŠ¤ ë ˆë²¨ ì´ë¯¸ì§€ ìºì‹œ
    _image_cache = None

    def __init__(self, pos: Tuple[float, float]):
        import config

        self.pos = pygame.math.Vector2(pos)
        self.shoot_range = config.TURRET_SETTINGS["shoot_range"]
        self.shoot_cooldown = config.TURRET_SETTINGS["shoot_cooldown"]
        self.damage = config.TURRET_SETTINGS["damage"]
        self.bullet_speed = config.TURRET_SETTINGS["bullet_speed"]
        self.duration = config.TURRET_SETTINGS["duration"]
        self.size = config.TURRET_SETTINGS["size"]

        self.shoot_timer = 0.0
        self.age = 0.0
        self.is_alive = True

        # íšŒì „ ê°ë„ (ë°œì‚¬ ë°©í–¥ í‘œì‹œìš©)
        self.rotation_angle = 0.0

        # ì´ë¯¸ì§€ ë¡œë“œ (í´ë˜ìŠ¤ ìºì‹œ ì‚¬ìš©)
        self._load_image()

    def _load_image(self):
        """í„°ë › ì´ë¯¸ì§€ ë¡œë“œ"""
        from pathlib import Path

        # í´ë˜ìŠ¤ ìºì‹œì—ì„œ ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°
        if Turret._image_cache is not None:
            self.image = Turret._image_cache
            return

        # ì´ë¯¸ì§€ ë¡œë“œ ì‹œë„
        image_path = Path("assets/images/ui/turret.png")
        if image_path.exists():
            try:
                original_image = pygame.image.load(str(image_path)).convert_alpha()
                # í„°ë › í¬ê¸°ì— ë§ê²Œ ìŠ¤ì¼€ì¼ë§ (size * 2 ì •ë„)
                target_size = self.size * 2
                self.image = pygame.transform.scale(original_image, (target_size, target_size))
                Turret._image_cache = self.image
                print(f"INFO: Turret image loaded from {image_path}")
            except Exception as e:
                print(f"WARNING: Failed to load turret image: {e}")
                self.image = None
        else:
            print(f"INFO: Turret image not found at {image_path}, using default shape")
            self.image = None

    def update(self, dt: float, enemies: List, bullets: List):
        """í„°ë › ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        # ì§€ì†ì‹œê°„ ê°ì†Œ
        self.age += dt
        if self.age >= self.duration:
            self.is_alive = False
            return

        # ì¿¨ë‹¤ìš´ ê°ì†Œ
        self.shoot_timer -= dt

        # ë²”ìœ„ ë‚´ ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
        if self.shoot_timer <= 0:
            closest_enemy = None
            closest_distance = float('inf')

            for enemy in enemies:
                if enemy.is_alive:
                    distance = (enemy.pos - self.pos).length()
                    if distance <= self.shoot_range and distance < closest_distance:
                        closest_enemy = enemy
                        closest_distance = distance

            # ì  ë°œê²¬ ì‹œ ë°œì‚¬
            if closest_enemy:
                direction = (closest_enemy.pos - self.pos).normalize()

                # ì´ì•Œ ìƒì„± (Bullet í´ë˜ìŠ¤ ì‚¬ìš©)
                bullet = Bullet(self.pos.copy(), direction, self.damage, piercing=False)
                bullet.speed = self.bullet_speed
                bullets.append(bullet)

                # íšŒì „ ê°ë„ ì—…ë°ì´íŠ¸ (ì‹œê° íš¨ê³¼ìš©)
                import math
                self.rotation_angle = math.atan2(direction.y, direction.x)

                self.shoot_timer = self.shoot_cooldown

    def draw(self, screen: pygame.Surface):
        """í„°ë › ê·¸ë¦¬ê¸°"""
        if not self.is_alive:
            return

        import math

        # ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì´ë¯¸ì§€ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ ë„í˜• ì‚¬ìš©
        if self.image is not None:
            # ì´ë¯¸ì§€ íšŒì „ (ë°œì‚¬ ë°©í–¥ì— ë§ì¶¤)
            angle_degrees = -math.degrees(self.rotation_angle)
            rotated_image = pygame.transform.rotate(self.image, angle_degrees)
            image_rect = rotated_image.get_rect(center=(int(self.pos.x), int(self.pos.y)))
            screen.blit(rotated_image, image_rect)
        else:
            # ê¸°ë³¸ ë„í˜• (ì´ë¯¸ì§€ ì—†ì„ ë•Œ)
            base_color = (100, 100, 255)
            pygame.draw.circle(screen, base_color, (int(self.pos.x), int(self.pos.y)), self.size)

            # í¬ì‹  (íšŒì „í•˜ëŠ” ì„ )
            barrel_length = self.size + 10
            barrel_end_x = self.pos.x + math.cos(self.rotation_angle) * barrel_length
            barrel_end_y = self.pos.y + math.sin(self.rotation_angle) * barrel_length
            pygame.draw.line(screen, (200, 200, 255),
                            (int(self.pos.x), int(self.pos.y)),
                            (int(barrel_end_x), int(barrel_end_y)), 4)

        # ì‚¬ê±°ë¦¬ í‘œì‹œ (ë°˜íˆ¬ëª… ì›)
        range_surf = pygame.Surface((self.shoot_range * 2, self.shoot_range * 2), pygame.SRCALPHA)
        pygame.draw.circle(range_surf, (100, 100, 255, 30),
                          (self.shoot_range, self.shoot_range), self.shoot_range, 1)
        screen.blit(range_surf, (int(self.pos.x - self.shoot_range), int(self.pos.y - self.shoot_range)))

        # ë‚¨ì€ ì‹œê°„ í‘œì‹œ
        remaining_time = self.duration - self.age
        font = pygame.font.Font(None, 20)
        time_text = font.render(f"{int(remaining_time)}s", True, (255, 255, 255))
        screen.blit(time_text, (int(self.pos.x - 10), int(self.pos.y + self.size + 5)))


class Drone:
    """í”Œë ˆì´ì–´ ì¶”ì í˜• ê³µê²© ë“œë¡ """

    def __init__(self, player, orbit_angle: float):
        import config
        from pathlib import Path

        self.player = player  # í”Œë ˆì´ì–´ ì°¸ì¡°
        self.orbit_radius = config.DRONE_SETTINGS["orbit_radius"]
        self.orbit_speed = config.DRONE_SETTINGS["orbit_speed"]
        self.shoot_range = config.DRONE_SETTINGS["shoot_range"]
        self.shoot_cooldown = config.DRONE_SETTINGS["shoot_cooldown"]
        self.damage = config.DRONE_SETTINGS["damage"]
        self.bullet_speed = config.DRONE_SETTINGS["bullet_speed"]
        self.size = config.DRONE_SETTINGS["size"]

        self.orbit_angle = orbit_angle  # ì´ˆê¸° ê¶¤ë„ ê°ë„
        self.shoot_timer = 0.0
        self.is_alive = True

        # ë“œë¡  ì´ë¯¸ì§€ ë¡œë“œ
        drone_image_path = Path("assets/images/units/dron_auto_image.png")
        if drone_image_path.exists():
            self.image = pygame.image.load(str(drone_image_path)).convert_alpha()
            # ë“œë¡  í¬ê¸°ì— ë§ê²Œ ìŠ¤ì¼€ì¼ë§
            self.image = pygame.transform.scale(self.image, (int(self.size * 2), int(self.size * 2)))
        else:
            self.image = None

        # ìœ„ì¹˜ ì´ˆê¸°í™” (ì›í˜• ê¶¤ë„)
        import math
        self.pos = pygame.math.Vector2(
            player.pos.x + math.cos(orbit_angle) * self.orbit_radius,
            player.pos.y + math.sin(orbit_angle) * self.orbit_radius
        )
        self.trail_glow_intensity = 0.0  # ê¸€ë¡œìš° íš¨ê³¼ ê°•ë„
        self.trail_pulse_phase = 0.0  # í„ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ ìœ„ìƒ

    def update(self, dt: float, enemies: List, bullets: List):
        """ë“œë¡  ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        import math

        # ì›í˜• ê¶¤ë„ í„ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
        self.trail_pulse_phase += dt * 3.0
        self.trail_glow_intensity = 0.5 + 0.5 * math.sin(self.trail_pulse_phase)

        # ê¶¤ë„ íšŒì „
        self.orbit_angle += self.orbit_speed * dt

        # ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (í”Œë ˆì´ì–´ ì£¼ë³€ ì›í˜• ê¶¤ë„)
        self.pos.x = self.player.pos.x + math.cos(self.orbit_angle) * self.orbit_radius
        self.pos.y = self.player.pos.y + math.sin(self.orbit_angle) * self.orbit_radius

        # ì¿¨ë‹¤ìš´ ê°ì†Œ
        self.shoot_timer -= dt

        # ë²”ìœ„ ë‚´ ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
        if self.shoot_timer <= 0:
            closest_enemy = None
            closest_distance = float('inf')

            for enemy in enemies:
                if enemy.is_alive:
                    distance = (enemy.pos - self.pos).length()
                    if distance <= self.shoot_range and distance < closest_distance:
                        closest_enemy = enemy
                        closest_distance = distance

            # ì  ë°œê²¬ ì‹œ ë°œì‚¬
            if closest_enemy:
                direction = (closest_enemy.pos - self.pos).normalize()

                # ì´ì•Œ ìƒì„±
                bullet = Bullet(self.pos.copy(), direction, self.damage, piercing=False)
                bullet.speed = self.bullet_speed
                bullets.append(bullet)

                self.shoot_timer = self.shoot_cooldown

    def draw(self, screen: pygame.Surface):
        """ë“œë¡  ê·¸ë¦¬ê¸°"""
        if not self.is_alive:
            return

        import math

        # íƒ€ì›í˜• ê¶¤ë„ íš¨ê³¼ ê·¸ë¦¬ê¸° (í”Œë ˆì´ì–´ ì£¼ë³€ì„ ì™„ì „íˆ ë‘˜ëŸ¬ì‹¸ëŠ” í˜•íƒœ)
        self._draw_ellipse_orbit(screen)

        if self.image:
            # ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
            image_rect = self.image.get_rect(center=(int(self.pos.x), int(self.pos.y)))
            screen.blit(self.image, image_rect)
        else:
            # ì´ë¯¸ì§€ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ìœ¡ê°í˜• ê·¸ë¦¬ê¸°
            import math
            points = []
            for i in range(6):
                angle = math.pi / 3 * i
                x = self.pos.x + math.cos(angle) * self.size
                y = self.pos.y + math.sin(angle) * self.size
                points.append((int(x), int(y)))

            pygame.draw.polygon(screen, (255, 200, 100), points)
            pygame.draw.polygon(screen, (255, 255, 150), points, 2)

            # ì¤‘ì‹¬ì 
            pygame.draw.circle(screen, (255, 255, 200), (int(self.pos.x), int(self.pos.y)), 4)

    def _draw_ellipse_orbit(self, screen: pygame.Surface):
        """í”Œë ˆì´ì–´ ì£¼ë³€ì„ ë‘˜ëŸ¬ì‹¸ëŠ” ì›í˜• ê¶¤ë„ íš¨ê³¼ ê·¸ë¦¬ê¸°"""
        import math

        # í”Œë ˆì´ì–´ ì¤‘ì‹¬ ì¢Œí‘œ
        center_x = int(self.player.pos.x)
        center_y = int(self.player.pos.y)

        # ì›í˜• í¬ê¸° (ê¶¤ë„ ë°˜ì§€ë¦„ ê¸°ë°˜)
        orbit_diameter = int(self.orbit_radius * 2)

        # ê¸€ë¡œìš° íš¨ê³¼ë¥¼ ìœ„í•œ ì—¬ëŸ¬ ê²¹ì˜ ì› ê·¸ë¦¬ê¸°
        glow_intensity = self.trail_glow_intensity

        # ì™¸ë¶€ ê¸€ë¡œìš° (ë„“ê³  íˆ¬ëª…)
        for i in range(3, 0, -1):
            glow_expand = i * 4
            glow_alpha = int(30 * glow_intensity / i)
            glow_color = (255, 200, 100)

            # ê¸€ë¡œìš° ì„œí”¼ìŠ¤ ìƒì„±
            glow_size = orbit_diameter + glow_expand * 2

            if glow_size > 0:
                glow_surf = pygame.Surface((glow_size + 10, glow_size + 10), pygame.SRCALPHA)
                glow_rect = pygame.Rect(5, 5, glow_size, glow_size)
                pygame.draw.ellipse(glow_surf, (*glow_color, glow_alpha), glow_rect, max(1, 4 - i))
                screen.blit(glow_surf, (center_x - glow_size // 2 - 5, center_y - glow_size // 2 - 5))

        # ë©”ì¸ ì›í˜• ê¶¤ë„ (ì ì„  íš¨ê³¼ë¡œ ì—ë„ˆì§€ íë¦„ í‘œí˜„)
        num_segments = 36  # ì›ì„ êµ¬ì„±í•˜ëŠ” ì„¸ê·¸ë¨¼íŠ¸ ìˆ˜
        trail_color_base = (255, 200, 100)
        trail_color_bright = (255, 255, 180)

        points = []
        for i in range(num_segments + 1):
            angle = (2 * math.pi * i / num_segments)
            x = center_x + math.cos(angle) * self.orbit_radius
            y = center_y + math.sin(angle) * self.orbit_radius
            points.append((x, y))

        # íšŒì „í•˜ëŠ” ë°ì€ êµ¬ê°„ íš¨ê³¼ (ë“œë¡  ìœ„ì¹˜ ê¸°ì¤€)
        drone_segment = int((self.orbit_angle / (2 * math.pi)) * num_segments) % num_segments

        for i in range(num_segments):
            # ë“œë¡  ìœ„ì¹˜ë¡œë¶€í„°ì˜ ê±°ë¦¬ì— ë”°ë¥¸ ë°ê¸° ê³„ì‚°
            segment_dist = min(abs(i - drone_segment), num_segments - abs(i - drone_segment))
            brightness = max(0, 1.0 - segment_dist / (num_segments / 3))

            # ìƒ‰ìƒ ë³´ê°„
            r = int(trail_color_base[0] + (trail_color_bright[0] - trail_color_base[0]) * brightness)
            g = int(trail_color_base[1] + (trail_color_bright[1] - trail_color_base[1]) * brightness)
            b = int(trail_color_base[2] + (trail_color_bright[2] - trail_color_base[2]) * brightness)

            # ì„  êµµê¸° (ë“œë¡  ê·¼ì²˜ê°€ ë” ë‘êº¼ì›€)
            line_width = 1 + int(brightness * 2)

            # ì•ŒíŒŒê°’ (ë“œë¡ ì—ì„œ ë©€ì–´ì§ˆìˆ˜ë¡ íˆ¬ëª…)
            alpha = int(100 + 155 * brightness * glow_intensity)

            # ì„¸ê·¸ë¨¼íŠ¸ ê·¸ë¦¬ê¸°
            if i < len(points) - 1:
                start_pos = (int(points[i][0]), int(points[i][1]))
                end_pos = (int(points[i + 1][0]), int(points[i + 1][1]))

                # íˆ¬ëª…í•œ ì„  ê·¸ë¦¬ê¸°
                line_surf = pygame.Surface((abs(end_pos[0] - start_pos[0]) + 10,
                                           abs(end_pos[1] - start_pos[1]) + 10), pygame.SRCALPHA)
                local_start = (5, 5)
                local_end = (end_pos[0] - start_pos[0] + 5, end_pos[1] - start_pos[1] + 5)

                pygame.draw.line(line_surf, (r, g, b, alpha), local_start, local_end, line_width)
                screen.blit(line_surf, (min(start_pos[0], end_pos[0]) - 5,
                                       min(start_pos[1], end_pos[1]) - 5))

        # ë“œë¡  í˜„ì¬ ìœ„ì¹˜ì— ë°ì€ ë§ˆì»¤ (ì—ë„ˆì§€ ë…¸ë“œ)
        marker_size = 4 + int(glow_intensity * 2)
        pygame.draw.circle(screen, trail_color_bright, (int(self.pos.x), int(self.pos.y)), marker_size)
        pygame.draw.circle(screen, (255, 255, 255), (int(self.pos.x), int(self.pos.y)), marker_size - 2)


class ShatterFragment:
    """ì  ì‚¬ë§ ì‹œ ìƒì„±ë˜ëŠ” ì´ë¯¸ì§€ íŒŒí¸"""

    def __init__(self, image_piece: pygame.Surface, pos: pygame.math.Vector2,
                 velocity: pygame.math.Vector2, rotation_speed: float):
        """íŒŒí¸ ì´ˆê¸°í™”

        Args:
            image_piece: íŒŒí¸ ì´ë¯¸ì§€ ì¡°ê°
            pos: ì´ˆê¸° ìœ„ì¹˜
            velocity: ì´ˆê¸° ì†ë„ ë²¡í„°
            rotation_speed: íšŒì „ ì†ë„ (ë„/ì´ˆ)
        """
        self.original_image = image_piece
        self.image = image_piece.copy()
        self.pos = pos.copy()
        self.velocity = velocity.copy()
        self.rotation = 0.0
        self.rotation_speed = rotation_speed
        self.alpha = 255
        self.lifetime = 0.0
        self.max_lifetime = 1.0  # 1ì´ˆ í›„ ì†Œë©¸
        self.gravity = 800.0  # ì¤‘ë ¥ ê°€ì†ë„
        self.is_alive = True

    def update(self, dt: float):
        """íŒŒí¸ ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        # ë¬¼ë¦¬ ì—…ë°ì´íŠ¸
        self.velocity.y += self.gravity * dt  # ì¤‘ë ¥ ì ìš©
        self.pos += self.velocity * dt
        self.rotation += self.rotation_speed * dt

        # ìˆ˜ëª… ì—…ë°ì´íŠ¸
        self.lifetime += dt
        progress = min(self.lifetime / self.max_lifetime, 1.0)

        # íˆ¬ëª…ë„ ê°ì†Œ (ì ì  íˆ¬ëª…í•´ì§)
        self.alpha = int(255 * (1.0 - progress))

        # ì´ë¯¸ì§€ íšŒì „ ë° íˆ¬ëª…ë„ ì ìš©
        rotated = pygame.transform.rotate(self.original_image, self.rotation)
        self.image = rotated.copy()
        self.image.set_alpha(self.alpha)

        # ìˆ˜ëª… ì¢…ë£Œ ì²´í¬
        if self.lifetime >= self.max_lifetime:
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        """íŒŒí¸ ê·¸ë¦¬ê¸°"""
        if not self.is_alive or self.alpha <= 0:
            return

        rect = self.image.get_rect(center=(int(self.pos.x), int(self.pos.y)))
        screen.blit(self.image, rect)


class BurstParticle:
    """íŒŒí‹°í´ í­ë°œìš© ê°œë³„ íŒŒí‹°í´"""

    def __init__(self, pos: pygame.math.Vector2, velocity: pygame.math.Vector2, color: tuple, size: float):
        self.pos = pos.copy()
        self.velocity = velocity.copy()
        self.color = color
        self.size = size
        self.alpha = 255
        self.lifetime = 0.0
        self.max_lifetime = 1.6  # 1.6ì´ˆ ìˆ˜ëª… (2ë°° ì—°ì¥)
        self.gravity = 600.0
        self.is_alive = True

    def update(self, dt: float):
        if not self.is_alive:
            return

        self.velocity.y += self.gravity * dt
        self.pos += self.velocity * dt
        self.lifetime += dt

        progress = min(self.lifetime / self.max_lifetime, 1.0)
        self.alpha = int(255 * (1.0 - progress))
        self.size = max(1, self.size * (1.0 - progress * 0.5))

        if self.lifetime >= self.max_lifetime:
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        if not self.is_alive or self.alpha <= 0:
            return

        surf = pygame.Surface((int(self.size * 2), int(self.size * 2)), pygame.SRCALPHA)
        color_with_alpha = (*self.color[:3], self.alpha)
        pygame.draw.circle(surf, color_with_alpha, (int(self.size), int(self.size)), int(self.size))
        screen.blit(surf, (int(self.pos.x - self.size), int(self.pos.y - self.size)))


class DissolveEffect:
    """ë””ì¡¸ë¸Œ(í”½ì…€ ì†Œë©¸) íš¨ê³¼"""

    def __init__(self, enemy_image: pygame.Surface, enemy_pos: pygame.math.Vector2):
        self.original_image = enemy_image.copy()
        self.pos = enemy_pos.copy()
        self.lifetime = 0.0
        self.max_lifetime = 2.0  # 2.0ì´ˆ (2ë°° ì—°ì¥)
        self.is_alive = True

        # í”½ì…€ ë°ì´í„° ì¶”ì¶œ
        self.width = enemy_image.get_width()
        self.height = enemy_image.get_height()
        self.pixels = []

        import random
        # í”½ì…€ ì¢Œí‘œë¥¼ ë¬´ì‘ìœ„ ìˆœì„œë¡œ ì €ì¥
        for y in range(self.height):
            for x in range(self.width):
                self.pixels.append((x, y))
        random.shuffle(self.pixels)

    def update(self, dt: float):
        if not self.is_alive:
            return

        self.lifetime += dt
        if self.lifetime >= self.max_lifetime:
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        if not self.is_alive:
            return

        progress = min(self.lifetime / self.max_lifetime, 1.0)
        visible_pixel_count = int(len(self.pixels) * (1.0 - progress))

        # ì„ì‹œ ì„œí˜ì´ìŠ¤ ìƒì„±
        temp_surf = self.original_image.copy()
        temp_surf.set_alpha(int(255 * (1.0 - progress * 0.5)))

        # ì‚¬ë¼ì§ˆ í”½ì…€ì„ íˆ¬ëª…í•˜ê²Œ ë§Œë“¤ê¸°
        pixel_array = pygame.PixelArray(temp_surf)
        for i in range(visible_pixel_count, len(self.pixels)):
            x, y = self.pixels[i]
            if 0 <= x < self.width and 0 <= y < self.height:
                pixel_array[x, y] = 0  # íˆ¬ëª…

        del pixel_array  # PixelArray í•´ì œ

        # ê·¸ë¦¬ê¸°
        rect = temp_surf.get_rect(center=(int(self.pos.x), int(self.pos.y)))
        screen.blit(temp_surf, rect)


class FadeEffect:
    """í˜ì´ë“œ & ìŠ¤ì¼€ì¼ íš¨ê³¼ - í™•ëŒ€â†’ì¶•ì†Œ í­ë°œê° ì—°ì¶œ"""

    def __init__(self, enemy_image: pygame.Surface, enemy_pos: pygame.math.Vector2):
        self.original_image = enemy_image.copy()
        self.pos = enemy_pos.copy()
        self.lifetime = 0.0
        self.max_lifetime = 1.6  # 1.6ì´ˆ (2ë°° ì—°ì¥)
        self.is_alive = True
        self.original_size = (enemy_image.get_width(), enemy_image.get_height())

        # í™•ëŒ€â†’ì¶•ì†Œ ì• ë‹ˆë©”ì´ì…˜ ì„¤ì •
        self.expand_duration = 0.15  # í™•ëŒ€ ì‹œê°„ (0.15ì´ˆ)
        self.expand_scale = 1.2  # ì¶”ê°€ í™•ëŒ€ ë¹„ìœ¨ (20% ë” í™•ëŒ€)

    def update(self, dt: float):
        if not self.is_alive:
            return

        self.lifetime += dt
        if self.lifetime >= self.max_lifetime:
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        if not self.is_alive:
            return

        progress = min(self.lifetime / self.max_lifetime, 1.0)

        # í™•ëŒ€â†’ì¶•ì†Œ ì• ë‹ˆë©”ì´ì…˜
        if self.lifetime < self.expand_duration:
            # Phase 1: í™•ëŒ€ (0 â†’ expand_scale)
            expand_progress = self.lifetime / self.expand_duration
            # ease-out íš¨ê³¼ë¡œ ë¶€ë“œëŸ¬ìš´ í™•ëŒ€
            scale = 1.0 + (self.expand_scale - 1.0) * (1.0 - (1.0 - expand_progress) ** 2)
        else:
            # Phase 2: ì¶•ì†Œ (expand_scale â†’ 0)
            shrink_progress = (self.lifetime - self.expand_duration) / (self.max_lifetime - self.expand_duration)
            # ease-in íš¨ê³¼ë¡œ ê°€ì†ë˜ëŠ” ì¶•ì†Œ
            scale = self.expand_scale * (1.0 - shrink_progress ** 0.8)

        new_width = max(1, int(self.original_size[0] * scale))
        new_height = max(1, int(self.original_size[1] * scale))

        # ì´ë¯¸ì§€ ìŠ¤ì¼€ì¼ë§
        scaled_image = pygame.transform.scale(self.original_image, (new_width, new_height))

        # íˆ¬ëª…ë„ ì ìš© (í™•ëŒ€ ì¤‘ì—ëŠ” 100%, ì¶•ì†Œ ì¤‘ì— í˜ì´ë“œì•„ì›ƒ)
        if self.lifetime < self.expand_duration:
            alpha = 255
        else:
            shrink_progress = (self.lifetime - self.expand_duration) / (self.max_lifetime - self.expand_duration)
            alpha = int(255 * (1.0 - shrink_progress))
        scaled_image.set_alpha(alpha)

        # ê·¸ë¦¬ê¸°
        rect = scaled_image.get_rect(center=(int(self.pos.x), int(self.pos.y)))
        screen.blit(scaled_image, rect)


class ImplodeEffect:
    """ë‚´íŒŒ(ì¤‘ì‹¬ìœ¼ë¡œ ìˆ˜ì¶•) íš¨ê³¼ - í™•ëŒ€â†’ì¶•ì†Œ í­ë°œê° ì—°ì¶œ"""

    def __init__(self, enemy_image: pygame.Surface, enemy_pos: pygame.math.Vector2):
        self.original_image = enemy_image.copy()
        self.pos = enemy_pos.copy()
        self.lifetime = 0.0
        self.max_lifetime = 1.2  # 1.2ì´ˆ (2ë°° ì—°ì¥)
        self.is_alive = True
        self.rotation = 0.0
        self.original_size = (enemy_image.get_width(), enemy_image.get_height())

        # í™•ëŒ€â†’ì¶•ì†Œ ì• ë‹ˆë©”ì´ì…˜ ì„¤ì •
        self.expand_duration = 0.12  # í™•ëŒ€ ì‹œê°„ (0.12ì´ˆ, ë” ë¹ ë¥´ê²Œ)
        self.expand_scale = 1.25  # ì¶”ê°€ í™•ëŒ€ ë¹„ìœ¨ (25% ë” í™•ëŒ€)

    def update(self, dt: float):
        if not self.is_alive:
            return

        self.lifetime += dt

        # í™•ëŒ€ ì¤‘ì—ëŠ” íšŒì „ ì—†ìŒ, ì¶•ì†Œ ì‹œì‘ í›„ ê°€ì† íšŒì „
        if self.lifetime >= self.expand_duration:
            shrink_progress = (self.lifetime - self.expand_duration) / (self.max_lifetime - self.expand_duration)
            # ì¶•ì†Œí•˜ë©´ì„œ ì ì  ë¹¨ë¼ì§€ëŠ” íšŒì „
            rotation_speed = 720 * (1.0 + shrink_progress * 2)  # 720 â†’ 2160 deg/s
            self.rotation += rotation_speed * dt

        if self.lifetime >= self.max_lifetime:
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        if not self.is_alive:
            return

        # í™•ëŒ€â†’ì¶•ì†Œ ì• ë‹ˆë©”ì´ì…˜
        if self.lifetime < self.expand_duration:
            # Phase 1: í™•ëŒ€ (í­ë°œ ì§ì „ íŒ½ì°½)
            expand_progress = self.lifetime / self.expand_duration
            # ease-out íš¨ê³¼ë¡œ ë¶€ë“œëŸ¬ìš´ í™•ëŒ€
            scale = 1.0 + (self.expand_scale - 1.0) * (1.0 - (1.0 - expand_progress) ** 2)
        else:
            # Phase 2: ê¸‰ê²©í•œ ì¶•ì†Œ (ë¹¨ë ¤ë“¤ì–´ê°)
            shrink_progress = (self.lifetime - self.expand_duration) / (self.max_lifetime - self.expand_duration)
            # ease-in íš¨ê³¼ë¡œ ê°€ì†ë˜ëŠ” ì¶•ì†Œ
            scale = self.expand_scale * (1.0 - shrink_progress) ** 2

        new_width = max(1, int(self.original_size[0] * scale))
        new_height = max(1, int(self.original_size[1] * scale))

        # ì´ë¯¸ì§€ ìŠ¤ì¼€ì¼ë§ ë° íšŒì „
        scaled_image = pygame.transform.scale(self.original_image, (new_width, new_height))
        rotated_image = pygame.transform.rotate(scaled_image, self.rotation)

        # íˆ¬ëª…ë„ ì ìš© (í™•ëŒ€ ì¤‘ì—ëŠ” 100%, ì¶•ì†Œ ëì— ê¸‰ê²©íˆ ì‚¬ë¼ì§)
        if self.lifetime < self.expand_duration:
            alpha = 255
        else:
            shrink_progress = (self.lifetime - self.expand_duration) / (self.max_lifetime - self.expand_duration)
            alpha = int(255 * (1.0 - shrink_progress ** 3))
        rotated_image.set_alpha(alpha)

        # ê·¸ë¦¬ê¸°
        rect = rotated_image.get_rect(center=(int(self.pos.x), int(self.pos.y)))
        screen.blit(rotated_image, rect)


class VortexEffect:
    """ì†Œìš©ëŒì´(ì°¨ì› ê· ì—´) íš¨ê³¼ - í™•ëŒ€â†’ì¶•ì†Œ íšŒì „í•˜ë©° ë¹¨ë ¤ë“¤ì–´ê°"""

    def __init__(self, enemy_image: pygame.Surface, enemy_pos: pygame.math.Vector2):
        self.original_image = enemy_image.copy()
        self.pos = enemy_pos.copy()
        self.lifetime = 0.0
        self.max_lifetime = 2.4  # 2.4ì´ˆ (2ë°° ì—°ì¥)
        self.is_alive = True
        self.rotation = 0.0
        self.original_size = (enemy_image.get_width(), enemy_image.get_height())

        # í™•ëŒ€â†’ì¶•ì†Œ ì• ë‹ˆë©”ì´ì…˜ ì„¤ì •
        self.expand_duration = 0.18  # í™•ëŒ€ ì‹œê°„ (0.18ì´ˆ)
        self.expand_scale = 1.15  # ì¶”ê°€ í™•ëŒ€ ë¹„ìœ¨ (15% ë” í™•ëŒ€)

        # ë‚˜ì„  íŒŒí‹°í´ ë¦¬ìŠ¤íŠ¸
        self.spiral_particles = []
        self._create_spiral_particles()

    def _create_spiral_particles(self):
        """ë‚˜ì„ í˜• íŒŒí‹°í´ ìƒì„±"""
        import random
        import math

        particle_count = 20
        for i in range(particle_count):
            angle = (i / particle_count) * math.pi * 4  # 2ë°”í€´ ë‚˜ì„ 
            distance = random.uniform(30, 80)
            speed = random.uniform(80, 150)
            color = random.choice([
                (100, 150, 255),  # íŒŒë€ìƒ‰
                (150, 100, 255),  # ë³´ë¼ìƒ‰
                (200, 150, 255),  # ì—°ë³´ë¼ìƒ‰
            ])
            self.spiral_particles.append({
                'angle': angle,
                'distance': distance,
                'speed': speed,
                'color': color,
                'size': random.uniform(2, 5),
                'alpha': 255
            })

    def update(self, dt: float):
        if not self.is_alive:
            return

        self.lifetime += dt

        # í™•ëŒ€ ì¤‘ì—ëŠ” íšŒì „ ëŠë¦¬ê²Œ, ì¶•ì†Œ ì‹œì‘ í›„ ê°€ì† íšŒì „
        if self.lifetime < self.expand_duration:
            self.rotation += 180 * dt  # ëŠë¦° íšŒì „
        else:
            # ì ì  ë¹¨ë¼ì§€ëŠ” íšŒì „ (ê°€ì†)
            shrink_progress = (self.lifetime - self.expand_duration) / (self.max_lifetime - self.expand_duration)
            acceleration = 1.0 + shrink_progress * 3
            self.rotation += 720 * dt * acceleration

        # íŒŒí‹°í´ ì—…ë°ì´íŠ¸ (ì¤‘ì‹¬ìœ¼ë¡œ ìˆ˜ë ´)
        for p in self.spiral_particles:
            p['angle'] += dt * 5  # ë‚˜ì„  íšŒì „
            p['distance'] = max(0, p['distance'] - p['speed'] * dt)
            p['alpha'] = max(0, p['alpha'] - 200 * dt)

        if self.lifetime >= self.max_lifetime:
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        if not self.is_alive:
            return

        import math

        progress = min(self.lifetime / self.max_lifetime, 1.0)

        # ë‚˜ì„  íŒŒí‹°í´ ê·¸ë¦¬ê¸° (ë’¤ì—)
        for p in self.spiral_particles:
            if p['alpha'] > 0 and p['distance'] > 0:
                px = self.pos.x + math.cos(p['angle']) * p['distance']
                py = self.pos.y + math.sin(p['angle']) * p['distance']
                color_with_alpha = (*p['color'], int(p['alpha']))
                surf = pygame.Surface((int(p['size'] * 2), int(p['size'] * 2)), pygame.SRCALPHA)
                pygame.draw.circle(surf, color_with_alpha, (int(p['size']), int(p['size'])), int(p['size']))
                screen.blit(surf, (int(px - p['size']), int(py - p['size'])))

        # í™•ëŒ€â†’ì¶•ì†Œ ì• ë‹ˆë©”ì´ì…˜
        if self.lifetime < self.expand_duration:
            # Phase 1: í™•ëŒ€
            expand_progress = self.lifetime / self.expand_duration
            scale = 1.0 + (self.expand_scale - 1.0) * (1.0 - (1.0 - expand_progress) ** 2)
        else:
            # Phase 2: ê¸‰ê²©í•œ ì¶•ì†Œ (ë¹¨ë ¤ë“¤ì–´ê°)
            shrink_progress = (self.lifetime - self.expand_duration) / (self.max_lifetime - self.expand_duration)
            scale = self.expand_scale * (1.0 - shrink_progress) ** 1.5

        new_width = max(1, int(self.original_size[0] * scale))
        new_height = max(1, int(self.original_size[1] * scale))

        # ì´ë¯¸ì§€ ìŠ¤ì¼€ì¼ë§ ë° íšŒì „
        scaled_image = pygame.transform.scale(self.original_image, (new_width, new_height))
        rotated_image = pygame.transform.rotate(scaled_image, self.rotation)

        # íˆ¬ëª…ë„ + ìƒ‰ì¡° ë³€í™” (íŒŒë€ìƒ‰ìœ¼ë¡œ)
        if self.lifetime < self.expand_duration:
            alpha = 255
        else:
            shrink_progress = (self.lifetime - self.expand_duration) / (self.max_lifetime - self.expand_duration)
            alpha = int(255 * (1.0 - shrink_progress ** 2))
        rotated_image.set_alpha(alpha)

        # íŒŒë€ìƒ‰ ì˜¤ë²„ë ˆì´ (ì°¨ì› ê· ì—´ ëŠë‚Œ) - ì¶•ì†Œ ì‹œì‘ í›„ì—ë§Œ
        if self.lifetime >= self.expand_duration:
            shrink_progress = (self.lifetime - self.expand_duration) / (self.max_lifetime - self.expand_duration)
            if shrink_progress > 0.2:
                tint_surf = pygame.Surface(rotated_image.get_size(), pygame.SRCALPHA)
                tint_alpha = int(100 * (shrink_progress - 0.2) / 0.8)
                tint_surf.fill((100, 150, 255, tint_alpha))
                rotated_image.blit(tint_surf, (0, 0), special_flags=pygame.BLEND_RGBA_ADD)

        # ê·¸ë¦¬ê¸°
        rect = rotated_image.get_rect(center=(int(self.pos.x), int(self.pos.y)))
        screen.blit(rotated_image, rect)

        # ë§ˆì§€ë§‰ í”Œë˜ì‹œ íš¨ê³¼
        if progress > 0.85:
            flash_alpha = int(200 * (progress - 0.85) / 0.15)
            flash_size = int(30 * (1.0 - (progress - 0.85) / 0.15))
            if flash_size > 0:
                flash_surf = pygame.Surface((flash_size * 2, flash_size * 2), pygame.SRCALPHA)
                pygame.draw.circle(flash_surf, (200, 220, 255, flash_alpha),
                                 (flash_size, flash_size), flash_size)
                screen.blit(flash_surf, (int(self.pos.x - flash_size), int(self.pos.y - flash_size)))


class PixelateEffect:
    """í”½ì…€í™”(ë””ì§€í„¸ ê¸€ë¦¬ì¹˜) íš¨ê³¼ - ë ˆíŠ¸ë¡œ ìŠ¤íƒ€ì¼ë¡œ ë¶„í•´"""

    def __init__(self, enemy_image: pygame.Surface, enemy_pos: pygame.math.Vector2):
        self.original_image = enemy_image.copy()
        self.pos = enemy_pos.copy()
        self.lifetime = 0.0
        self.max_lifetime = 2.0  # 2.0ì´ˆ (2ë°° ì—°ì¥)
        self.is_alive = True
        self.original_size = (enemy_image.get_width(), enemy_image.get_height())

        # í”½ì…€ ë¸”ë¡ ë¦¬ìŠ¤íŠ¸ (ë¶„í•´ í›„)
        self.pixel_blocks = []
        self.phase = 'pixelate'  # 'pixelate' -> 'scatter'
        self.scatter_started = False

        # íƒ€ì´ë° ì„¤ì • (2ë°° ì—°ì¥)
        self.pixelate_duration = 0.8  # í”½ì…€í™” ë‹¨ê³„ ì‹œê°„
        self.scatter_duration = 1.2   # ë¶„í•´ ë‹¨ê³„ ì‹œê°„

    def _create_pixel_blocks(self, block_size: int = 8):
        """í”½ì…€ ë¸”ë¡ ìƒì„± (ë¶„í•´ìš©)"""
        import random
        import math

        width, height = self.original_size

        for y in range(0, height, block_size):
            for x in range(0, width, block_size):
                # ë¸”ë¡ ì˜ì—­ ì¶”ì¶œ
                block_w = min(block_size, width - x)
                block_h = min(block_size, height - y)

                if block_w <= 0 or block_h <= 0:
                    continue

                # ë¸”ë¡ ì´ë¯¸ì§€ ì¶”ì¶œ
                block_rect = pygame.Rect(x, y, block_w, block_h)
                try:
                    block_surf = self.original_image.subsurface(block_rect).copy()
                except:
                    continue

                # ë¸”ë¡ ìœ„ì¹˜ (ì  ì¤‘ì‹¬ ê¸°ì¤€)
                offset_x = x - width / 2 + block_w / 2
                offset_y = y - height / 2 + block_h / 2
                block_pos = pygame.math.Vector2(
                    self.pos.x + offset_x,
                    self.pos.y + offset_y
                )

                # ëœë¤ ì†ë„ (ì•„ë˜ë¡œ ë–¨ì–´ì§ + ì¢Œìš° í©ì–´ì§)
                angle = random.uniform(-math.pi / 3, math.pi / 3) - math.pi / 2  # ìœ„ìª½ ë°˜ì›
                speed = random.uniform(50, 150)
                velocity = pygame.math.Vector2(
                    math.cos(angle) * speed * 0.5,
                    random.uniform(30, 100)  # ì•„ë˜ë¡œ ë–¨ì–´ì§
                )

                self.pixel_blocks.append({
                    'image': block_surf,
                    'pos': block_pos,
                    'velocity': velocity,
                    'alpha': 255,
                    'blink_timer': random.uniform(0, 0.5),  # ê¹œë¹¡ì„ íƒ€ì´ë¨¸
                    'gravity': random.uniform(150, 250)
                })

    def update(self, dt: float):
        if not self.is_alive:
            return

        self.lifetime += dt

        # í˜ì´ì¦ˆ ì „í™˜ (pixelate_duration í›„ ë¶„í•´ ì‹œì‘)
        if self.phase == 'pixelate' and self.lifetime >= self.pixelate_duration:
            self.phase = 'scatter'
            if not self.scatter_started:
                self._create_pixel_blocks(block_size=8)
                self.scatter_started = True

        # ë¶„í•´ í˜ì´ì¦ˆ: ë¸”ë¡ ì—…ë°ì´íŠ¸
        if self.phase == 'scatter':
            for block in self.pixel_blocks:
                # ì¤‘ë ¥ ì ìš©
                block['velocity'].y += block['gravity'] * dt
                block['pos'] += block['velocity'] * dt

                # ê¹œë¹¡ì„
                block['blink_timer'] -= dt
                if block['blink_timer'] <= 0:
                    block['blink_timer'] = random.uniform(0.05, 0.15)

                # í˜ì´ë“œì•„ì›ƒ
                scatter_progress = (self.lifetime - self.pixelate_duration) / self.scatter_duration
                block['alpha'] = max(0, int(255 * (1.0 - scatter_progress)))

        if self.lifetime >= self.max_lifetime:
            self.is_alive = False

    def draw(self, screen: pygame.Surface):
        if not self.is_alive:
            return

        progress = min(self.lifetime / self.max_lifetime, 1.0)

        if self.phase == 'pixelate':
            # í”½ì…€í™” ë‹¨ê³„: í•´ìƒë„ ì ì  ë‚®ì•„ì§
            pixelate_progress = min(self.lifetime / self.pixelate_duration, 1.0)

            # í”½ì…€ í¬ê¸° ê³„ì‚° (1 -> 16)
            pixel_size = int(1 + pixelate_progress * 15)

            # ì¶•ì†Œ í›„ í™•ëŒ€ë¡œ í”½ì…€í™” íš¨ê³¼
            small_w = max(1, self.original_size[0] // pixel_size)
            small_h = max(1, self.original_size[1] // pixel_size)

            # ì¶•ì†Œ
            small_img = pygame.transform.scale(self.original_image, (small_w, small_h))
            # ë‹¤ì‹œ í™•ëŒ€ (í”½ì…€í™”)
            pixelated = pygame.transform.scale(small_img, self.original_size)

            # ê¸€ë¦¬ì¹˜ íš¨ê³¼ (RGB ë¶„ë¦¬)
            if pixelate_progress > 0.5:
                glitch_offset = int(3 * (pixelate_progress - 0.5) / 0.5)
                if glitch_offset > 0:
                    # ë¹¨ê°„ìƒ‰ ì±„ë„ ì˜¤í”„ì…‹
                    glitch_surf = pygame.Surface(self.original_size, pygame.SRCALPHA)
                    glitch_surf.blit(pixelated, (glitch_offset, 0))
                    glitch_surf.set_alpha(50)
                    pixelated.blit(glitch_surf, (0, 0), special_flags=pygame.BLEND_RGB_ADD)

            # ê·¸ë¦¬ê¸°
            rect = pixelated.get_rect(center=(int(self.pos.x), int(self.pos.y)))
            screen.blit(pixelated, rect)

        else:
            # ë¶„í•´ ë‹¨ê³„: ë¸”ë¡ë“¤ì´ í©ì–´ì§
            import random
            for block in self.pixel_blocks:
                if block['alpha'] <= 0:
                    continue

                # ê¹œë¹¡ì„ íš¨ê³¼
                if block['blink_timer'] < 0.03:
                    continue  # ê¹œë¹¡ì„ ì¤‘ ì•ˆ ë³´ì„

                block_img = block['image'].copy()
                block_img.set_alpha(block['alpha'])

                rect = block_img.get_rect(center=(int(block['pos'].x), int(block['pos'].y)))
                screen.blit(block_img, rect)


class DeathEffectManager:
    """ì  ì‚¬ë§ íš¨ê³¼ ê´€ë¦¬ í´ë˜ìŠ¤"""

    def __init__(self):
        """ì‚¬ë§ íš¨ê³¼ ë§¤ë‹ˆì € ì´ˆê¸°í™”"""
        self.fragments = []  # ShatterFragment ë¦¬ìŠ¤íŠ¸
        self.particles = []  # BurstParticle ë¦¬ìŠ¤íŠ¸
        self.dissolve_effects = []  # DissolveEffect ë¦¬ìŠ¤íŠ¸
        self.fade_effects = []  # FadeEffect ë¦¬ìŠ¤íŠ¸
        self.implode_effects = []  # ImplodeEffect ë¦¬ìŠ¤íŠ¸
        self.vortex_effects = []  # VortexEffect ë¦¬ìŠ¤íŠ¸
        self.pixelate_effects = []  # PixelateEffect ë¦¬ìŠ¤íŠ¸

        self.current_effect = "shatter"  # í˜„ì¬ ì„ íƒëœ íš¨ê³¼

        # ëª¨ë“  íš¨ê³¼ í™œì„±í™”
        self.enabled_effects = {
            "shatter": True,
            "particle_burst": True,
            "dissolve": True,
            "fade": True,
            "implode": True,
            "vortex": True,
            "pixelate": True
        }

        # ì  ìœ í˜•ë³„ ì£½ìŒ íš¨ê³¼ ë§¤í•‘
        self.enemy_type_effects = {
            "NORMAL": "shatter",        # ì¼ë°˜: íŒŒí¸í™”
            "TANK": "implode",          # íƒ±í¬: ë‚´íŒŒ (ë¬´ê±°ìš´ ëŠë‚Œ)
            "RUNNER": "fade",           # ëŸ¬ë„ˆ: ë¹ ë¥¸ í˜ì´ë“œ (ë¹ ë¥¸ ì )
            "SUMMONER": "vortex",       # ì†Œí™˜ì‚¬: ì†Œìš©ëŒì´ (ë§ˆë²•ì  ëŠë‚Œ)
            "SHIELDED": "dissolve",     # ë³´í˜¸ë§‰: ë””ì¡¸ë¸Œ (ë³´í˜¸ë§‰ ì†Œë©¸)
            "KAMIKAZE": "particle_burst", # ì¹´ë¯¸ì¹´ì œ: í­ë°œ íŒŒí‹°í´
            "RESPAWNED": "pixelate",    # ë¦¬ìŠ¤í°: í”½ì…€í™” (ë””ì§€í„¸ ê¸€ë¦¬ì¹˜)
        }

    def create_shatter_effect(self, enemy_image: pygame.Surface, enemy_pos: pygame.math.Vector2,
                             grid_size: int = 4):
        """ì´ë¯¸ì§€ íŒŒí¸í™” íš¨ê³¼ ìƒì„±

        Args:
            enemy_image: ì  ì´ë¯¸ì§€
            enemy_pos: ì  ìœ„ì¹˜
            grid_size: íŒŒí¸ ê·¸ë¦¬ë“œ í¬ê¸° (4x4 = 16ì¡°ê°)
        """
        import random
        import math

        if not enemy_image:
            return

        image_width = enemy_image.get_width()
        image_height = enemy_image.get_height()
        piece_width = image_width // grid_size
        piece_height = image_height // grid_size

        # ê° íŒŒí¸ ìƒì„±
        for row in range(grid_size):
            for col in range(grid_size):
                # ì´ë¯¸ì§€ ì¡°ê° ì¶”ì¶œ
                piece_rect = pygame.Rect(col * piece_width, row * piece_height,
                                        piece_width, piece_height)
                piece = enemy_image.subsurface(piece_rect).copy()

                # íŒŒí¸ ì‹œì‘ ìœ„ì¹˜ (ì  ì¤‘ì‹¬ ê¸°ì¤€)
                offset_x = (col - grid_size / 2 + 0.5) * piece_width
                offset_y = (row - grid_size / 2 + 0.5) * piece_height
                frag_pos = pygame.math.Vector2(
                    enemy_pos.x + offset_x,
                    enemy_pos.y + offset_y
                )

                # í­ë°œ ë°©í–¥ (ì¤‘ì‹¬ì—ì„œ ë°”ê¹¥ìœ¼ë¡œ)
                angle = math.atan2(offset_y, offset_x)
                speed = random.uniform(150, 300)  # ì†ë„ ë¬´ì‘ìœ„
                velocity = pygame.math.Vector2(
                    math.cos(angle) * speed,
                    math.sin(angle) * speed - random.uniform(50, 150)  # ìœ„ìª½ìœ¼ë¡œ ì•½ê°„ íŠ€ì–´ì˜¤ë¦„
                )

                # íšŒì „ ì†ë„ ë¬´ì‘ìœ„
                rotation_speed = random.uniform(-360, 360)

                # íŒŒí¸ ìƒì„±
                fragment = ShatterFragment(piece, frag_pos, velocity, rotation_speed)
                self.fragments.append(fragment)

    def create_particle_burst(self, pos: pygame.math.Vector2, color: tuple, count: int = 30):
        """íŒŒí‹°í´ í­ë°œ íš¨ê³¼ ìƒì„±

        Args:
            pos: í­ë°œ ìœ„ì¹˜
            color: íŒŒí‹°í´ ìƒ‰ìƒ
            count: íŒŒí‹°í´ ê°œìˆ˜
        """
        import random
        import math

        for _ in range(count):
            angle = random.uniform(0, math.pi * 2)
            speed = random.uniform(100, 250)
            velocity = pygame.math.Vector2(
                math.cos(angle) * speed,
                math.sin(angle) * speed - random.uniform(0, 100)
            )
            size = random.uniform(2, 5)

            particle = BurstParticle(pos.copy(), velocity, color, size)
            self.particles.append(particle)

    def create_dissolve_effect(self, enemy_image: pygame.Surface, enemy_pos: pygame.math.Vector2):
        """ë””ì¡¸ë¸Œ íš¨ê³¼ ìƒì„±"""
        effect = DissolveEffect(enemy_image, enemy_pos)
        self.dissolve_effects.append(effect)

    def create_fade_effect(self, enemy_image: pygame.Surface, enemy_pos: pygame.math.Vector2):
        """í˜ì´ë“œ íš¨ê³¼ ìƒì„±"""
        effect = FadeEffect(enemy_image, enemy_pos)
        self.fade_effects.append(effect)

    def create_implode_effect(self, enemy_image: pygame.Surface, enemy_pos: pygame.math.Vector2):
        """ë‚´íŒŒ íš¨ê³¼ ìƒì„±"""
        effect = ImplodeEffect(enemy_image, enemy_pos)
        self.implode_effects.append(effect)

    def create_vortex_effect(self, enemy_image: pygame.Surface, enemy_pos: pygame.math.Vector2):
        """ì†Œìš©ëŒì´ íš¨ê³¼ ìƒì„±"""
        effect = VortexEffect(enemy_image, enemy_pos)
        self.vortex_effects.append(effect)

    def create_pixelate_effect(self, enemy_image: pygame.Surface, enemy_pos: pygame.math.Vector2):
        """í”½ì…€í™” íš¨ê³¼ ìƒì„±"""
        effect = PixelateEffect(enemy_image, enemy_pos)
        self.pixelate_effects.append(effect)

    def update(self, dt: float):
        """ëª¨ë“  íš¨ê³¼ ì—…ë°ì´íŠ¸"""
        # íŒŒí¸ ì—…ë°ì´íŠ¸
        for fragment in self.fragments[:]:
            fragment.update(dt)
            if not fragment.is_alive:
                self.fragments.remove(fragment)

        # íŒŒí‹°í´ ì—…ë°ì´íŠ¸
        for particle in self.particles[:]:
            particle.update(dt)
            if not particle.is_alive:
                self.particles.remove(particle)

        # ë””ì¡¸ë¸Œ íš¨ê³¼ ì—…ë°ì´íŠ¸
        for effect in self.dissolve_effects[:]:
            effect.update(dt)
            if not effect.is_alive:
                self.dissolve_effects.remove(effect)

        # í˜ì´ë“œ íš¨ê³¼ ì—…ë°ì´íŠ¸
        for effect in self.fade_effects[:]:
            effect.update(dt)
            if not effect.is_alive:
                self.fade_effects.remove(effect)

        # ë‚´íŒŒ íš¨ê³¼ ì—…ë°ì´íŠ¸
        for effect in self.implode_effects[:]:
            effect.update(dt)
            if not effect.is_alive:
                self.implode_effects.remove(effect)

        # ì†Œìš©ëŒì´ íš¨ê³¼ ì—…ë°ì´íŠ¸
        for effect in self.vortex_effects[:]:
            effect.update(dt)
            if not effect.is_alive:
                self.vortex_effects.remove(effect)

        # í”½ì…€í™” íš¨ê³¼ ì—…ë°ì´íŠ¸
        for effect in self.pixelate_effects[:]:
            effect.update(dt)
            if not effect.is_alive:
                self.pixelate_effects.remove(effect)

    def draw(self, screen: pygame.Surface):
        """ëª¨ë“  íš¨ê³¼ ê·¸ë¦¬ê¸°"""
        for fragment in self.fragments:
            fragment.draw(screen)

        for particle in self.particles:
            particle.draw(screen)

        for effect in self.dissolve_effects:
            effect.draw(screen)

        for effect in self.fade_effects:
            effect.draw(screen)

        for effect in self.implode_effects:
            effect.draw(screen)

        for effect in self.vortex_effects:
            effect.draw(screen)

        for effect in self.pixelate_effects:
            effect.draw(screen)

    def trigger_death_effect(self, enemy):
        """ì  ì‚¬ë§ ì‹œ íš¨ê³¼ ë°œë™ (ì  ìœ í˜•ì— ë”°ë¼ ìë™ ë§¤ì¹­)

        Args:
            enemy: ì‚¬ë§í•œ Enemy ê°ì²´
        """
        # ì  ì´ë¯¸ì§€ ìƒì„±
        if hasattr(enemy, 'image') and enemy.image:
            enemy_image = enemy.image
        else:
            # ì„ì‹œ ì´ë¯¸ì§€ ìƒì„± (ì  í¬ê¸°ì— ë§ì¶¤)
            enemy_image = pygame.Surface((int(enemy.size * 2), int(enemy.size * 2)), pygame.SRCALPHA)
            pygame.draw.circle(enemy_image, enemy.color,
                             (int(enemy.size), int(enemy.size)), int(enemy.size))

        # ì‚¬ë§ íš¨ê³¼ìš© í™•ëŒ€ ì´ë¯¸ì§€ ìƒì„± (1.3ë°° í™•ëŒ€ë¡œ í­ë°œê° ì—°ì¶œ)
        death_scale = 1.3
        if hasattr(enemy, 'is_boss') and enemy.is_boss:
            death_scale = 1.5  # ë³´ìŠ¤ëŠ” ë” í¬ê²Œ í™•ëŒ€

        scaled_width = int(enemy_image.get_width() * death_scale)
        scaled_height = int(enemy_image.get_height() * death_scale)
        scaled_image = pygame.transform.smoothscale(enemy_image, (scaled_width, scaled_height))

        # ì  ìœ í˜•ì— ë”°ë¼ íš¨ê³¼ ì„ íƒ
        enemy_type = getattr(enemy, 'enemy_type', 'NORMAL')
        effect_name = self.enemy_type_effects.get(enemy_type, self.current_effect)

        # ë³´ìŠ¤ëŠ” í•­ìƒ shatter (í° íŒŒí¸ íš¨ê³¼)
        if hasattr(enemy, 'is_boss') and enemy.is_boss:
            effect_name = "shatter"

        # ì„ íƒëœ íš¨ê³¼ ë°œë™ (í™•ëŒ€ëœ ì´ë¯¸ì§€ ì‚¬ìš©)
        self._apply_effect(effect_name, scaled_image, enemy.pos, getattr(enemy, 'color', (255, 100, 100)))

    def _apply_effect(self, effect_name: str, enemy_image: pygame.Surface,
                     enemy_pos: pygame.math.Vector2, enemy_color: tuple):
        """ì‹¤ì œ íš¨ê³¼ ì ìš©"""
        if effect_name == "shatter" and self.enabled_effects.get("shatter", True):
            self.create_shatter_effect(enemy_image, enemy_pos)

        elif effect_name == "particle_burst" and self.enabled_effects.get("particle_burst", True):
            self.create_particle_burst(enemy_pos, enemy_color, count=40)

        elif effect_name == "dissolve" and self.enabled_effects.get("dissolve", True):
            self.create_dissolve_effect(enemy_image, enemy_pos)

        elif effect_name == "fade" and self.enabled_effects.get("fade", True):
            self.create_fade_effect(enemy_image, enemy_pos)

        elif effect_name == "implode" and self.enabled_effects.get("implode", True):
            self.create_implode_effect(enemy_image, enemy_pos)

        elif effect_name == "vortex" and self.enabled_effects.get("vortex", True):
            self.create_vortex_effect(enemy_image, enemy_pos)

        elif effect_name == "pixelate" and self.enabled_effects.get("pixelate", True):
            self.create_pixelate_effect(enemy_image, enemy_pos)

    def set_effect(self, effect_name: str):
        """í˜„ì¬ íš¨ê³¼ ì„¤ì •

        Args:
            effect_name: íš¨ê³¼ ì´ë¦„ (shatter, particle_burst, dissolve, fade, implode)
        """
        if effect_name in self.enabled_effects:
            self.current_effect = effect_name
            print(f"INFO: Death effect changed to: {effect_name}")

    def clear(self):
        """ëª¨ë“  íš¨ê³¼ ì œê±°"""
        self.fragments.clear()
        self.particles.clear()
        self.dissolve_effects.clear()
        self.fade_effects.clear()
        self.implode_effects.clear()
        self.vortex_effects.clear()
        self.pixelate_effects.clear()


# =========================================================
# ìŠ¤í† ë¦¬ ë¸Œë¦¬í•‘ íš¨ê³¼ (ë¹„ì£¼ì–¼ ë…¸ë²¨ ìŠ¤íƒ€ì¼)
# =========================================================
class StoryBriefingEffect:
    """
    ìŠ¤í† ë¦¬ ë¸Œë¦¬í•‘ íš¨ê³¼ - ë¹„ì£¼ì–¼ ë…¸ë²¨ ìŠ¤íƒ€ì¼ ëŒ€ì‚¬ ì‹œìŠ¤í…œ

    íŠ¹ì§•:
    - ë°°ê²½ ì´ë¯¸ì§€ + ì–´ë‘¡ê²Œ ì²˜ë¦¬
    - ìºë¦­í„° ì´ˆìƒí™” í‘œì‹œ
    - íƒ€ì´í•‘ íš¨ê³¼ë¡œ ëŒ€ì‚¬ í‘œì‹œ
    - í´ë¦­ìœ¼ë¡œ ë‹¤ìŒ ëŒ€ì‚¬ ì§„í–‰
    - ESCë¡œ ìŠ¤í‚µ ê°€ëŠ¥
    """

    PHASE_FADEIN = 0       # ë°°ê²½ í˜ì´ë“œì¸
    PHASE_DIALOGUE = 1     # ëŒ€ì‚¬ ì§„í–‰ ì¤‘
    PHASE_FADEOUT = 2      # í˜ì´ë“œì•„ì›ƒ
    PHASE_DONE = 3         # ì™„ë£Œ

    def __init__(self, screen_size: tuple, dialogue_data: list,
                 background_path: str = None, title: str = "", location: str = ""):
        """
        Args:
            screen_size: í™”ë©´ í¬ê¸° (width, height)
            dialogue_data: ëŒ€ì‚¬ ë¦¬ìŠ¤íŠ¸ [{"speaker": "...", "text": "..."}, ...]
            background_path: ë°°ê²½ ì´ë¯¸ì§€ ê²½ë¡œ (Noneì´ë©´ ì–´ë‘ìš´ ë°°ê²½)
            title: íƒ€ì´í‹€ í…ìŠ¤íŠ¸ (ì˜ˆ: "ACT 1: RETURN TO RUINS")
            location: ìœ„ì¹˜ í…ìŠ¤íŠ¸ (ì˜ˆ: "DESTROYED CITY")
        """
        self.screen_size = screen_size
        self.dialogue_data = dialogue_data
        self.title = title
        self.location = location

        self.is_alive = True
        self.phase = self.PHASE_FADEIN
        self.phase_timer = 0.0

        # ëŒ€ì‚¬ ê´€ë ¨
        self.current_dialogue_index = 0
        self.typing_progress = 0.0
        self.typing_speed = 30.0  # ì´ˆë‹¹ ê¸€ì ìˆ˜
        self.current_text = ""
        self.full_text = ""
        self.waiting_for_click = False

        # í˜ì´ë“œ íƒ€ì´ë°
        self.fadein_duration = 0.8
        self.fadeout_duration = 0.5
        self.fade_alpha = 0.0

        # ë°°ê²½ ë¡œë“œ
        self.background = None
        self.background_overlay = None
        if background_path:
            self._load_background(background_path)
        self._create_overlay()

        # ì´ˆìƒí™” ìºì‹œ
        self.portrait_cache = {}

        # ìºë¦­í„° ìƒ‰ìƒ (ê¸°ë³¸ê°’)
        self.character_colors = {
            "ARTEMIS": (255, 220, 150),
            "PILOT": (150, 200, 255),
            "BOSS": (255, 100, 100),
            "NARRATOR": (200, 200, 200),
            "SYSTEM": (100, 255, 200),
        }

        # í°íŠ¸ (ë‚˜ì¤‘ì— ì™¸ë¶€ì—ì„œ ì„¤ì •)
        self.fonts = {}

        # ì½œë°±
        self.on_complete = None

        # ì²« ëŒ€ì‚¬ ì¤€ë¹„
        if self.dialogue_data:
            self._prepare_dialogue(0)

    def _load_background(self, path: str):
        """ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ"""
        try:
            img = pygame.image.load(path).convert()
            self.background = pygame.transform.scale(img, self.screen_size)
        except Exception as e:
            print(f"WARNING: Failed to load background: {path} - {e}")
            self.background = None

    def _create_overlay(self):
        """ì–´ë‘ìš´ ì˜¤ë²„ë ˆì´ ìƒì„±"""
        self.background_overlay = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        self.background_overlay.fill((0, 0, 0, 180))

    def _prepare_dialogue(self, index: int):
        """ëŒ€ì‚¬ ì¤€ë¹„"""
        if 0 <= index < len(self.dialogue_data):
            dialogue = self.dialogue_data[index]
            self.full_text = dialogue.get("text", "")
            self.current_text = ""
            self.typing_progress = 0.0
            self.waiting_for_click = False

    def _get_portrait(self, speaker: str) -> pygame.Surface:
        """ì´ˆìƒí™” ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸° (ìºì‹œ ì‚¬ìš©)"""
        if speaker in self.portrait_cache:
            return self.portrait_cache[speaker]

        # config_story_dialogueì—ì„œ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
        try:
            from mode_configs.config_story_dialogue import CHARACTER_PORTRAITS
            path = CHARACTER_PORTRAITS.get(speaker)
        except ImportError:
            # í´ë°±: ê¸°ë³¸ ê²½ë¡œ
            portrait_paths = {
                "ARTEMIS": "assets/story_mode/portraits/portrait_artemis.jpg",
                "PILOT": "assets/story_mode/portraits/portrait_pilot.png",
            }
            path = portrait_paths.get(speaker)

        if path:
            try:
                img = pygame.image.load(path).convert_alpha()
                # í¬ê¸° ì¡°ì • (200x200 ì •ë„)
                target_size = (200, 200)
                img = pygame.transform.smoothscale(img, target_size)
                self.portrait_cache[speaker] = img
                return img
            except Exception as e:
                print(f"WARNING: Failed to load portrait for {speaker}: {e}")

        return None

    def set_fonts(self, fonts: dict):
        """í°íŠ¸ ì„¤ì •"""
        self.fonts = fonts

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        if self.phase == self.PHASE_FADEIN:
            # í˜ì´ë“œì¸
            progress = min(self.phase_timer / self.fadein_duration, 1.0)
            self.fade_alpha = progress

            if progress >= 1.0:
                self.phase = self.PHASE_DIALOGUE
                self.phase_timer = 0.0

        elif self.phase == self.PHASE_DIALOGUE:
            # íƒ€ì´í•‘ íš¨ê³¼
            if not self.waiting_for_click:
                self.typing_progress += self.typing_speed * dt
                char_count = int(self.typing_progress)

                if char_count >= len(self.full_text):
                    self.current_text = self.full_text
                    self.waiting_for_click = True
                else:
                    self.current_text = self.full_text[:char_count]

        elif self.phase == self.PHASE_FADEOUT:
            # í˜ì´ë“œì•„ì›ƒ
            progress = min(self.phase_timer / self.fadeout_duration, 1.0)
            self.fade_alpha = 1.0 - progress

            if progress >= 1.0:
                self.phase = self.PHASE_DONE
                self.is_alive = False
                if self.on_complete:
                    self.on_complete()

    def handle_click(self):
        """í´ë¦­ ì²˜ë¦¬"""
        if self.phase == self.PHASE_FADEIN:
            # í˜ì´ë“œì¸ ìŠ¤í‚µ
            self.phase = self.PHASE_DIALOGUE
            self.phase_timer = 0.0
            self.fade_alpha = 1.0
            return

        if self.phase != self.PHASE_DIALOGUE:
            return

        if not self.waiting_for_click:
            # íƒ€ì´í•‘ ìŠ¤í‚µ - ì „ì²´ í…ìŠ¤íŠ¸ í‘œì‹œ
            self.current_text = self.full_text
            self.waiting_for_click = True
        else:
            # ë‹¤ìŒ ëŒ€ì‚¬ë¡œ
            self.current_dialogue_index += 1

            if self.current_dialogue_index >= len(self.dialogue_data):
                # ëª¨ë“  ëŒ€ì‚¬ ì™„ë£Œ - í˜ì´ë“œì•„ì›ƒ
                self.phase = self.PHASE_FADEOUT
                self.phase_timer = 0.0
            else:
                self._prepare_dialogue(self.current_dialogue_index)

    def skip(self):
        """ì „ì²´ ìŠ¤í‚µ"""
        self.phase = self.PHASE_FADEOUT
        self.phase_timer = 0.0

    def draw(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        if not self.is_alive and self.phase == self.PHASE_DONE:
            return

        # ë°°ê²½
        if self.background:
            screen.blit(self.background, (0, 0))
        else:
            screen.fill((10, 10, 20))

        # ì˜¤ë²„ë ˆì´ (í˜ì´ë“œ ì ìš©)
        overlay = self.background_overlay.copy()
        overlay.set_alpha(int(180 * self.fade_alpha))
        screen.blit(overlay, (0, 0))

        # í˜ì´ë“œì¸/ì•„ì›ƒ ì¤‘ì´ë©´ ë‚˜ë¨¸ì§€ UI í‘œì‹œ ì•ˆí•¨
        if self.phase == self.PHASE_FADEIN and self.fade_alpha < 0.5:
            return
        if self.phase == self.PHASE_FADEOUT and self.fade_alpha < 0.5:
            return

        # UI ì•ŒíŒŒ
        ui_alpha = int(255 * self.fade_alpha)

        # íƒ€ì´í‹€/ìœ„ì¹˜
        self._draw_title(screen, ui_alpha)

        # ëŒ€ì‚¬ ë°•ìŠ¤
        self._draw_dialogue_box(screen, ui_alpha)

    def _draw_title(self, screen: pygame.Surface, alpha: int):
        """íƒ€ì´í‹€ ê·¸ë¦¬ê¸°"""
        if not self.title:
            return

        font = self.fonts.get("large") or self.fonts.get("medium")
        if not font:
            return

        # íƒ€ì´í‹€
        title_surf = font.render(self.title, True, (255, 255, 255))
        title_surf.set_alpha(alpha)
        title_rect = title_surf.get_rect(midtop=(self.screen_size[0] // 2, 50))
        screen.blit(title_surf, title_rect)

        # ìœ„ì¹˜
        if self.location:
            small_font = self.fonts.get("small") or font
            loc_surf = small_font.render(self.location, True, (180, 180, 180))
            loc_surf.set_alpha(alpha)
            loc_rect = loc_surf.get_rect(midtop=(self.screen_size[0] // 2, title_rect.bottom + 10))
            screen.blit(loc_surf, loc_rect)

    def _draw_dialogue_box(self, screen: pygame.Surface, alpha: int):
        """ëŒ€ì‚¬ ë°•ìŠ¤ ê·¸ë¦¬ê¸°"""
        if self.current_dialogue_index >= len(self.dialogue_data):
            return

        dialogue = self.dialogue_data[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")

        # ëŒ€ì‚¬ ë°•ìŠ¤ ì˜ì—­ (í•˜ë‹¨ ì¤‘ì•™, ê°€ë¡œ 1/2 í¬ê¸°)
        box_height = 180
        box_width = (self.screen_size[0] - 100) // 2
        box_x = (self.screen_size[0] - box_width) // 2
        box_rect = pygame.Rect(
            box_x,
            self.screen_size[1] - box_height - 40,
            box_width,
            box_height
        )

        # ë°•ìŠ¤ ë°°ê²½
        box_surf = pygame.Surface((box_rect.width, box_rect.height), pygame.SRCALPHA)
        pygame.draw.rect(box_surf, (20, 20, 40, 220), (0, 0, box_rect.width, box_rect.height), border_radius=10)
        pygame.draw.rect(box_surf, (100, 100, 150, 200), (0, 0, box_rect.width, box_rect.height), 2, border_radius=10)
        box_surf.set_alpha(alpha)
        screen.blit(box_surf, box_rect.topleft)

        # ì´ˆìƒí™” (ëª¨ë“  ìºë¦­í„° ì™¼ìª½ ë°°ì¹˜)
        portrait = self._get_portrait(speaker)
        portrait_width = 0
        if portrait:
            portrait_rect = portrait.get_rect()
            portrait_rect.bottomleft = (box_rect.left + 20, box_rect.bottom - 10)

            portrait_copy = portrait.copy()
            portrait_copy.set_alpha(alpha)
            screen.blit(portrait_copy, portrait_rect)
            portrait_width = portrait_rect.width + 30

        # í™”ì ì´ë¦„
        name_color = self.character_colors.get(speaker, (255, 255, 255))
        font = self.fonts.get("medium") or self.fonts.get("small")

        # í…ìŠ¤íŠ¸ ì‹œì‘ X ìœ„ì¹˜ (ì´ˆìƒí™” ì˜¤ë¥¸ìª½)
        text_left_x = box_rect.left + portrait_width + 20

        if font and speaker and speaker not in ["NARRATOR", "SYSTEM"]:
            # ì´ë¦„ í‘œì‹œ
            display_name = {
                "ARTEMIS": "ì•„ë¥´í…Œë¯¸ìŠ¤",
                "PILOT": "íŒŒì¼ëŸ¿",
                "BOSS": "???",
            }.get(speaker, speaker)

            name_surf = font.render(display_name, True, name_color)
            name_surf.set_alpha(alpha)
            name_rect = name_surf.get_rect(topleft=(text_left_x, box_rect.top + 15))
            screen.blit(name_surf, name_rect)
            text_y = name_rect.bottom + 10
        else:
            text_y = box_rect.top + 20

        # ëŒ€ì‚¬ í…ìŠ¤íŠ¸
        small_font = self.fonts.get("small") or font
        if small_font and self.current_text:
            text_color = (255, 255, 255) if speaker not in ["NARRATOR", "SYSTEM"] else (180, 180, 180)

            # ì¤„ë°”ê¿ˆ ì²˜ë¦¬ (ì´ˆìƒí™” ìœ„ì¹˜ì— ë”°ë¼ í…ìŠ¤íŠ¸ ì˜ì—­ ì¡°ì •)
            max_width = box_rect.width - portrait_width - 60
            words = self.current_text.split()
            lines = []
            current_line = ""

            for word in words:
                test_line = current_line + (" " if current_line else "") + word
                if small_font.size(test_line)[0] <= max_width:
                    current_line = test_line
                else:
                    if current_line:
                        lines.append(current_line)
                    current_line = word
            if current_line:
                lines.append(current_line)

            # í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            for i, line in enumerate(lines):
                text_surf = small_font.render(line, True, text_color)
                text_surf.set_alpha(alpha)
                screen.blit(text_surf, (text_left_x, text_y + i * 28))

        # í´ë¦­ ëŒ€ê¸° í‘œì‹œ
        if self.waiting_for_click:
            indicator_text = "Click to continue..." if self.current_dialogue_index < len(self.dialogue_data) - 1 else "Click to finish..."
            ind_surf = small_font.render(indicator_text, True, (150, 150, 150))
            ind_surf.set_alpha(int(alpha * (0.5 + 0.5 * math.sin(pygame.time.get_ticks() / 300))))
            ind_rect = ind_surf.get_rect(bottomright=(box_rect.right - 20, box_rect.bottom - 15))
            screen.blit(ind_surf, ind_rect)


# =========================================================
# í´ë¼ë¡œì´ë“œ íšŒìƒ íš¨ê³¼
# =========================================================
class PolaroidMemoryEffect:
    """
    í´ë¼ë¡œì´ë“œ íšŒìƒ ì»·ì”¬ íš¨ê³¼

    íŠ¹ì§•:
    - ë°°ê²½ ì´ë¯¸ì§€ + ì–´ë‘¡ê²Œ ì²˜ë¦¬
    - ì—¬ëŸ¬ ì¥ì˜ í´ë¼ë¡œì´ë“œ ì‚¬ì§„ì´ ê²¹ì³ì„œ í‘œì‹œ
    - ê° ì‚¬ì§„ì€ ëœë¤ ê°ë„ë¡œ íšŒì „
    - ìˆœì°¨ì ìœ¼ë¡œ ë“±ì¥í•˜ëŠ” ì• ë‹ˆë©”ì´ì…˜
    - í”„ë ˆì„(í° í…Œë‘ë¦¬)ì€ ì½”ë“œë¡œ ìë™ ìƒì„±
    """

    PHASE_FADEIN = 0       # ë°°ê²½ í˜ì´ë“œì¸
    PHASE_PHOTOS = 1       # ì‚¬ì§„ ë“±ì¥
    PHASE_DISPLAY = 2      # ì‚¬ì§„ í‘œì‹œ (ëŒ€ê¸°)
    PHASE_DIALOGUE = 3     # ëŒ€ì‚¬ í‘œì‹œ
    PHASE_FINAL_ZOOM = 4   # ìµœì¢… ì‚¬ì§„ í™•ëŒ€ (memory_survive)
    PHASE_FADEOUT = 5      # í˜ì´ë“œì•„ì›ƒ
    PHASE_DONE = 6         # ì™„ë£Œ

    def __init__(self, screen_size: tuple, photo_paths: list,
                 background_path: str = None, dialogue_after: list = None,
                 dialogue_per_photo: list = None,
                 sound_manager=None, special_effects: dict = None,
                 scene_id: str = "memory_scene_01"):
        """
        Args:
            screen_size: í™”ë©´ í¬ê¸°
            photo_paths: í´ë¼ë¡œì´ë“œ ì‚¬ì§„ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸
            background_path: ë°°ê²½ ì´ë¯¸ì§€ ê²½ë¡œ
            dialogue_after: ëª¨ë“  ì‚¬ì§„ í‘œì‹œ í›„ ëŒ€ì‚¬ ë¦¬ìŠ¤íŠ¸
            dialogue_per_photo: ê° í´ë¼ë¡œì´ë“œ ë“±ì¥ ì‹œ ìë™ í‘œì‹œë˜ëŠ” ëŒ€ì‚¬ ë¦¬ìŠ¤íŠ¸
            sound_manager: íš¨ê³¼ìŒ ì¬ìƒìš©
            special_effects: íŠ¹ìˆ˜ íš¨ê³¼ ì„¤ì • (íŒŒì¼ëª…: {effect: "flicker"/"fullscreen_fadeout", ...})
            scene_id: ë©”ëª¨ë¦¬ ì”¬ ì‹ë³„ì (ë¦¬í”Œë ˆì´ìš©)
        """
        self.screen_size = screen_size
        self.photo_paths = photo_paths
        self.background_path = background_path  # ë¦¬í”Œë ˆì´ìš© ì €ì¥
        self.dialogue_after = dialogue_after or []
        self.dialogue_per_photo = dialogue_per_photo or []  # ê° í´ë¼ë¡œì´ë“œì— ëŒ€ì‘í•˜ëŠ” ëŒ€í™”
        self.sound_manager = sound_manager
        self.special_effects = special_effects or {}
        self.scene_id = scene_id  # ë©”ëª¨ë¦¬ ì”¬ ID

        self.is_alive = True
        self.phase = self.PHASE_FADEIN
        self.phase_timer = 0.0

        # íƒ€ì´ë° (ì¡°ê¸ˆ ë¹ ë¥´ê²Œ ì¡°ì • - ê¸°ì¡´ ëŒ€ë¹„ ì•½ 15% ë‹¨ì¶•)
        self.fadein_duration = 1.8
        self.photo_interval = 4.3  # ì‚¬ì§„ ì™„ì „ ë“±ì¥ í›„ ëŒ€ê¸° ì‹œê°„ (ëŒ€í™” ì½ì„ ì‹œê°„ í¬í•¨)
        self.photo_animation_speed = 0.12  # ì‚¬ì§„ ë‚ ì•„ì˜¤ëŠ” ì†ë„
        self.display_duration = 2.5  # ì „ì²´ ì‚¬ì§„ í‘œì‹œ í›„ ëŒ€ê¸° ì‹œê°„
        self.fadeout_duration = 1.8
        self.fade_alpha = 0.0

        # ì‚¬ì§„ í™•ëŒ€ íš¨ê³¼ìš© (ì—¬ëŸ¬ ì‚¬ì§„ ì§€ì›)
        self.final_zoom_duration = 3.0  # í™•ëŒ€ ì§€ì† ì‹œê°„
        self.final_zoom_scale = 1.0  # í˜„ì¬ í™•ëŒ€ ë°°ìœ¨
        self.final_zoom_alpha = 255  # ìµœì¢… ì‚¬ì§„ ì•ŒíŒŒ
        self.zoom_photo_indices = []  # í™•ëŒ€ íš¨ê³¼ ì ìš©í•  ì‚¬ì§„ ì¸ë±ìŠ¤ ë¦¬ìŠ¤íŠ¸
        self.current_zoom_index = 0  # í˜„ì¬ í™•ëŒ€ ì¤‘ì¸ ì‚¬ì§„ ì¸ë±ìŠ¤ (ë¦¬ìŠ¤íŠ¸ ë‚´ ìœ„ì¹˜)
        self.final_photo_index = -1  # í˜„ì¬ í™•ëŒ€ ì¤‘ì¸ ì‹¤ì œ ì‚¬ì§„ ì¸ë±ìŠ¤ (í˜¸í™˜ì„±ìš©)

        # ì ë©¸ íš¨ê³¼ìš©
        self.flicker_timer = 0.0

        # ë°°ê²½
        self.background = None
        if background_path:
            self._load_background(background_path)

        # í´ë¼ë¡œì´ë“œ ì‚¬ì§„ë“¤
        self.polaroids = []
        self._prepare_polaroids()

        # í˜„ì¬ í‘œì‹œ ì¤‘ì¸ ì‚¬ì§„ ê°œìˆ˜
        self.visible_count = 0
        self.photo_timer = 0.0

        # ëŒ€ì‚¬ ê´€ë ¨ (í´ë¼ë¡œì´ë“œë³„ + ë§ˆì§€ë§‰ ëŒ€í™”)
        self.current_dialogue_index = 0
        self.dialogue_text = ""
        self.typing_progress = 0.0
        self.typing_speed = 30.0  # íƒ€ì´í•‘ ì†ë„
        self.waiting_for_click = False
        self.current_photo_dialogue_shown = False  # í˜„ì¬ í´ë¼ë¡œì´ë“œ ëŒ€í™” í‘œì‹œ ì™„ë£Œ ì—¬ë¶€

        # ì´ˆìƒí™” ìºì‹œ
        self.portrait_cache = {}

        # í°íŠ¸
        self.fonts = {}

        # ì½œë°±
        self.on_complete = None
        self.on_replay_request = None  # ë¦¬í”Œë ˆì´ ìš”ì²­ ì½œë°±

        # ë¦¬í”Œë ˆì´ ë²„íŠ¼ ê´€ë ¨
        self.replay_button_rect = None
        self.replay_button_hover = False
        self.replay_button_alpha = 0.0  # ë²„íŠ¼ í˜ì´ë“œ ì¸ íš¨ê³¼

    def _load_background(self, path: str):
        """ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ"""
        try:
            img = pygame.image.load(path).convert()
            self.background = pygame.transform.scale(img, self.screen_size)
        except Exception as e:
            print(f"WARNING: Failed to load background: {path} - {e}")

    def _prepare_polaroids(self):
        """í´ë¼ë¡œì´ë“œ ì‚¬ì§„ ì¤€ë¹„ - ìì—°ìŠ¤ëŸ½ê²Œ í©ì–´ì§„ ë°°ì¹˜"""
        import random

        # í™”ë©´ ì¤‘ì•™ ì˜ì—­ ê³„ì‚°
        screen_w, screen_h = self.screen_size
        center_x = screen_w // 2
        center_y = screen_h // 2 - 50

        # ì‚¬ì§„ í¬ê¸°
        photo_size = 260

        # ìì—°ìŠ¤ëŸ½ê²Œ í©ì–´ì§„ ìœ„ì¹˜ (í…Œì´ë¸” ìœ„ì— ë˜ì ¸ë†“ì€ ëŠë‚Œ)
        # í° í…Œë‘ë¦¬ê°€ ì‚´ì§ ê²¹ì¹˜ëŠ” ì •ë„ë¡œ ë°°ì¹˜ - 9ì¥ ì‚¬ì§„ìš©
        base_positions = [
            (-320, -160),   # ì¢Œìƒë‹¨ - 1ë²ˆ
            (80, -200),     # ì¤‘ìƒë‹¨ (ì•½ê°„ ì¹˜ìš°ì¹¨) - 2ë²ˆ
            (350, -80),     # ìš°ì¸¡ - 3ë²ˆ
            (-250, 100),    # ì¢Œí•˜ë‹¨ - 4ë²ˆ
            (30, 120),      # ì¤‘ì•™ ì•„ë˜ - 5ë²ˆ
            (320, 200),     # ìš°í•˜ë‹¨ - 6ë²ˆ
            (-380, 20),     # ì¢Œì¸¡ ì¤‘ì•™ - 7ë²ˆ
            (-150, -50),    # ì¤‘ì•™ ì¢Œì¸¡ (memory_ufoìš©) - 8ë²ˆ
            (0, 0),         # ì •ì¤‘ì•™ (memory_surviveìš© - í™•ëŒ€ë  ì‚¬ì§„) - 9ë²ˆ
        ]

        positions = []
        for bx, by in base_positions:
            # ê° ìœ„ì¹˜ì— ëœë¤ ì˜¤í”„ì…‹ ì¶”ê°€ (ìì—°ìŠ¤ëŸ¬ì›€)
            offset_x = random.randint(-60, 60)
            offset_y = random.randint(-50, 50)
            x = center_x + bx + offset_x
            y = center_y + by + offset_y
            positions.append((x, y))

        # ìœ„ì¹˜ ìˆœì„œë„ ì„ê¸° (ë” ìì—°ìŠ¤ëŸ½ê²Œ)
        random.shuffle(positions)

        # ë‹¤ì–‘í•œ ì§„ì… ë°©í–¥ ì •ì˜ (ì™¸ë¶€ì—ì„œ ë‚ ì•„ì˜¤ê¸°) - 9ê°œ
        entry_directions = [
            ("left", -400, 0),      # ì™¼ìª½ì—ì„œ - 1ë²ˆ
            ("right", 400, 0),      # ì˜¤ë¥¸ìª½ì—ì„œ - 2ë²ˆ
            ("top", 0, -400),       # ìœ„ì—ì„œ - 3ë²ˆ
            ("bottom", 0, 400),     # ì•„ë˜ì—ì„œ - 4ë²ˆ
            ("top_left", -300, -300),   # ì¢Œìƒë‹¨ì—ì„œ - 5ë²ˆ
            ("bottom_right", 300, 300),  # ìš°í•˜ë‹¨ì—ì„œ - 6ë²ˆ
            ("left_bottom", -350, 200),  # ì¢Œì¸¡ ì•„ë˜ì—ì„œ - 7ë²ˆ
            ("top_right", 300, -300),   # ìš°ìƒë‹¨ì—ì„œ (memory_ufoìš©) - 8ë²ˆ
            ("bottom_left", -300, 300),  # ì¢Œí•˜ë‹¨ì—ì„œ (memory_surviveìš©) - 9ë²ˆ
        ]

        for i, path in enumerate(self.photo_paths):
            if i >= len(positions):
                break

            # ì´ë¯¸ì§€ ë¡œë“œ
            photo_img = None
            try:
                photo_img = pygame.image.load(path).convert_alpha()
                # í¬ê¸° ì¡°ì •
                photo_img = pygame.transform.smoothscale(photo_img, (photo_size, photo_size))
            except Exception as e:
                print(f"WARNING: Failed to load polaroid: {path} - {e}")
                # í”Œë ˆì´ìŠ¤í™€ë” ìƒì„±
                photo_img = pygame.Surface((photo_size, photo_size))
                photo_img.fill((100, 100, 100))

            # í´ë¼ë¡œì´ë“œ í”„ë ˆì„ ìƒì„± (ë‚¡ì€ íš¨ê³¼)
            # 2ë²ˆì§¸ ì‚¬ì§„(ì¸ë±ìŠ¤ 1)ì—ë§Œ photo_flip_00.png ì ìš©
            framed = self._create_polaroid_frame(photo_img, photo_index=i)

            # ìµœì¢… ëª©í‘œ ìœ„ì¹˜
            target_x, target_y = positions[i]

            # ì§„ì… ë°©í–¥ ì„ íƒ (ë‹¤ì–‘í•˜ê²Œ)
            direction_name, offset_x, offset_y = entry_directions[i % len(entry_directions)]

            # ì‹œì‘ ìœ„ì¹˜ (í™”ë©´ ì™¸ë¶€)
            start_x = target_x + offset_x
            start_y = target_y + offset_y

            # ëœë¤ ê°ë„ (-18ë„ ~ +18ë„) - ë” ìì—°ìŠ¤ëŸ½ê²Œ ê¸°ìš¸ì–´ì§
            angle = random.uniform(-18, 18)

            # íšŒì „ ì ìš©
            rotated = pygame.transform.rotate(framed, angle)

            # íŒŒì¼ëª… ì¶”ì¶œ (íŠ¹ìˆ˜ íš¨ê³¼ í™•ì¸ìš©)
            filename = Path(path).name
            effect_info = self.special_effects.get(filename, {})
            effect_type = effect_info.get("effect", None)

            # í™•ëŒ€ íš¨ê³¼ê°€ ì ìš©ë  ì‚¬ì§„ ì¸ë±ìŠ¤ ì €ì¥ (flicker_then_zoom ë˜ëŠ” fullscreen_fadeout)
            if effect_type in ["fullscreen_fadeout", "flicker_then_zoom"]:
                self.zoom_photo_indices.append(i)

            self.polaroids.append({
                'image': rotated,
                'original_image': framed,  # ì›ë³¸ ë³´ê´€ (ìŠ¤ì¼€ì¼ ì¡°ì •ìš©)
                'photo_image': photo_img,  # ì›ë³¸ ì‚¬ì§„ (í™•ëŒ€ìš©)
                'pos': [start_x, start_y],  # í˜„ì¬ ìœ„ì¹˜ (ë¦¬ìŠ¤íŠ¸ë¡œ ë³€ê²½ - ìˆ˜ì • ê°€ëŠ¥)
                'target_pos': (target_x, target_y),  # ëª©í‘œ ìœ„ì¹˜
                'start_pos': (start_x, start_y),  # ì‹œì‘ ìœ„ì¹˜
                'angle': angle,
                'target_angle': angle + random.uniform(-3, 3),  # ìµœì¢… ê°ë„ (ì‚´ì§ ë³€í™”)
                'alpha': 0,  # ì²˜ìŒì—” íˆ¬ëª…
                'target_alpha': 255,
                'scale': 0.5,  # ì²˜ìŒì—” ì‘ê²Œ
                'target_scale': 1.0,
                'direction': direction_name,
                'animation_progress': 0.0,  # 0.0 ~ 1.0
                'filename': filename,  # íŒŒì¼ëª… (íŠ¹ìˆ˜ íš¨ê³¼ìš©)
                'effect_type': effect_type,  # íŠ¹ìˆ˜ íš¨ê³¼ íƒ€ì…
                'flicker_speed': effect_info.get("flicker_speed", 0.3),  # ì ë©¸ ì†ë„
                'flicker_phase': 0.0,  # ì ë©¸ ìœ„ìƒ
            })

    def _create_polaroid_frame(self, photo: pygame.Surface, photo_index: int = 0) -> pygame.Surface:
        """í´ë¼ë¡œì´ë“œ í”„ë ˆì„ ìƒì„± - ë‚¡ê³  ë¹›ë°”ëœ íš¨ê³¼"""
        import random

        photo_w, photo_h = photo.get_size()

        # í”„ë ˆì„ í¬ê¸° (í…Œë‘ë¦¬ 18px, í•˜ë‹¨ 45px ì¶”ê°€ - ë” í¬ê²Œ)
        border = 18
        bottom_margin = 45
        frame_w = photo_w + border * 2
        frame_h = photo_h + border + bottom_margin

        # í”„ë ˆì„ Surface ìƒì„±
        frame = pygame.Surface((frame_w, frame_h), pygame.SRCALPHA)

        # ì˜¤ë˜ëœ í´ë¼ë¡œì´ë“œ ìƒ‰ìƒ (ì•„ì´ë³´ë¦¬/í¬ë¦¼ìƒ‰, ì•½ê°„ ë³€ìƒ‰)
        base_color = (245, 240, 225)  # ë¹›ë°”ëœ í¬ë¦¼ìƒ‰
        frame.fill(base_color)

        # ë¶ˆê· ì¼í•œ ë³€ìƒ‰ íš¨ê³¼ (ë…¸ì´ì¦ˆ)
        for _ in range(50):
            x = random.randint(0, frame_w - 1)
            y = random.randint(0, frame_h - 1)
            spot_size = random.randint(3, 8)
            # ì•½ê°„ ë” ì–´ë‘¡ê±°ë‚˜ ëˆ„ëŸ° ë°˜ì 
            spot_color = (
                base_color[0] - random.randint(5, 20),
                base_color[1] - random.randint(8, 25),
                base_color[2] - random.randint(10, 30),
            )
            pygame.draw.circle(frame, spot_color, (x, y), spot_size)

        # ê°€ì¥ìë¦¬ ì–´ë‘¡ê²Œ (ë¹›ë°”ëœ íš¨ê³¼)
        edge_overlay = pygame.Surface((frame_w, frame_h), pygame.SRCALPHA)
        # ìƒë‹¨ ê°€ì¥ìë¦¬
        for i in range(8):
            alpha = 25 - i * 3
            pygame.draw.line(edge_overlay, (180, 170, 140, alpha), (0, i), (frame_w, i))
        # í•˜ë‹¨ ê°€ì¥ìë¦¬
        for i in range(8):
            alpha = 25 - i * 3
            pygame.draw.line(edge_overlay, (180, 170, 140, alpha), (0, frame_h - 1 - i), (frame_w, frame_h - 1 - i))
        # ì¢Œì¸¡ ê°€ì¥ìë¦¬
        for i in range(6):
            alpha = 20 - i * 3
            pygame.draw.line(edge_overlay, (180, 170, 140, alpha), (i, 0), (i, frame_h))
        # ìš°ì¸¡ ê°€ì¥ìë¦¬
        for i in range(6):
            alpha = 20 - i * 3
            pygame.draw.line(edge_overlay, (180, 170, 140, alpha), (frame_w - 1 - i, 0), (frame_w - 1 - i, frame_h))
        frame.blit(edge_overlay, (0, 0))

        # ì™¸ê³½ì„  (ë‚¡ì€ ê°ˆìƒ‰ í†¤)
        pygame.draw.rect(frame, (200, 185, 160), (0, 0, frame_w, frame_h), 2)
        # ë‚´ë¶€ í…Œë‘ë¦¬ (ë” ë°ì€ ì„ )
        pygame.draw.rect(frame, (230, 220, 200), (2, 2, frame_w - 4, frame_h - 4), 1)

        # ì‚¬ì§„ì— ì•½ê°„ì˜ ì„¸í”¼ì•„/ë¹ˆí‹°ì§€ íš¨ê³¼ ì ìš©
        vintage_photo = self._apply_vintage_effect(photo)

        # ì‚¬ì§„ ë°°ì¹˜
        frame.blit(vintage_photo, (border, border))

        # ì‚¬ì§„ í…Œë‘ë¦¬ (ì•½ê°„ ì–´ë‘ìš´ ì„ )
        pygame.draw.rect(frame, (210, 200, 180), (border - 1, border - 1, photo_w + 2, photo_h + 2), 1)

        # ëª¨ì„œë¦¬ ë“¤ëœ¬ íš¨ê³¼ - 2ë²ˆì§¸ ì‚¬ì§„(ì¸ë±ìŠ¤ 1)ì—ë§Œ photo_flip_00.png ì ìš©
        if photo_index == 1:
            flip_overlay = self._load_flip_overlay(frame_w, frame_h, border, photo_w, photo_h,
                                                    flip_file="photo_flip_00.png")
            if flip_overlay:
                frame.blit(flip_overlay, (0, 0))

        return frame

    def _load_flip_overlay(self, frame_w: int, frame_h: int,
                              border: int = 18, photo_w: int = 260, photo_h: int = 260,
                              flip_file: str = "photo_flip.png") -> pygame.Surface:
        """ëª¨ì„œë¦¬ ë“¤ëœ¬ íš¨ê³¼ ì´ë¯¸ì§€ ë¡œë“œ - í”„ë ˆì„(í° í…Œë‘ë¦¬)ì—ë§Œ ì ìš©"""
        try:
            flip_path = f"assets/story_mode/polaroids/{flip_file}"
            if Path(flip_path).exists():
                img = pygame.image.load(flip_path).convert_alpha()
                # í”„ë ˆì„ í¬ê¸°ì— ë§ê²Œ ìŠ¤ì¼€ì¼ë§
                img = pygame.transform.scale(img, (frame_w, frame_h))

                # ì‚¬ì§„ ì˜ì—­ì„ íˆ¬ëª…í•˜ê²Œ ë§Œë“¤ê¸° (í”„ë ˆì„ë§Œ íš¨ê³¼ ì ìš©)
                # ì‚¬ì§„ ì˜ì—­ì˜ ìœ„ì¹˜: (border, border) ~ (border + photo_w, border + photo_h)
                transparent_rect = pygame.Surface((photo_w, photo_h), pygame.SRCALPHA)
                transparent_rect.fill((0, 0, 0, 0))
                # BLEND_RGBA_MIN: ì•ŒíŒŒê°’ì„ ìµœì†Œí™”í•˜ì—¬ í•´ë‹¹ ì˜ì—­ì„ íˆ¬ëª…í•˜ê²Œ
                img.blit(transparent_rect, (border, border), special_flags=pygame.BLEND_RGBA_MIN)

                return img
        except Exception as e:
            print(f"WARNING: Failed to load photo_flip.png: {e}")
        return None

    def _apply_vintage_effect(self, photo: pygame.Surface) -> pygame.Surface:
        """ì‚¬ì§„ì— ë¹ˆí‹°ì§€/ì„¸í”¼ì•„ íš¨ê³¼ ì ìš©"""
        result = photo.copy()
        w, h = result.get_size()

        # ì „ì²´ì ìœ¼ë¡œ ì•½ê°„ ë”°ëœ»í•œ í†¤ ì¶”ê°€ (ì„¸í”¼ì•„ ëŠë‚Œ)
        sepia_overlay = pygame.Surface((w, h), pygame.SRCALPHA)
        sepia_overlay.fill((255, 240, 200, 30))  # ë”°ëœ»í•œ ì„¸í”¼ì•„ í†¤
        result.blit(sepia_overlay, (0, 0))

        # ë¹„ë„¤íŠ¸ íš¨ê³¼ (ê°€ì¥ìë¦¬ ì–´ë‘¡ê²Œ)
        vignette = pygame.Surface((w, h), pygame.SRCALPHA)
        for i in range(20):
            alpha = 3 * (20 - i)
            # ìƒë‹¨
            pygame.draw.line(vignette, (0, 0, 0, alpha), (0, i), (w, i))
            # í•˜ë‹¨
            pygame.draw.line(vignette, (0, 0, 0, alpha), (0, h - 1 - i), (w, h - 1 - i))
            # ì¢Œì¸¡
            pygame.draw.line(vignette, (0, 0, 0, alpha), (i, 0), (i, h))
            # ìš°ì¸¡
            pygame.draw.line(vignette, (0, 0, 0, alpha), (w - 1 - i, 0), (w - 1 - i, h))
        result.blit(vignette, (0, 0))

        return result

    def set_fonts(self, fonts: dict):
        """í°íŠ¸ ì„¤ì •"""
        self.fonts = fonts

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        if self.phase == self.PHASE_FADEIN:
            progress = min(self.phase_timer / self.fadein_duration, 1.0)
            self.fade_alpha = progress

            if progress >= 1.0:
                self.phase = self.PHASE_PHOTOS
                self.phase_timer = 0.0
                self.photo_timer = 0.0

        elif self.phase == self.PHASE_PHOTOS:
            # ì‚¬ì§„ ìˆœì°¨ ë“±ì¥ (í•œ ì‚¬ì§„ì´ ì™„ì „íˆ ë“±ì¥í•œ í›„ ëŒ€í™” í‘œì‹œ + ì¸í„°ë²Œ ëŒ€ê¸°)
            self.photo_timer += dt

            # í˜„ì¬ ì‚¬ì§„ì´ ì™„ì „íˆ ë“±ì¥í–ˆëŠ”ì§€ í™•ì¸
            current_photo_complete = False
            if self.visible_count > 0 and self.visible_count <= len(self.polaroids):
                current_p = self.polaroids[self.visible_count - 1]
                current_photo_complete = current_p['animation_progress'] >= 1.0

            # í´ë¼ë¡œì´ë“œ ë“±ì¥ ì‹œ í•´ë‹¹ ëŒ€í™” ìë™ í‘œì‹œ
            if current_photo_complete and not self.current_photo_dialogue_shown:
                photo_index = self.visible_count - 1
                if photo_index < len(self.dialogue_per_photo):
                    # í•´ë‹¹ í´ë¼ë¡œì´ë“œì˜ ëŒ€í™” ì‹œì‘
                    self.dialogue_text = ""
                    self.typing_progress = 0.0
                    self.current_photo_dialogue_shown = True
                    self.photo_timer = 0.0  # ëŒ€í™” í‘œì‹œ ì‹œì‘ ì‹œì ë¶€í„° íƒ€ì´ë¨¸

            # ëŒ€í™” íƒ€ì´í•‘ íš¨ê³¼ (PHASE_PHOTOS ì¤‘ì—ë„)
            if self.current_photo_dialogue_shown and self.visible_count > 0:
                photo_index = self.visible_count - 1
                if photo_index < len(self.dialogue_per_photo):
                    self.typing_progress += self.typing_speed * dt
                    char_count = int(self.typing_progress)
                    full_text = self.dialogue_per_photo[photo_index].get("text", "")
                    if char_count >= len(full_text):
                        self.dialogue_text = full_text
                    else:
                        self.dialogue_text = full_text[:char_count]

            # ë‹¤ìŒ ì‚¬ì§„ ë“±ì¥ ì¡°ê±´: í˜„ì¬ ì‚¬ì§„ ì™„ë£Œ + ëŒ€í™” í‘œì‹œ ì™„ë£Œ + ì¸í„°ë²Œ ê²½ê³¼
            if self.visible_count == 0:
                # ì²« ë²ˆì§¸ ì‚¬ì§„ì€ ë°”ë¡œ ì‹œì‘
                if self.sound_manager:
                    self.sound_manager.play_sfx("sfx_polaroid")
                self.visible_count = 1
                self.photo_timer = 0.0
                self.current_photo_dialogue_shown = False
            elif current_photo_complete and self.visible_count < len(self.polaroids):
                # í˜„ì¬ ì‚¬ì§„ ì™„ë£Œ + ëŒ€í™” ì½ì„ ì‹œê°„ í›„ ë‹¤ìŒ ì‚¬ì§„
                if self.photo_timer >= self.photo_interval:
                    if self.sound_manager:
                        self.sound_manager.play_sfx("sfx_polaroid")
                    self.visible_count += 1
                    self.photo_timer = 0.0  # íƒ€ì´ë¨¸ ë¦¬ì…‹
                    self.current_photo_dialogue_shown = False  # ë‹¤ìŒ ëŒ€í™” ì¤€ë¹„
                    self.dialogue_text = ""  # ëŒ€í™” ì´ˆê¸°í™”

            # ì‚¬ì§„ ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸ (2ë°° í™•ëŒ€ â†’ ì ì‹œ ìœ ì§€ â†’ ì›ë˜ í¬ê¸°ë¡œ ì¶•ì†Œ)
            for i, p in enumerate(self.polaroids):
                if i < self.visible_count:
                    # ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ë„ ì—…ë°ì´íŠ¸
                    p['animation_progress'] = min(p['animation_progress'] + self.photo_animation_speed * dt, 1.0)
                    progress = p['animation_progress']

                    # 3ë‹¨ê³„ ì• ë‹ˆë©”ì´ì…˜: ë“±ì¥(0~0.3) â†’ í™•ëŒ€ ìœ ì§€(0.3~0.6) â†’ ì¶•ì†Œ(0.6~1.0)
                    if progress < 0.3:
                        # 1ë‹¨ê³„: ë“±ì¥ (ì™¸ë¶€ì—ì„œ ë‚ ì•„ì˜¤ë©° 2ë°° í¬ê¸°ë¡œ)
                        phase_progress = progress / 0.3
                        eased = 1 - pow(1 - phase_progress, 3)  # ease-out-cubic

                        # ìœ„ì¹˜ ë³´ê°„ (ì‹œì‘ â†’ ëª©í‘œ)
                        start_x, start_y = p['start_pos']
                        target_x, target_y = p['target_pos']
                        p['pos'][0] = start_x + (target_x - start_x) * eased
                        p['pos'][1] = start_y + (target_y - start_y) * eased

                        # ì•ŒíŒŒ ì¦ê°€
                        p['alpha'] = min(int(255 * eased), p['target_alpha'])

                        # ìŠ¤ì¼€ì¼: 0.5 â†’ 2.0 (ë“±ì¥í•˜ë©´ì„œ 2ë°°ë¡œ í™•ëŒ€)
                        p['scale'] = 0.5 + 1.5 * eased

                    elif progress < 0.6:
                        # 2ë‹¨ê³„: í™•ëŒ€ ìƒíƒœ ìœ ì§€ (2ë°° í¬ê¸°ë¡œ ì ì‹œ ë³´ì—¬ì¤Œ)
                        p['pos'][0], p['pos'][1] = p['target_pos']
                        p['alpha'] = 255
                        p['scale'] = 2.0

                    else:
                        # 3ë‹¨ê³„: ì›ë˜ í¬ê¸°ë¡œ ì¶•ì†Œ (2.0 â†’ 1.0)
                        phase_progress = (progress - 0.6) / 0.4
                        eased = 1 - pow(1 - phase_progress, 2)  # ease-out-quad

                        p['pos'][0], p['pos'][1] = p['target_pos']
                        p['alpha'] = 255
                        # ìŠ¤ì¼€ì¼: 2.0 â†’ 1.0
                        p['scale'] = 2.0 - 1.0 * eased

                    # ì ë©¸ íš¨ê³¼ (flicker ë˜ëŠ” flicker_then_zoom) - ì¶•ì†Œ ì™„ë£Œ í›„ì—ë§Œ ì ìš©
                    if p.get('effect_type') in ['flicker', 'flicker_then_zoom'] and p['animation_progress'] >= 0.95:
                        p['flicker_phase'] += dt * (1.0 / p.get('flicker_speed', 0.3))
                        # ëŠë¦° ì ë©¸ (ì‚¬ì¸íŒŒë¡œ ë¶€ë“œëŸ½ê²Œ)
                        flicker_val = 0.5 + 0.5 * math.sin(p['flicker_phase'] * math.pi)
                        p['alpha'] = int(150 + 105 * flicker_val)  # 150~255 ì‚¬ì´

            # ëª¨ë“  ì‚¬ì§„ ë“±ì¥ ì™„ë£Œ
            if self.visible_count >= len(self.polaroids):
                all_complete = all(p['animation_progress'] >= 0.98 for p in self.polaroids)
                if all_complete:
                    # ìµœì¢… ìœ„ì¹˜ë¡œ ê³ ì •
                    for p in self.polaroids:
                        p['pos'][0], p['pos'][1] = p['target_pos']
                        # ì ë©¸ íš¨ê³¼ (flicker ë˜ëŠ” flicker_then_zoom)ëŠ” ì•ŒíŒŒ ìœ ì§€
                        if p.get('effect_type') not in ['flicker', 'flicker_then_zoom']:
                            p['alpha'] = 255
                        p['scale'] = 1.0
                    self.phase = self.PHASE_DISPLAY
                    self.phase_timer = 0.0

        elif self.phase == self.PHASE_DISPLAY:
            # ì ë©¸ íš¨ê³¼ ì—…ë°ì´íŠ¸ (DISPLAY ì¤‘ì—ë„ ê³„ì†) - flicker_then_zoomë„ í¬í•¨
            for p in self.polaroids:
                if p.get('effect_type') in ['flicker', 'flicker_then_zoom']:
                    p['flicker_phase'] += dt * (1.0 / p.get('flicker_speed', 0.3))
                    flicker_val = 0.5 + 0.5 * math.sin(p['flicker_phase'] * math.pi)
                    p['alpha'] = int(150 + 105 * flicker_val)

            # ì ì‹œ í‘œì‹œ
            if self.phase_timer >= self.display_duration:
                # í™•ëŒ€ íš¨ê³¼ê°€ ì ìš©ë  ì‚¬ì§„ì´ ìˆìœ¼ë©´ FINAL_ZOOMìœ¼ë¡œ ì „í™˜
                if len(self.zoom_photo_indices) > 0:
                    self.current_zoom_index = 0
                    self.final_photo_index = self.zoom_photo_indices[0]
                    self.phase = self.PHASE_FINAL_ZOOM
                    self.phase_timer = 0.0
                    self.final_zoom_scale = 1.0
                    self.final_zoom_alpha = 255
                elif self.dialogue_after:
                    self.phase = self.PHASE_DIALOGUE
                    self.phase_timer = 0.0
                    self._prepare_dialogue(0)
                else:
                    self.phase = self.PHASE_FADEOUT
                    self.phase_timer = 0.0

        elif self.phase == self.PHASE_FINAL_ZOOM:
            # ì‚¬ì§„ í™”ë©´ ì „ì²´ë¡œ í™•ëŒ€ í›„ í˜ì´ë“œì•„ì›ƒ (ì—¬ëŸ¬ ì‚¬ì§„ ìˆœì°¨ ì²˜ë¦¬)
            progress = min(self.phase_timer / self.final_zoom_duration, 1.0)

            # ì´ì§• (ease-in-out)
            if progress < 0.5:
                eased = 2 * progress * progress
            else:
                eased = 1 - pow(-2 * progress + 2, 2) / 2

            # í™•ëŒ€ ë°°ìœ¨ (1.0 â†’ í™”ë©´ ê°€ë“)
            # ëª©í‘œ ë°°ìœ¨: í™”ë©´ í¬ê¸° / ì‚¬ì§„ í¬ê¸° * ì•½ê°„ì˜ ì—¬ìœ 
            target_scale = max(self.screen_size[0], self.screen_size[1]) / 260 * 1.2
            self.final_zoom_scale = 1.0 + (target_scale - 1.0) * eased

            # í›„ë°˜ë¶€ì— í˜ì´ë“œì•„ì›ƒ ì‹œì‘
            if progress > 0.6:
                fade_progress = (progress - 0.6) / 0.4
                self.final_zoom_alpha = int(255 * (1.0 - fade_progress))

            if progress >= 1.0:
                # ë‹¤ìŒ í™•ëŒ€ ì‚¬ì§„ì´ ìˆëŠ”ì§€ í™•ì¸
                self.current_zoom_index += 1
                if self.current_zoom_index < len(self.zoom_photo_indices):
                    # ë‹¤ìŒ ì‚¬ì§„ í™•ëŒ€ ì‹œì‘
                    self.final_photo_index = self.zoom_photo_indices[self.current_zoom_index]
                    self.phase_timer = 0.0
                    self.final_zoom_scale = 1.0
                    self.final_zoom_alpha = 255
                else:
                    # ëª¨ë“  í™•ëŒ€ ì™„ë£Œ â†’ ëŒ€ì‚¬ ë˜ëŠ” í˜ì´ë“œì•„ì›ƒ
                    if self.dialogue_after:
                        self.phase = self.PHASE_DIALOGUE
                        self.phase_timer = 0.0
                        self._prepare_dialogue(0)
                    else:
                        self.phase = self.PHASE_FADEOUT
                        self.phase_timer = 0.0

        elif self.phase == self.PHASE_DIALOGUE:
            # íƒ€ì´í•‘ íš¨ê³¼
            if not self.waiting_for_click:
                self.typing_progress += self.typing_speed * dt
                char_count = int(self.typing_progress)
                full_text = self.dialogue_after[self.current_dialogue_index].get("text", "")

                if char_count >= len(full_text):
                    self.dialogue_text = full_text
                    self.waiting_for_click = True
                else:
                    self.dialogue_text = full_text[:char_count]

        elif self.phase == self.PHASE_FADEOUT:
            progress = min(self.phase_timer / self.fadeout_duration, 1.0)
            self.fade_alpha = 1.0 - progress

            # ì‚¬ì§„ í˜ì´ë“œì•„ì›ƒ
            for p in self.polaroids:
                p['alpha'] = max(0, int(255 * (1.0 - progress)))

            if progress >= 1.0:
                self.phase = self.PHASE_DONE
                self.is_alive = False
                if self.on_complete:
                    self.on_complete()

    def _get_portrait(self, speaker: str) -> pygame.Surface:
        """ì´ˆìƒí™” ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸° (ìºì‹œ ì‚¬ìš©)"""
        if speaker in self.portrait_cache:
            return self.portrait_cache[speaker]

        # config_story_dialogueì—ì„œ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
        try:
            from mode_configs.config_story_dialogue import CHARACTER_PORTRAITS
            path = CHARACTER_PORTRAITS.get(speaker)
        except ImportError:
            # í´ë°±: ê¸°ë³¸ ê²½ë¡œ
            portrait_paths = {
                "ARTEMIS": "assets/story_mode/portraits/portrait_artemis.jpg",
                "PILOT": "assets/story_mode/portraits/portrait_pilot.png",
            }
            path = portrait_paths.get(speaker)

        if path:
            try:
                img = pygame.image.load(path).convert_alpha()
                # í¬ê¸° ì¡°ì • (150x150 ì •ë„)
                target_size = (150, 150)
                img = pygame.transform.smoothscale(img, target_size)
                self.portrait_cache[speaker] = img
                return img
            except Exception as e:
                print(f"WARNING: Failed to load portrait for {speaker}: {e}")

        return None

    def _prepare_dialogue(self, index: int):
        """ëŒ€ì‚¬ ì¤€ë¹„"""
        if 0 <= index < len(self.dialogue_after):
            self.dialogue_text = ""
            self.typing_progress = 0.0
            self.waiting_for_click = False

    def handle_click(self):
        """í´ë¦­ ì²˜ë¦¬ - í´ë¼ë¡œì´ë“œ ë“±ì¥ ì¤‘ì—ëŠ” í´ë¦­ ë¬´ì‹œ (ìë™ ì§„í–‰)"""
        if self.phase == self.PHASE_FADEIN:
            # í˜ì´ë“œì¸ ì¤‘ í´ë¦­ ì‹œ ìŠ¤í‚µ
            self.phase = self.PHASE_PHOTOS
            self.phase_timer = 0.0
            self.fade_alpha = 1.0
            return

        if self.phase == self.PHASE_PHOTOS:
            # í´ë¼ë¡œì´ë“œ ë“±ì¥ ì¤‘ì—ëŠ” í´ë¦­ ë¬´ì‹œ (ìë™ ì§„í–‰ë§Œ í—ˆìš©)
            # í´ë¦­ìœ¼ë¡œ ì¦‰ì‹œ ë“±ì¥í•˜ëŠ” ê¸°ëŠ¥ ì‚­ì œ
            return

        if self.phase == self.PHASE_DISPLAY:
            # ìµœì¢… ì‚¬ì§„ í™•ëŒ€ íš¨ê³¼ê°€ ìˆìœ¼ë©´ FINAL_ZOOMìœ¼ë¡œ ì „í™˜
            if self.final_photo_index >= 0:
                self.phase = self.PHASE_FINAL_ZOOM
                self.phase_timer = 0.0
                self.final_zoom_scale = 1.0
                self.final_zoom_alpha = 255
            elif self.dialogue_after:
                self.phase = self.PHASE_DIALOGUE
                self.phase_timer = 0.0
                self._prepare_dialogue(0)
            else:
                self.phase = self.PHASE_FADEOUT
                self.phase_timer = 0.0
            return

        if self.phase == self.PHASE_FINAL_ZOOM:
            # ìµœì¢… í™•ëŒ€ ìŠ¤í‚µ â†’ ëŒ€ì‚¬ ë˜ëŠ” í˜ì´ë“œì•„ì›ƒ
            if self.dialogue_after:
                self.phase = self.PHASE_DIALOGUE
                self.phase_timer = 0.0
                self._prepare_dialogue(0)
            else:
                self.phase = self.PHASE_FADEOUT
                self.phase_timer = 0.0
            return

        if self.phase == self.PHASE_DIALOGUE:
            # ë¦¬í”Œë ˆì´ ë²„íŠ¼ í´ë¦­ ì²´í¬ (ë§ˆì§€ë§‰ ëŒ€ì‚¬ì¼ ë•Œ)
            is_last_dialogue = self.current_dialogue_index >= len(self.dialogue_after) - 1
            if is_last_dialogue and self.waiting_for_click and self.replay_button_rect:
                mouse_pos = pygame.mouse.get_pos()
                if self.replay_button_rect.collidepoint(mouse_pos):
                    # ë¦¬í”Œë ˆì´ ìš”ì²­
                    self._request_replay()
                    return

            if not self.waiting_for_click:
                # íƒ€ì´í•‘ ìŠ¤í‚µ
                full_text = self.dialogue_after[self.current_dialogue_index].get("text", "")
                self.dialogue_text = full_text
                self.waiting_for_click = True
            else:
                # ë‹¤ìŒ ëŒ€ì‚¬ ë˜ëŠ” ì™„ë£Œ
                self.current_dialogue_index += 1
                if self.current_dialogue_index >= len(self.dialogue_after):
                    self.phase = self.PHASE_FADEOUT
                    self.phase_timer = 0.0
                else:
                    self._prepare_dialogue(self.current_dialogue_index)

    def _request_replay(self):
        """ë¦¬í”Œë ˆì´ ìš”ì²­ - íšŒìƒ ì¥ë©´ ì¬ì‹œì‘"""
        print(f"INFO: Replay requested for {self.scene_id}")

        # ì½œë°±ì´ ìˆìœ¼ë©´ í˜¸ì¶œ (story_modeì—ì„œ ìƒˆ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±)
        if self.on_replay_request:
            self.on_replay_request(self.scene_id)
        else:
            # ì½œë°± ì—†ìœ¼ë©´ ìì²´ ë¦¬ì…‹
            self._reset_for_replay()

    def _reset_for_replay(self):
        """ë¦¬í”Œë ˆì´ë¥¼ ìœ„í•œ ë‚´ë¶€ ìƒíƒœ ë¦¬ì…‹"""
        # í˜ì´ì¦ˆ ë¦¬ì…‹
        self.phase = self.PHASE_FADEIN
        self.phase_timer = 0.0
        self.fade_alpha = 0.0

        # ì‚¬ì§„ ìƒíƒœ ë¦¬ì…‹
        self.visible_count = 0
        self.photo_timer = 0.0

        # í´ë¼ë¡œì´ë“œ ì• ë‹ˆë©”ì´ì…˜ ìƒíƒœ ë¦¬ì…‹
        for p in self.polaroids:
            p['animation_progress'] = 0.0
            p['pos'][0], p['pos'][1] = p['start_pos']
            p['alpha'] = 0
            p['scale'] = 0.5
            p['flicker_phase'] = 0.0

        # ì¤Œ íš¨ê³¼ ë¦¬ì…‹
        self.final_zoom_scale = 1.0
        self.final_zoom_alpha = 255
        self.current_zoom_index = 0
        self.final_photo_index = -1

        # ëŒ€ì‚¬ ìƒíƒœ ë¦¬ì…‹
        self.current_dialogue_index = 0
        self.dialogue_text = ""
        self.typing_progress = 0.0
        self.waiting_for_click = False
        self.current_photo_dialogue_shown = False

        # ë¦¬í”Œë ˆì´ ë²„íŠ¼ ìƒíƒœ ë¦¬ì…‹
        self.replay_button_alpha = 0.0

        print(f"INFO: {self.scene_id} reset for replay")

    def skip(self):
        """ì „ì²´ ìŠ¤í‚µ"""
        self.phase = self.PHASE_FADEOUT
        self.phase_timer = 0.0

    def draw(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        if not self.is_alive and self.phase == self.PHASE_DONE:
            return

        # ë°°ê²½
        if self.background:
            bg_copy = self.background.copy()
            bg_copy.set_alpha(int(255 * self.fade_alpha))
            screen.blit(bg_copy, (0, 0))
        else:
            screen.fill((30, 30, 40))

        # ì–´ë‘ìš´ ì˜¤ë²„ë ˆì´
        overlay = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        overlay.fill((0, 0, 0, int(150 * self.fade_alpha)))
        screen.blit(overlay, (0, 0))

        # FINAL_ZOOM ë‹¨ê³„ì—ì„œëŠ” ìµœì¢… ì‚¬ì§„ë§Œ í™•ëŒ€ ë Œë”ë§
        if self.phase == self.PHASE_FINAL_ZOOM and self.final_photo_index >= 0:
            final_p = self.polaroids[self.final_photo_index]
            # ì›ë³¸ ì‚¬ì§„ ì´ë¯¸ì§€ ì‚¬ìš© (í”„ë ˆì„ ì—†ì´)
            photo_img = final_p.get('photo_image')
            if photo_img:
                # í™•ëŒ€ ì ìš©
                zoom_w = int(photo_img.get_width() * self.final_zoom_scale)
                zoom_h = int(photo_img.get_height() * self.final_zoom_scale)
                if zoom_w > 0 and zoom_h > 0:
                    zoomed = pygame.transform.smoothscale(photo_img, (zoom_w, zoom_h))
                    zoomed.set_alpha(self.final_zoom_alpha)
                    # í™”ë©´ ì¤‘ì•™ì— ë°°ì¹˜
                    rect = zoomed.get_rect(center=(self.screen_size[0] // 2, self.screen_size[1] // 2))
                    screen.blit(zoomed, rect)
            return  # FINAL_ZOOMì—ì„œëŠ” ë‹¤ë¥¸ ì‚¬ì§„ ë Œë”ë§ ì•ˆí•¨

        # í´ë¼ë¡œì´ë“œ ì‚¬ì§„ë“¤
        for i, p in enumerate(self.polaroids):
            if i >= self.visible_count and self.phase == self.PHASE_PHOTOS:
                continue
            if p['alpha'] <= 0:
                continue

            # ìŠ¤ì¼€ì¼ ì ìš©
            scaled_w = int(p['image'].get_width() * p['scale'])
            scaled_h = int(p['image'].get_height() * p['scale'])
            if scaled_w > 0 and scaled_h > 0:
                scaled = pygame.transform.smoothscale(p['image'], (scaled_w, scaled_h))
                scaled.set_alpha(int(p['alpha']))

                rect = scaled.get_rect(center=p['pos'])
                screen.blit(scaled, rect)

        # ëŒ€ì‚¬ (í•˜ë‹¨) - PHASE_PHOTOSì—ì„œë„ í´ë¼ë¡œì´ë“œë³„ ëŒ€í™” í‘œì‹œ
        if self.phase == self.PHASE_PHOTOS and self.dialogue_text and self.current_photo_dialogue_shown:
            # í´ë¼ë¡œì´ë“œë³„ ëŒ€í™” í‘œì‹œ
            self._draw_photo_dialogue(screen)
        elif self.phase in [self.PHASE_DIALOGUE, self.PHASE_DISPLAY] and self.dialogue_text:
            self._draw_dialogue(screen)

        # í´ë¦­ íŒíŠ¸ (PHASE_PHOTOSì—ì„œëŠ” í‘œì‹œ ì•ˆí•¨ - ìë™ ì§„í–‰)
        if self.phase in [self.PHASE_DISPLAY, self.PHASE_DIALOGUE] and self.waiting_for_click:
            self._draw_click_hint(screen)

    def _draw_dialogue(self, screen: pygame.Surface):
        """ëŒ€ì‚¬ ê·¸ë¦¬ê¸° - ì´ˆìƒí™” í¬í•¨"""
        font = self.fonts.get("medium") or self.fonts.get("small")
        small_font = self.fonts.get("small") or font
        if not font:
            return

        # í˜„ì¬ ëŒ€ì‚¬ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        if self.current_dialogue_index >= len(self.dialogue_after):
            return

        current_dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = current_dialogue.get("speaker", "")

        # config_story_dialogueì—ì„œ ìƒ‰ìƒ/ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
        try:
            from mode_configs.config_story_dialogue import CHARACTER_COLORS, CHARACTER_NAMES
            text_color = CHARACTER_COLORS.get(speaker, (255, 255, 255))
            speaker_name = CHARACTER_NAMES.get(speaker, speaker)
        except ImportError:
            text_color = (255, 220, 150)
            speaker_name = speaker

        # ì´ˆìƒí™” ê°€ì ¸ì˜¤ê¸°
        portrait = self._get_portrait(speaker)
        portrait_width = 150 if portrait else 0

        # ëŒ€ì‚¬ ë°•ìŠ¤ (ê°€ë¡œ 1/2 í¬ê¸°, ì¤‘ì•™ ì •ë ¬)
        box_height = 120
        box_width = (self.screen_size[0] - 160) // 2
        box_x = (self.screen_size[0] - box_width) // 2
        box_rect = pygame.Rect(
            box_x,
            self.screen_size[1] - box_height - 40,
            box_width,
            box_height
        )

        # ë°•ìŠ¤ ë°°ê²½
        box_surf = pygame.Surface((box_rect.width, box_rect.height), pygame.SRCALPHA)
        pygame.draw.rect(box_surf, (0, 0, 0, 200), (0, 0, box_rect.width, box_rect.height), border_radius=12)
        pygame.draw.rect(box_surf, text_color + (100,), (0, 0, box_rect.width, box_rect.height), 2, border_radius=12)
        screen.blit(box_surf, box_rect.topleft)

        # ì´ˆìƒí™” ê·¸ë¦¬ê¸°
        text_left_x = box_rect.left + 25
        if portrait:
            portrait_x = box_rect.left + 15
            portrait_y = box_rect.top + (box_height - portrait_width) // 2
            # ì´ˆìƒí™” ë°°ê²½ (ì›í˜•)
            pygame.draw.circle(screen, (30, 30, 40),
                             (portrait_x + portrait_width // 2, portrait_y + portrait_width // 2),
                             portrait_width // 2 + 5)
            pygame.draw.circle(screen, text_color,
                             (portrait_x + portrait_width // 2, portrait_y + portrait_width // 2),
                             portrait_width // 2 + 5, 2)
            # ì´ˆìƒí™” ë§ˆìŠ¤í‚¹ (ì›í˜•)
            mask_surf = pygame.Surface((portrait_width, portrait_width), pygame.SRCALPHA)
            pygame.draw.circle(mask_surf, (255, 255, 255, 255),
                             (portrait_width // 2, portrait_width // 2), portrait_width // 2)
            portrait_copy = portrait.copy()
            portrait_copy.blit(mask_surf, (0, 0), special_flags=pygame.BLEND_RGBA_MIN)
            screen.blit(portrait_copy, (portrait_x, portrait_y))
            text_left_x = portrait_x + portrait_width + 20

        # í™”ì ì´ë¦„
        if speaker_name:
            name_surf = small_font.render(speaker_name, True, text_color)
            screen.blit(name_surf, (text_left_x, box_rect.top + 15))

        # ëŒ€ì‚¬ í…ìŠ¤íŠ¸ (ì—¬ëŸ¬ ì¤„ ì²˜ë¦¬)
        text_y = box_rect.top + 45
        max_width = box_rect.right - text_left_x - 30
        words = self.dialogue_text.split()
        lines = []
        current_line = ""

        for word in words:
            test_line = current_line + (" " if current_line else "") + word
            if small_font.size(test_line)[0] <= max_width:
                current_line = test_line
            else:
                if current_line:
                    lines.append(current_line)
                current_line = word
        if current_line:
            lines.append(current_line)

        # í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
        for i, line in enumerate(lines):
            text_surf = small_font.render(line, True, (255, 255, 255))
            screen.blit(text_surf, (text_left_x, text_y + i * 26))

        # ë¦¬í”Œë ˆì´ ë²„íŠ¼ (ë§ˆì§€ë§‰ ëŒ€ì‚¬ì´ê³  í´ë¦­ ëŒ€ê¸° ì¤‘ì¼ ë•Œ)
        is_last_dialogue = self.current_dialogue_index >= len(self.dialogue_after) - 1
        if is_last_dialogue and self.waiting_for_click:
            self._draw_replay_button(screen, box_rect)

    def _draw_replay_button(self, screen: pygame.Surface, dialogue_box_rect: pygame.Rect):
        """ë¦¬í”Œë ˆì´ ë²„íŠ¼ ê·¸ë¦¬ê¸° - ëŒ€í™” ìƒì ë‚´ë¶€ ìš°ì¸¡ í•˜ë‹¨"""
        font = self.fonts.get("small")
        if not font:
            return

        # ë²„íŠ¼ ì•ŒíŒŒ í˜ì´ë“œ ì¸
        self.replay_button_alpha = min(1.0, self.replay_button_alpha + 0.05)

        # ë²„íŠ¼ í¬ê¸° ë° ìœ„ì¹˜ (ëŒ€í™” ìƒì ë‚´ë¶€ ìš°ì¸¡ í•˜ë‹¨)
        button_text = "REPLAY"
        button_padding_x = 16
        button_padding_y = 8
        text_surf = font.render(button_text, True, (255, 255, 255))
        button_width = text_surf.get_width() + button_padding_x * 2
        button_height = text_surf.get_height() + button_padding_y * 2

        button_x = dialogue_box_rect.right - button_width - 15
        button_y = dialogue_box_rect.bottom - button_height - 10

        self.replay_button_rect = pygame.Rect(button_x, button_y, button_width, button_height)

        # í˜¸ë²„ ì²´í¬
        mouse_pos = pygame.mouse.get_pos()
        self.replay_button_hover = self.replay_button_rect.collidepoint(mouse_pos)

        # ë²„íŠ¼ ìƒ‰ìƒ (í˜¸ë²„ ì‹œ ë” ë°ê²Œ)
        if self.replay_button_hover:
            bg_color = (80, 120, 180, int(220 * self.replay_button_alpha))
            border_color = (150, 200, 255, int(255 * self.replay_button_alpha))
            text_color = (255, 255, 255)
        else:
            bg_color = (50, 70, 100, int(180 * self.replay_button_alpha))
            border_color = (100, 150, 200, int(200 * self.replay_button_alpha))
            text_color = (200, 220, 255)

        # ë²„íŠ¼ ë°°ê²½
        button_surf = pygame.Surface((button_width, button_height), pygame.SRCALPHA)
        pygame.draw.rect(button_surf, bg_color, (0, 0, button_width, button_height), border_radius=6)
        pygame.draw.rect(button_surf, border_color, (0, 0, button_width, button_height), 2, border_radius=6)

        # ì•„ì´ì½˜ (ì¬ìƒ ì‚¼ê°í˜•) + í…ìŠ¤íŠ¸
        icon_size = 10
        icon_x = button_padding_x - 2
        icon_y = button_height // 2

        # ì¬ìƒ ì•„ì´ì½˜ (ì‚¼ê°í˜•)
        icon_points = [
            (icon_x, icon_y - icon_size // 2),
            (icon_x, icon_y + icon_size // 2),
            (icon_x + icon_size, icon_y)
        ]
        pygame.draw.polygon(button_surf, text_color, icon_points)

        # í…ìŠ¤íŠ¸
        text_surf = font.render(button_text, True, text_color)
        text_x = icon_x + icon_size + 6
        text_y = (button_height - text_surf.get_height()) // 2
        button_surf.blit(text_surf, (text_x, text_y))

        screen.blit(button_surf, (button_x, button_y))

    def _draw_photo_dialogue(self, screen: pygame.Surface):
        """í´ë¼ë¡œì´ë“œë³„ ëŒ€í™” ê·¸ë¦¬ê¸° (PHASE_PHOTOS ì¤‘ ìë™ í‘œì‹œ)"""
        font = self.fonts.get("medium") or self.fonts.get("small")
        small_font = self.fonts.get("small") or font
        if not font:
            return

        # í˜„ì¬ í´ë¼ë¡œì´ë“œ ì¸ë±ìŠ¤ì— í•´ë‹¹í•˜ëŠ” ëŒ€í™” ê°€ì ¸ì˜¤ê¸°
        photo_index = self.visible_count - 1
        if photo_index < 0 or photo_index >= len(self.dialogue_per_photo):
            return

        current_dialogue = self.dialogue_per_photo[photo_index]
        speaker = current_dialogue.get("speaker", "")

        # config_story_dialogueì—ì„œ ìƒ‰ìƒ/ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
        try:
            from mode_configs.config_story_dialogue import CHARACTER_COLORS, CHARACTER_NAMES
            text_color = CHARACTER_COLORS.get(speaker, (255, 255, 255))
            speaker_name = CHARACTER_NAMES.get(speaker, speaker)
        except ImportError:
            text_color = (255, 220, 150)
            speaker_name = speaker

        # ì´ˆìƒí™” ê°€ì ¸ì˜¤ê¸°
        portrait = self._get_portrait(speaker)
        portrait_width = 150 if portrait else 0

        # ëŒ€ì‚¬ ë°•ìŠ¤ (í•˜ë‹¨, ê°€ë¡œ 1/2 í¬ê¸°, ì¤‘ì•™ ì •ë ¬)
        box_height = 120
        box_width = (self.screen_size[0] - 160) // 2
        box_x = (self.screen_size[0] - box_width) // 2
        box_rect = pygame.Rect(
            box_x,
            self.screen_size[1] - box_height - 40,
            box_width,
            box_height
        )

        # ë°•ìŠ¤ ë°°ê²½
        box_surf = pygame.Surface((box_rect.width, box_rect.height), pygame.SRCALPHA)
        pygame.draw.rect(box_surf, (0, 0, 0, 200), (0, 0, box_rect.width, box_rect.height), border_radius=12)
        pygame.draw.rect(box_surf, text_color + (100,), (0, 0, box_rect.width, box_rect.height), 2, border_radius=12)
        screen.blit(box_surf, box_rect.topleft)

        # ì´ˆìƒí™” ê·¸ë¦¬ê¸°
        text_left_x = box_rect.left + 25
        if portrait:
            portrait_x = box_rect.left + 15
            portrait_y = box_rect.top + (box_height - portrait_width) // 2
            # ì´ˆìƒí™” ë°°ê²½ (ì›í˜•)
            pygame.draw.circle(screen, (30, 30, 40),
                             (portrait_x + portrait_width // 2, portrait_y + portrait_width // 2),
                             portrait_width // 2 + 5)
            pygame.draw.circle(screen, text_color,
                             (portrait_x + portrait_width // 2, portrait_y + portrait_width // 2),
                             portrait_width // 2 + 5, 2)
            screen.blit(portrait, (portrait_x, portrait_y))
            text_left_x = portrait_x + portrait_width + 20

        # í™”ì ì´ë¦„
        if speaker_name:
            name_surf = font.render(speaker_name, True, text_color)
            screen.blit(name_surf, (text_left_x, box_rect.top + 12))

        # ëŒ€ì‚¬ í…ìŠ¤íŠ¸ (ìë™ ì¤„ë°”ê¿ˆ)
        text_y = box_rect.top + 45
        max_width = box_rect.width - (text_left_x - box_rect.left) - 30

        # ì¤„ë°”ê¿ˆ ì²˜ë¦¬
        words = self.dialogue_text.split(' ')
        lines = []
        current_line = ""
        for word in words:
            test_line = current_line + (" " if current_line else "") + word
            test_surf = small_font.render(test_line, True, (255, 255, 255))
            if test_surf.get_width() <= max_width:
                current_line = test_line
            else:
                if current_line:
                    lines.append(current_line)
                current_line = word
        if current_line:
            lines.append(current_line)

        # í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
        for i, line in enumerate(lines):
            text_surf = small_font.render(line, True, (255, 255, 255))
            screen.blit(text_surf, (text_left_x, text_y + i * 26))

    def _draw_click_hint(self, screen: pygame.Surface):
        """í´ë¦­ íŒíŠ¸ ê·¸ë¦¬ê¸°"""
        font = self.fonts.get("small")
        if not font:
            return

        alpha = int(128 + 127 * math.sin(pygame.time.get_ticks() / 300))
        hint_surf = font.render("Click to continue...", True, (200, 200, 200))
        hint_surf.set_alpha(alpha)
        hint_rect = hint_surf.get_rect(midbottom=(self.screen_size[0] // 2, self.screen_size[1] - 20))
        screen.blit(hint_surf, hint_rect)


# =========================================================
# ë¹„í–‰ì„  ì§„ì… & ì„ íšŒ ì• ë‹ˆë©”ì´ì…˜ (1ë§‰ ì˜¤í”„ë‹)
# =========================================================
class ShipEntranceEffect:
    """
    ë¹„í–‰ì„  ì§„ì… íš¨ê³¼ - í™”ë©´ ìƒë‹¨ì—ì„œ ì§„ì… í›„ íí—ˆ ì£¼ë³€ ì„ íšŒ

    ì—°ì¶œ:
    1. ë¹„í–‰ì„ ì´ í™”ë©´ ìƒë‹¨ ë°–ì—ì„œ ì§„ì…
    2. í™”ë©´ ì¤‘ì•™ì˜ íí—ˆ ê±´ë¬¼ ì£¼ë³€ì„ ì²œì²œíˆ íƒ€ì›í˜•ìœ¼ë¡œ ì„ íšŒ
    3. ì„ íšŒ ì¤‘ ëŒ€í™” ì§„í–‰
    4. ëŒ€í™” ì™„ë£Œ í›„ ë¹„í–‰ì„ ì´ ì „íˆ¬ ìœ„ì¹˜(í™”ë©´ í•˜ë‹¨)ë¡œ ì´ë™
    """

    PHASE_ENTRANCE = 0      # í™”ë©´ ì§„ì…
    PHASE_CIRCLING = 1      # íí—ˆ ì£¼ë³€ ì„ íšŒ + ëŒ€í™”
    PHASE_POSITIONING = 2   # ì „íˆ¬ ìœ„ì¹˜ë¡œ ì´ë™
    PHASE_DONE = 3          # ì™„ë£Œ

    def __init__(self, screen_size: tuple, player, dialogue_data: list,
                 background_path: str = None, title: str = "", location: str = ""):
        """
        Args:
            screen_size: í™”ë©´ í¬ê¸° (width, height)
            player: Player ê°ì²´ (ìœ„ì¹˜ ì œì–´ìš©)
            dialogue_data: ëŒ€ì‚¬ ë¦¬ìŠ¤íŠ¸ [{"speaker": "...", "text": "..."}, ...]
            background_path: ë°°ê²½ ì´ë¯¸ì§€ ê²½ë¡œ
            title: íƒ€ì´í‹€ í…ìŠ¤íŠ¸
            location: ìœ„ì¹˜ í…ìŠ¤íŠ¸
        """
        self.screen_size = screen_size
        self.player = player
        self.dialogue_data = dialogue_data
        self.title = title
        self.location = location

        self.is_alive = True
        self.phase = self.PHASE_ENTRANCE
        self.phase_timer = 0.0

        # ì§„ì… ì• ë‹ˆë©”ì´ì…˜
        self.entrance_duration = 2.5  # ì§„ì… ì‹œê°„ (ì´ˆ)
        self.start_pos = (screen_size[0] // 2, -100)  # í™”ë©´ ìƒë‹¨ ë°–
        self.entrance_end_pos = (screen_size[0] // 2, screen_size[1] // 3)  # ì„ íšŒ ì‹œì‘ ìœ„ì¹˜

        # ì„ íšŒ ì• ë‹ˆë©”ì´ì…˜
        self.orbit_center = (screen_size[0] // 2, screen_size[1] // 2 - 50)  # íí—ˆ ì¤‘ì‹¬
        self.orbit_radius_x = screen_size[0] // 4  # íƒ€ì› ê°€ë¡œ ë°˜ê²½
        self.orbit_radius_y = screen_size[1] // 6  # íƒ€ì› ì„¸ë¡œ ë°˜ê²½
        self.orbit_speed = 0.3  # ì„ íšŒ ì†ë„ (ë¼ë””ì•ˆ/ì´ˆ)
        self.orbit_angle = -math.pi / 2  # ì‹œì‘ ê°ë„ (ìƒë‹¨ì—ì„œ ì‹œì‘)

        # ì „íˆ¬ ìœ„ì¹˜
        self.battle_pos = (screen_size[0] // 2, int(screen_size[1] * 0.7))
        self.positioning_duration = 1.5

        # ëŒ€ì‚¬ ê´€ë ¨
        self.current_dialogue_index = 0
        self.typing_progress = 0.0
        self.typing_speed = 25.0  # ì´ˆë‹¹ ê¸€ì ìˆ˜
        self.current_text = ""
        self.full_text = ""
        self.waiting_for_click = False
        self.dialogue_started = False  # ì„ íšŒ ì‹œì‘ í›„ ëŒ€í™” ì‹œì‘
        self.dialogue_start_delay = 1.0  # ì„ íšŒ ì‹œì‘ í›„ ëŒ€í™” ì‹œì‘ê¹Œì§€ ë”œë ˆì´
        self.dialogue_timer = 0.0

        # ë°°ê²½ ë¡œë“œ
        self.background = None
        if background_path:
            self._load_background(background_path)

        # ì´ˆìƒí™” ìºì‹œ
        self.portrait_cache = {}

        # ìºë¦­í„° ìƒ‰ìƒ
        self.character_colors = {
            "ARTEMIS": (255, 220, 150),
            "PILOT": (150, 200, 255),
            "BOSS": (255, 100, 100),
            "NARRATOR": (200, 200, 200),
            "SYSTEM": (100, 255, 200),
        }

        # í°íŠ¸
        self.fonts = {}

        # ì½œë°±
        self.on_complete = None

        # í”Œë ˆì´ì–´ ì›ë˜ ì´ë¯¸ì§€/ìœ„ì¹˜ ì €ì¥
        if player:
            self.original_player_pos = player.pos.copy()
            player.pos = pygame.math.Vector2(self.start_pos)

        # ì²« ëŒ€ì‚¬ ì¤€ë¹„
        if self.dialogue_data:
            self._prepare_dialogue(0)

        print("INFO: ShipEntranceEffect initialized")

    def _load_background(self, path: str):
        """ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ"""
        try:
            img = pygame.image.load(path).convert()
            self.background = pygame.transform.scale(img, self.screen_size)
        except Exception as e:
            print(f"WARNING: Failed to load background: {path} - {e}")

    def _prepare_dialogue(self, index: int):
        """ëŒ€ì‚¬ ì¤€ë¹„"""
        if 0 <= index < len(self.dialogue_data):
            dialogue = self.dialogue_data[index]
            self.full_text = dialogue.get("text", "")
            self.current_text = ""
            self.typing_progress = 0.0
            self.waiting_for_click = False

    def _get_portrait(self, speaker: str) -> pygame.Surface:
        """ì´ˆìƒí™” ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸°"""
        if speaker in self.portrait_cache:
            return self.portrait_cache[speaker]

        try:
            from mode_configs.config_story_dialogue import CHARACTER_PORTRAITS
            path = CHARACTER_PORTRAITS.get(speaker)
        except ImportError:
            portrait_paths = {
                "ARTEMIS": "assets/story_mode/portraits/portrait_artemis.jpg",
                "PILOT": "assets/story_mode/portraits/portrait_pilot.png",
            }
            path = portrait_paths.get(speaker)

        if path:
            try:
                img = pygame.image.load(path).convert_alpha()
                target_size = (180, 180)
                img = pygame.transform.smoothscale(img, target_size)
                self.portrait_cache[speaker] = img
                return img
            except Exception as e:
                print(f"WARNING: Failed to load portrait for {speaker}: {e}")

        return None

    def set_fonts(self, fonts: dict):
        """í°íŠ¸ ì„¤ì •"""
        self.fonts = fonts

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        if self.phase == self.PHASE_ENTRANCE:
            # í™”ë©´ ì§„ì… ì• ë‹ˆë©”ì´ì…˜
            progress = min(self.phase_timer / self.entrance_duration, 1.0)

            # ì´ì§• (ease-out-cubic)
            eased = 1 - pow(1 - progress, 3)

            # í”Œë ˆì´ì–´ ìœ„ì¹˜ ë³´ê°„
            if self.player:
                new_x = self.start_pos[0] + (self.entrance_end_pos[0] - self.start_pos[0]) * eased
                new_y = self.start_pos[1] + (self.entrance_end_pos[1] - self.start_pos[1]) * eased
                self.player.pos = pygame.math.Vector2(new_x, new_y)

            if progress >= 1.0:
                self.phase = self.PHASE_CIRCLING
                self.phase_timer = 0.0
                self.dialogue_timer = 0.0
                print("INFO: Ship entrance complete, starting circling")

        elif self.phase == self.PHASE_CIRCLING:
            # ì„ íšŒ ì• ë‹ˆë©”ì´ì…˜
            self.orbit_angle += self.orbit_speed * dt

            # íƒ€ì› ê¶¤ë„ ê³„ì‚°
            orbit_x = self.orbit_center[0] + math.cos(self.orbit_angle) * self.orbit_radius_x
            orbit_y = self.orbit_center[1] + math.sin(self.orbit_angle) * self.orbit_radius_y

            if self.player:
                self.player.pos = pygame.math.Vector2(orbit_x, orbit_y)

            # ëŒ€í™” ì‹œì‘ ë”œë ˆì´
            self.dialogue_timer += dt
            if not self.dialogue_started and self.dialogue_timer >= self.dialogue_start_delay:
                self.dialogue_started = True

            # ëŒ€í™” ì§„í–‰
            if self.dialogue_started and self.dialogue_data:
                self._update_dialogue(dt)

        elif self.phase == self.PHASE_POSITIONING:
            # ì „íˆ¬ ìœ„ì¹˜ë¡œ ì´ë™
            progress = min(self.phase_timer / self.positioning_duration, 1.0)

            # ì´ì§• (ease-in-out-cubic)
            if progress < 0.5:
                eased = 4 * progress * progress * progress
            else:
                eased = 1 - pow(-2 * progress + 2, 3) / 2

            if self.player:
                # í˜„ì¬ ì„ íšŒ ìœ„ì¹˜ì—ì„œ ì „íˆ¬ ìœ„ì¹˜ë¡œ
                start_x = self.orbit_center[0] + math.cos(self.orbit_angle) * self.orbit_radius_x
                start_y = self.orbit_center[1] + math.sin(self.orbit_angle) * self.orbit_radius_y

                new_x = start_x + (self.battle_pos[0] - start_x) * eased
                new_y = start_y + (self.battle_pos[1] - start_y) * eased
                self.player.pos = pygame.math.Vector2(new_x, new_y)

            if progress >= 1.0:
                self.phase = self.PHASE_DONE
                self.is_alive = False
                if self.on_complete:
                    self.on_complete()
                print("INFO: ShipEntranceEffect complete")

    def _update_dialogue(self, dt: float):
        """ëŒ€í™” ì—…ë°ì´íŠ¸"""
        if self.current_dialogue_index >= len(self.dialogue_data):
            # ëª¨ë“  ëŒ€í™” ì™„ë£Œ â†’ ì „íˆ¬ ìœ„ì¹˜ë¡œ ì´ë™
            self.phase = self.PHASE_POSITIONING
            self.phase_timer = 0.0
            return

        if not self.waiting_for_click:
            self.typing_progress += self.typing_speed * dt
            char_count = int(self.typing_progress)

            if char_count >= len(self.full_text):
                self.current_text = self.full_text
                self.waiting_for_click = True
            else:
                self.current_text = self.full_text[:char_count]

    def handle_click(self):
        """í´ë¦­ ì²˜ë¦¬"""
        if self.phase == self.PHASE_ENTRANCE:
            # ì§„ì… ìŠ¤í‚µ
            self.phase = self.PHASE_CIRCLING
            self.phase_timer = 0.0
            self.dialogue_timer = 0.0
            if self.player:
                self.player.pos = pygame.math.Vector2(self.entrance_end_pos)
            return

        if self.phase == self.PHASE_CIRCLING and self.dialogue_started:
            if not self.waiting_for_click:
                # íƒ€ì´í•‘ ìŠ¤í‚µ
                self.current_text = self.full_text
                self.waiting_for_click = True
            else:
                # ë‹¤ìŒ ëŒ€ì‚¬
                self.current_dialogue_index += 1
                if self.current_dialogue_index >= len(self.dialogue_data):
                    # ëŒ€í™” ì™„ë£Œ
                    self.phase = self.PHASE_POSITIONING
                    self.phase_timer = 0.0
                else:
                    self._prepare_dialogue(self.current_dialogue_index)

    def skip(self):
        """ì „ì²´ ìŠ¤í‚µ"""
        self.phase = self.PHASE_POSITIONING
        self.phase_timer = 0.0
        if self.player:
            self.player.pos = pygame.math.Vector2(self.battle_pos)

    def draw(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        if not self.is_alive and self.phase == self.PHASE_DONE:
            return

        # ë°°ê²½
        if self.background:
            screen.blit(self.background, (0, 0))
        else:
            screen.fill((20, 20, 30))

        # ë°˜íˆ¬ëª… ì˜¤ë²„ë ˆì´ (ë¶„ìœ„ê¸°)
        overlay = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 100))
        screen.blit(overlay, (0, 0))

        # í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
        if self.player:
            # í”Œë ˆì´ì–´ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
            player_rect = self.player.image.get_rect(center=(int(self.player.pos.x), int(self.player.pos.y)))
            screen.blit(self.player.image, player_rect)

        # íƒ€ì´í‹€/ìœ„ì¹˜ (ì§„ì… ì¤‘ì—ë§Œ)
        if self.phase == self.PHASE_ENTRANCE:
            self._draw_title(screen)

        # ëŒ€í™” ë°•ìŠ¤ (ì„ íšŒ ì¤‘ ëŒ€í™” ì‹œì‘ í›„)
        if self.phase == self.PHASE_CIRCLING and self.dialogue_started and self.dialogue_data:
            if self.current_dialogue_index < len(self.dialogue_data):
                self._draw_dialogue_box(screen)

        # í´ë¦­ íŒíŠ¸
        if self.waiting_for_click:
            self._draw_click_hint(screen)

    def _draw_title(self, screen: pygame.Surface):
        """íƒ€ì´í‹€ ê·¸ë¦¬ê¸°"""
        if not self.title:
            return

        font = self.fonts.get("large") or self.fonts.get("medium")
        if not font:
            return

        # í˜ì´ë“œ ì¸ íš¨ê³¼
        alpha = min(int(255 * self.phase_timer / 1.0), 255)

        title_surf = font.render(self.title, True, (255, 200, 100))
        title_surf.set_alpha(alpha)
        title_rect = title_surf.get_rect(center=(self.screen_size[0] // 2, self.screen_size[1] // 6))
        screen.blit(title_surf, title_rect)

        if self.location:
            loc_font = self.fonts.get("medium") or self.fonts.get("small")
            if loc_font:
                loc_surf = loc_font.render(self.location, True, (200, 200, 200))
                loc_surf.set_alpha(alpha)
                loc_rect = loc_surf.get_rect(center=(self.screen_size[0] // 2, self.screen_size[1] // 6 + 40))
                screen.blit(loc_surf, loc_rect)

    def _draw_dialogue_box(self, screen: pygame.Surface):
        """ëŒ€í™” ë°•ìŠ¤ ê·¸ë¦¬ê¸°"""
        if not self.dialogue_data or self.current_dialogue_index >= len(self.dialogue_data):
            return

        dialogue = self.dialogue_data[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")

        # í°íŠ¸
        font = self.fonts.get("medium") or self.fonts.get("small")
        if not font:
            return

        # ì´ˆìƒí™”
        portrait = self._get_portrait(speaker)
        portrait_width = 180 if portrait else 0

        # ëŒ€í™” ë°•ìŠ¤ ì˜ì—­ (ê°€ë¡œ 1/2 í¬ê¸°, ì¤‘ì•™ ì •ë ¬)
        box_margin = 50
        box_height = 140
        box_width = (self.screen_size[0] - box_margin * 2) // 2
        box_x = (self.screen_size[0] - box_width) // 2
        box_y = self.screen_size[1] - box_height - box_margin

        # ë°•ìŠ¤ ë°°ê²½
        box_surf = pygame.Surface((box_width, box_height), pygame.SRCALPHA)
        pygame.draw.rect(box_surf, (0, 0, 0, 200), (0, 0, box_width, box_height), border_radius=15)
        pygame.draw.rect(box_surf, (100, 100, 120), (0, 0, box_width, box_height), width=2, border_radius=15)
        screen.blit(box_surf, (box_x, box_y))

        # ì´ˆìƒí™” (ì¢Œì¸¡)
        if portrait:
            portrait_y = box_y + (box_height - portrait.get_height()) // 2
            screen.blit(portrait, (box_x + 10, portrait_y))

        # í™”ì ì´ë¦„
        try:
            from mode_configs.config_story_dialogue import CHARACTER_NAMES
            speaker_name = CHARACTER_NAMES.get(speaker, speaker)
        except ImportError:
            speaker_name = speaker

        name_color = self.character_colors.get(speaker, (255, 255, 255))

        if speaker_name:
            name_surf = font.render(speaker_name, True, name_color)
            name_x = box_x + portrait_width + 30
            name_y = box_y + 15
            screen.blit(name_surf, (name_x, name_y))

        # ëŒ€ì‚¬ í…ìŠ¤íŠ¸
        text_x = box_x + portrait_width + 30
        text_y = box_y + 50
        text_width = box_width - portrait_width - 60

        # ì¤„ë°”ê¿ˆ ì²˜ë¦¬
        words = self.current_text.split(' ')
        lines = []
        current_line = ""

        for word in words:
            test_line = current_line + word + " "
            if font.size(test_line)[0] <= text_width:
                current_line = test_line
            else:
                if current_line:
                    lines.append(current_line)
                current_line = word + " "
        if current_line:
            lines.append(current_line)

        # í…ìŠ¤íŠ¸ ë Œë”ë§
        for i, line in enumerate(lines[:3]):  # ìµœëŒ€ 3ì¤„
            text_surf = font.render(line.strip(), True, (255, 255, 255))
            screen.blit(text_surf, (text_x, text_y + i * 28))

    def _draw_click_hint(self, screen: pygame.Surface):
        """í´ë¦­ íŒíŠ¸"""
        font = self.fonts.get("small")
        if not font:
            return

        alpha = int(128 + 127 * math.sin(pygame.time.get_ticks() / 300))
        hint_surf = font.render("Click to continue...", True, (200, 200, 200))
        hint_surf.set_alpha(alpha)
        hint_rect = hint_surf.get_rect(midbottom=(self.screen_size[0] // 2, self.screen_size[1] - 20))
        screen.blit(hint_surf, hint_rect)


# =========================================================
# ì‹œê°ì  í”¼ë“œë°± íš¨ê³¼ í´ë˜ìŠ¤ë“¤
# =========================================================

class DamageFlash:
    """
    í”Œë ˆì´ì–´ê°€ í”¼ê²©ë‹¹í–ˆì„ ë•Œ í™”ë©´ì— ë¹¨ê°„ìƒ‰ í”Œë˜ì‹œ íš¨ê³¼ë¥¼ í‘œì‹œí•˜ëŠ” í´ë˜ìŠ¤.
    ë°ë¯¸ì§€ ë¹„ìœ¨ì— ë”°ë¼ í”Œë˜ì‹œ ê°•ë„ê°€ ì¡°ì ˆë©ë‹ˆë‹¤.
    """
    def __init__(self, screen_size: Tuple[int, int]):
        self.screen_size = screen_size
        self.is_active = False
        self.start_time = 0.0
        self.duration = 0.0
        self.max_alpha = 0
        self.flash_surface = pygame.Surface(screen_size, pygame.SRCALPHA)

    def trigger(self, damage_ratio: float):
        """
        ë°ë¯¸ì§€ í”Œë˜ì‹œë¥¼ íŠ¸ë¦¬ê±°í•©ë‹ˆë‹¤.

        Args:
            damage_ratio: ë°›ì€ ë°ë¯¸ì§€ / ìµœëŒ€ HP ë¹„ìœ¨ (0.0 ~ 1.0)
        """
        self.is_active = True
        self.start_time = pygame.time.get_ticks() / 1000.0

        # ë°ë¯¸ì§€ ë¹„ìœ¨ì— ë”°ë¼ í”Œë˜ì‹œ ê°•ë„ì™€ ì§€ì†ì‹œê°„ ì¡°ì ˆ
        self.max_alpha = int(min(180, 60 + damage_ratio * 200))  # 60 ~ 180
        self.duration = 0.15 + damage_ratio * 0.15  # 0.15 ~ 0.3ì´ˆ

    def update(self) -> bool:
        """
        í”Œë˜ì‹œ íš¨ê³¼ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

        Returns:
            bool: í”Œë˜ì‹œê°€ ì•„ì§ í™œì„± ìƒíƒœì¸ì§€ ì—¬ë¶€
        """
        if not self.is_active:
            return False

        current_time = pygame.time.get_ticks() / 1000.0
        elapsed = current_time - self.start_time

        if elapsed >= self.duration:
            self.is_active = False
            return False

        return True

    def render(self, screen: pygame.Surface):
        """í”Œë˜ì‹œ íš¨ê³¼ë¥¼ í™”ë©´ì— ë Œë”ë§í•©ë‹ˆë‹¤."""
        if not self.is_active:
            return

        current_time = pygame.time.get_ticks() / 1000.0
        elapsed = current_time - self.start_time
        progress = elapsed / self.duration

        # ë¹ ë¥´ê²Œ ë‚˜íƒ€ë‚¬ë‹¤ê°€ ì²œì²œíˆ ì‚¬ë¼ì§€ëŠ” ì´ì§•
        if progress < 0.2:
            # ë¹ ë¥´ê²Œ ë‚˜íƒ€ë‚¨ (0 ~ 0.2)
            alpha_progress = progress / 0.2
        else:
            # ì²œì²œíˆ ì‚¬ë¼ì§ (0.2 ~ 1.0)
            alpha_progress = 1.0 - ((progress - 0.2) / 0.8)

        # alpha ê°’ì„ 0-255 ë²”ìœ„ë¡œ í´ë¨í•‘
        alpha = max(0, min(255, int(self.max_alpha * alpha_progress)))

        self.flash_surface.fill((255, 0, 0, alpha))
        screen.blit(self.flash_surface, (0, 0))


class LevelUpEffect:
    """
    ë ˆë²¨ì—… ì‹œ í™”ë©´ì— í‘œì‹œë˜ëŠ” ì‹œê° íš¨ê³¼ í´ë˜ìŠ¤.
    ê³¨ë“œ ìƒ‰ìƒ ê¸€ë¡œìš°, ìƒìŠ¹ íŒŒí‹°í´, ë ˆë²¨ í…ìŠ¤íŠ¸ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.
    """
    def __init__(self, screen_size: Tuple[int, int]):
        self.screen_size = screen_size
        self.is_active = False
        self.start_time = 0.0
        self.duration = 1.5  # 1.5ì´ˆ ì§€ì†
        self.level = 0
        self.particles: List[Dict] = []
        self.glow_surface = pygame.Surface(screen_size, pygame.SRCALPHA)
        self.font = None
        self._init_font()

    def _init_font(self):
        """í°íŠ¸ ì´ˆê¸°í™”"""
        try:
            self.font = pygame.font.Font(None, 72)
        except:
            self.font = pygame.font.SysFont("Arial", 72)

    def trigger(self, level: int):
        """
        ë ˆë²¨ì—… íš¨ê³¼ë¥¼ íŠ¸ë¦¬ê±°í•©ë‹ˆë‹¤.

        Args:
            level: ìƒˆë¡œìš´ ë ˆë²¨
        """
        self.is_active = True
        self.start_time = pygame.time.get_ticks() / 1000.0
        self.level = level
        self._create_particles()

    def _create_particles(self):
        """ìƒìŠ¹ íŒŒí‹°í´ ìƒì„± (30ê°œ)"""
        self.particles = []
        for _ in range(30):
            particle = {
                'x': random.randint(0, self.screen_size[0]),
                'y': self.screen_size[1] + random.randint(0, 50),
                'speed': random.uniform(100, 250),
                'size': random.randint(3, 8),
                'alpha': random.randint(150, 255),
                'color': random.choice([
                    (255, 215, 0),   # ê³¨ë“œ
                    (255, 200, 50),  # ë°ì€ ê³¨ë“œ
                    (255, 180, 0),   # ì˜¤ë Œì§€ ê³¨ë“œ
                    (255, 255, 150), # ë°ì€ ë…¸ë‘
                ])
            }
            self.particles.append(particle)

    def update(self, dt: float) -> bool:
        """
        ë ˆë²¨ì—… íš¨ê³¼ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

        Args:
            dt: ë¸íƒ€ íƒ€ì„

        Returns:
            bool: íš¨ê³¼ê°€ ì•„ì§ í™œì„± ìƒíƒœì¸ì§€ ì—¬ë¶€
        """
        if not self.is_active:
            return False

        current_time = pygame.time.get_ticks() / 1000.0
        elapsed = current_time - self.start_time

        if elapsed >= self.duration:
            self.is_active = False
            return False

        # íŒŒí‹°í´ ì—…ë°ì´íŠ¸ (ìœ„ë¡œ ìƒìŠ¹)
        for particle in self.particles:
            particle['y'] -= particle['speed'] * dt
            # í˜ì´ë“œ ì•„ì›ƒ
            particle['alpha'] = max(0, particle['alpha'] - 80 * dt)

        return True

    def render(self, screen: pygame.Surface):
        """ë ˆë²¨ì—… íš¨ê³¼ë¥¼ í™”ë©´ì— ë Œë”ë§í•©ë‹ˆë‹¤."""
        if not self.is_active:
            return

        current_time = pygame.time.get_ticks() / 1000.0
        elapsed = current_time - self.start_time
        progress = elapsed / self.duration

        # 1. ê³¨ë“œ í™”ë©´ ê¸€ë¡œìš° (ì²˜ìŒì— ê°•í•˜ê³  ì ì  ì‚¬ë¼ì§)
        # alpha ê°’ì„ 0-255 ë²”ìœ„ë¡œ í´ë¨í•‘
        glow_alpha = max(0, min(255, int(40 * (1.0 - progress))))
        self.glow_surface.fill((255, 215, 0, glow_alpha))
        screen.blit(self.glow_surface, (0, 0))

        # 2. íŒŒí‹°í´ ë Œë”ë§
        for particle in self.particles:
            if particle['alpha'] > 0 and 0 <= particle['y'] <= self.screen_size[1]:
                alpha = int(particle['alpha'])
                color = (*particle['color'][:3], alpha)
                pygame.draw.circle(
                    screen,
                    color,
                    (int(particle['x']), int(particle['y'])),
                    particle['size']
                )

        # 3. "LEVEL X!" í…ìŠ¤íŠ¸ (ì¤‘ì•™ ìƒë‹¨, í˜ì´ë“œ ì¸/ì•„ì›ƒ)
        if self.font and progress < 0.8:
            text_alpha = 255
            if progress < 0.1:
                text_alpha = int(255 * (progress / 0.1))
            elif progress > 0.6:
                text_alpha = int(255 * (1.0 - (progress - 0.6) / 0.2))

            text = f"LEVEL {self.level}!"
            text_surf = self.font.render(text, True, (255, 215, 0))
            text_surf.set_alpha(text_alpha)

            # í…ìŠ¤íŠ¸ ìœ„ì¹˜ (í™”ë©´ ìƒë‹¨ ì¤‘ì•™, ì•½ê°„ ì•„ë˜ë¡œ ì´ë™í•˜ëŠ” ì• ë‹ˆë©”ì´ì…˜)
            text_y = int(80 + 30 * progress)
            text_rect = text_surf.get_rect(center=(self.screen_size[0] // 2, text_y))
            screen.blit(text_surf, text_rect)


# =============================================================================
# 2ë§‰ ë²™ì»¤ í¬ì‹  ì—°ì¶œ íš¨ê³¼
# =============================================================================

class SmokeParticle:
    """í¬ì‹  ë°œì‚¬ í›„ ì—°ê¸° íŒŒí‹°í´"""

    def __init__(self, pos: Tuple[float, float]):
        self.pos = pygame.math.Vector2(pos)
        self.velocity = pygame.math.Vector2(
            random.uniform(-30, 30),
            random.uniform(-60, -30)
        )
        self.size = random.uniform(20, 40)
        self.lifetime = random.uniform(1.5, 2.5)
        self.age = 0.0
        self.is_alive = True

    def update(self, dt: float):
        self.age += dt
        if self.age >= self.lifetime:
            self.is_alive = False
            return

        self.pos += self.velocity * dt
        self.velocity *= 0.97  # ê°ì†
        self.size += 20 * dt   # í™•ì‚°

    def draw(self, screen: pygame.Surface):
        if not self.is_alive:
            return

        progress = self.age / self.lifetime
        alpha = int(60 * (1 - progress))

        surf = pygame.Surface((int(self.size * 2), int(self.size * 2)), pygame.SRCALPHA)
        pygame.draw.circle(surf, (120, 110, 100, alpha),
                          (int(self.size), int(self.size)), int(self.size))
        screen.blit(surf, (int(self.pos.x - self.size), int(self.pos.y - self.size)))


class CannonShell:
    """í¬ì‹ ì—ì„œ ë°œì‚¬ë˜ëŠ” í¬íƒ„"""

    def __init__(self, start_pos: Tuple[float, float], target_pos: Tuple[float, float],
                 screen_size: Tuple[int, int]):
        self.pos = pygame.math.Vector2(start_pos)
        self.start_pos = pygame.math.Vector2(start_pos)
        self.target_pos = pygame.math.Vector2(target_pos)
        self.screen_size = screen_size

        # í¬íƒ„ ì†ì„±
        self.speed = 800  # í”½ì…€/ì´ˆ
        self.damage = 500  # ë†’ì€ ë°ë¯¸ì§€
        self.explosion_radius = 120  # ë„“ì€ í­ë°œ ë²”ìœ„

        # ë°©í–¥ ê³„ì‚°
        direction = self.target_pos - self.start_pos
        if direction.length() > 0:
            self.velocity = direction.normalize() * self.speed
        else:
            self.velocity = pygame.math.Vector2(0, -self.speed)

        # ê¶¤ì  ì €ì¥ (íŠ¸ë ˆì¼ íš¨ê³¼)
        self.trail: List[pygame.math.Vector2] = []
        self.trail_max_length = 12

        # ìƒíƒœ
        self.is_alive = True
        self.exploded = False

        # ì‹œê° íš¨ê³¼
        self.size = 8
        self.glow_size = 16

    def update(self, dt: float) -> bool:
        """ì—…ë°ì´íŠ¸. í­ë°œ ì‹œ True ë°˜í™˜"""
        if not self.is_alive:
            return False

        # ê¶¤ì  ì €ì¥
        self.trail.append(pygame.math.Vector2(self.pos))
        if len(self.trail) > self.trail_max_length:
            self.trail.pop(0)

        # ì´ë™
        self.pos += self.velocity * dt

        # í™”ë©´ ë°– ì²´í¬ (ì•½ê°„ì˜ ì—¬ìœ )
        margin = 50
        if (self.pos.x < -margin or self.pos.x > self.screen_size[0] + margin or
            self.pos.y < -margin or self.pos.y > self.screen_size[1] + margin):
            self.is_alive = False
            return False

        # ëª©í‘œ ì§€ì  ê·¼ì²˜ ë„ë‹¬ ì‹œ í­ë°œ
        dist_to_target = (self.pos - self.target_pos).length()
        if dist_to_target < 30:
            self.explode()
            return True

        return False

    def explode(self):
        """í¬íƒ„ í­ë°œ"""
        self.exploded = True
        self.is_alive = False

    def draw(self, screen: pygame.Surface):
        """í¬íƒ„ ë° íŠ¸ë ˆì¼ ë Œë”ë§"""
        if not self.is_alive and not self.exploded:
            return

        # íŠ¸ë ˆì¼ ê·¸ë¦¬ê¸° (ê·¸ë¼ë°ì´ì…˜)
        for i, trail_pos in enumerate(self.trail):
            progress = i / max(1, len(self.trail) - 1)
            alpha = int(180 * progress)
            trail_size = int(3 + 4 * progress)

            # ì£¼í™©ìƒ‰ ê·¸ë¼ë°ì´ì…˜
            r = int(255 * (0.8 + 0.2 * progress))
            g = int(180 * progress)
            b = int(50 * progress)

            trail_surf = pygame.Surface((trail_size * 2, trail_size * 2), pygame.SRCALPHA)
            pygame.draw.circle(trail_surf, (r, g, b, alpha),
                             (trail_size, trail_size), trail_size)
            screen.blit(trail_surf, (int(trail_pos.x - trail_size),
                                    int(trail_pos.y - trail_size)))

        if not self.is_alive:
            return

        # ê¸€ë¡œìš° íš¨ê³¼
        glow_surf = pygame.Surface((self.glow_size * 2, self.glow_size * 2), pygame.SRCALPHA)
        pygame.draw.circle(glow_surf, (255, 200, 100, 100),
                          (self.glow_size, self.glow_size), self.glow_size)
        screen.blit(glow_surf, (int(self.pos.x - self.glow_size),
                               int(self.pos.y - self.glow_size)))

        # í¬íƒ„ ë³¸ì²´
        pygame.draw.circle(screen, (255, 220, 150),
                          (int(self.pos.x), int(self.pos.y)), self.size)
        pygame.draw.circle(screen, (255, 255, 200),
                          (int(self.pos.x), int(self.pos.y)), self.size // 2)


class BunkerCannonEffect:
    """
    2ë§‰ ë²™ì»¤ í¬ì‹  ì—°ì¶œ íš¨ê³¼

    ìƒíƒœ ë¨¸ì‹ :
    - IDLE: ëŒ€ê¸° (3-8ì´ˆ ëœë¤)
    - AIMING: ëª©í‘œ ì¡°ì¤€ (í¬ì‹  íšŒì „)
    - CHARGING: ì¶©ì „ (ê²½ê³ ì„  í‘œì‹œ)
    - FIRING: ë°œì‚¬ (ì„¬ê´‘ + ë°˜ë™)
    - COOLDOWN: ì¿¨ë‹¤ìš´
    """

    # ìƒíƒœ ìƒìˆ˜
    STATE_IDLE = "idle"
    STATE_AIMING = "aiming"
    STATE_CHARGING = "charging"
    STATE_FIRING = "firing"
    STATE_COOLDOWN = "cooldown"

    def __init__(self, screen_size: Tuple[int, int], position: Tuple[float, float] = None):
        """
        Args:
            screen_size: í™”ë©´ í¬ê¸°
            position: í¬ì‹  ê¸°ì¤€ì  ìœ„ì¹˜ (ê¸°ë³¸: í™”ë©´ ìš°ì¸¡ í•˜ë‹¨)
        """
        self.screen_size = screen_size

        # í¬ì‹  ìœ„ì¹˜ (í™”ë©´ ìš°ì¸¡ í•˜ë‹¨, ë°°ê²½ ê±´ë¬¼ ìœ„ì¹˜ ì¶”ì •)
        if position:
            self.base_pos = pygame.math.Vector2(position)
        else:
            self.base_pos = pygame.math.Vector2(
                screen_size[0] * 0.85,
                screen_size[1] * 0.75
            )

        # í¬ì‹  í¬ê¸°
        self.barrel_length = 80
        self.barrel_width = 16

        # íšŒì „ ê°ë„ (ë¼ë””ì•ˆ, 0 = ì˜¤ë¥¸ìª½, ìœ„ìª½ì´ ìŒìˆ˜)
        self.current_angle = -math.pi / 4  # -45ë„ (ì¢Œìƒë‹¨ ë°©í–¥)
        self.target_angle = self.current_angle
        self.angle_speed = 1.5  # ë¼ë””ì•ˆ/ì´ˆ

        # ë°˜ë™ íš¨ê³¼
        self.recoil_offset = 0.0
        self.recoil_max = 20.0

        # ìƒíƒœ ë¨¸ì‹ 
        self.state = self.STATE_IDLE
        self.state_timer = 0.0
        self.state_duration = random.uniform(3.0, 6.0)

        # ë°œì‚¬ ëŒ€ìƒ
        self.target_pos: Optional[pygame.math.Vector2] = None
        self.fire_pattern = "player"  # player, random_area, sweep

        # í¬íƒ„ ë° íŒŒí‹°í´
        self.shells: List[CannonShell] = []
        self.smoke_particles: List[SmokeParticle] = []

        # ë¨¸ì¦ í”Œë˜ì‹œ
        self.muzzle_flash_timer = 0.0
        self.muzzle_flash_duration = 0.15

        # ì¶©ì „ ê²½ê³ ì„ 
        self.charge_warning_blink = 0.0

        # í™œì„±í™” ìƒíƒœ
        self.is_active = False

        # í­ë°œ íš¨ê³¼ ì½œë°± (story_modeì—ì„œ ì„¤ì •)
        self.on_shell_explode = None

    def activate(self):
        """í¬ì‹  í™œì„±í™”"""
        self.is_active = True
        self.state = self.STATE_IDLE
        self.state_timer = 0.0
        self.state_duration = random.uniform(2.0, 4.0)

    def deactivate(self):
        """í¬ì‹  ë¹„í™œì„±í™”"""
        self.is_active = False

    def _select_target(self, player_pos: Optional[Tuple[float, float]],
                       enemies: List = None) -> pygame.math.Vector2:
        """ë°œì‚¬ ëŒ€ìƒ ì„ íƒ - ê°€ì¥ ê°€ê¹Œìš´ ì  ìš°ì„ """
        # ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
        if enemies:
            closest_enemy = None
            closest_dist = float('inf')
            for enemy in enemies:
                if hasattr(enemy, 'is_alive') and enemy.is_alive:
                    dist = ((enemy.pos.x - self.base_pos.x) ** 2 +
                           (enemy.pos.y - self.base_pos.y) ** 2) ** 0.5
                    if dist < closest_dist:
                        closest_dist = dist
                        closest_enemy = enemy

            if closest_enemy:
                self.fire_pattern = "enemy"
                return pygame.math.Vector2(closest_enemy.pos.x, closest_enemy.pos.y)

        # ì ì´ ì—†ìœ¼ë©´ ëœë¤ ì˜ì—­
        self.fire_pattern = "random_area"
        return pygame.math.Vector2(
            random.uniform(self.screen_size[0] * 0.2, self.screen_size[0] * 0.8),
            random.uniform(self.screen_size[1] * 0.1, self.screen_size[1] * 0.4)
        )

    def _calculate_angle_to_target(self) -> float:
        """ëŒ€ìƒê¹Œì§€ì˜ ê°ë„ ê³„ì‚°"""
        if not self.target_pos:
            return self.current_angle

        direction = self.target_pos - self.base_pos
        return math.atan2(direction.y, direction.x)

    def _get_muzzle_position(self) -> pygame.math.Vector2:
        """í¬êµ¬ ìœ„ì¹˜ ë°˜í™˜ (ë°˜ë™ ì ìš©)"""
        effective_length = self.barrel_length - self.recoil_offset
        return pygame.math.Vector2(
            self.base_pos.x + math.cos(self.current_angle) * effective_length,
            self.base_pos.y + math.sin(self.current_angle) * effective_length
        )

    def update(self, dt: float, player_pos: Optional[Tuple[float, float]] = None,
               enemies: List = None):
        """ìƒíƒœ ë¨¸ì‹  ì—…ë°ì´íŠ¸"""
        if not self.is_active:
            return

        self.state_timer += dt

        # ìƒíƒœë³„ ì²˜ë¦¬
        if self.state == self.STATE_IDLE:
            self._update_idle(dt, player_pos, enemies)
        elif self.state == self.STATE_AIMING:
            self._update_aiming(dt)
        elif self.state == self.STATE_CHARGING:
            self._update_charging(dt)
        elif self.state == self.STATE_FIRING:
            self._update_firing(dt)
        elif self.state == self.STATE_COOLDOWN:
            self._update_cooldown(dt)

        # ë°˜ë™ ë³µêµ¬
        if self.recoil_offset > 0:
            self.recoil_offset = max(0, self.recoil_offset - 60 * dt)

        # í¬íƒ„ ì—…ë°ì´íŠ¸
        for shell in self.shells[:]:
            exploded = shell.update(dt)
            if exploded and self.on_shell_explode:
                self.on_shell_explode(shell.pos, shell.damage, shell.explosion_radius)
            if not shell.is_alive:
                self.shells.remove(shell)

        # ì—°ê¸° íŒŒí‹°í´ ì—…ë°ì´íŠ¸
        for particle in self.smoke_particles[:]:
            particle.update(dt)
            if not particle.is_alive:
                self.smoke_particles.remove(particle)

    def _update_idle(self, dt: float, player_pos, enemies):
        """ëŒ€ê¸° ìƒíƒœ"""
        if self.state_timer >= self.state_duration:
            # ëª©í‘œ ì„ íƒ ë° ì¡°ì¤€ ì‹œì‘
            self.target_pos = self._select_target(player_pos, enemies)
            self.target_angle = self._calculate_angle_to_target()
            self._change_state(self.STATE_AIMING, 1.5)

    def _update_aiming(self, dt: float):
        """ì¡°ì¤€ ìƒíƒœ (í¬ì‹  íšŒì „)"""
        # ê°ë„ ë³´ê°„
        angle_diff = self.target_angle - self.current_angle
        # ìµœë‹¨ ê²½ë¡œë¡œ íšŒì „
        while angle_diff > math.pi:
            angle_diff -= 2 * math.pi
        while angle_diff < -math.pi:
            angle_diff += 2 * math.pi

        rotate_amount = self.angle_speed * dt
        if abs(angle_diff) < rotate_amount:
            self.current_angle = self.target_angle
        else:
            self.current_angle += rotate_amount if angle_diff > 0 else -rotate_amount

        if self.state_timer >= self.state_duration:
            self._change_state(self.STATE_CHARGING, 0.8)

    def _update_charging(self, dt: float):
        """ì¶©ì „ ìƒíƒœ (ê²½ê³ ì„ )"""
        self.charge_warning_blink += dt * 10

        if self.state_timer >= self.state_duration:
            self._fire()
            self._change_state(self.STATE_FIRING, 0.3)

    def _update_firing(self, dt: float):
        """ë°œì‚¬ ìƒíƒœ (ì„¬ê´‘)"""
        self.muzzle_flash_timer = self.state_timer

        if self.state_timer >= self.state_duration:
            self._change_state(self.STATE_COOLDOWN, 2.0)

    def _update_cooldown(self, dt: float):
        """ì¿¨ë‹¤ìš´ ìƒíƒœ"""
        if self.state_timer >= self.state_duration:
            self._change_state(self.STATE_IDLE, random.uniform(3.0, 8.0))

    def _change_state(self, new_state: str, duration: float):
        """ìƒíƒœ ì „í™˜"""
        self.state = new_state
        self.state_timer = 0.0
        self.state_duration = duration

    def _fire(self):
        """í¬íƒ„ ë°œì‚¬"""
        if not self.target_pos:
            return

        muzzle_pos = self._get_muzzle_position()

        # í¬íƒ„ ìƒì„±
        shell = CannonShell(
            start_pos=(muzzle_pos.x, muzzle_pos.y),
            target_pos=(self.target_pos.x, self.target_pos.y),
            screen_size=self.screen_size
        )
        self.shells.append(shell)

        # ë°˜ë™
        self.recoil_offset = self.recoil_max

        # ì—°ê¸° ìƒì„±
        for _ in range(8):
            smoke = SmokeParticle((muzzle_pos.x, muzzle_pos.y))
            self.smoke_particles.append(smoke)

    def draw_background_layer(self, screen: pygame.Surface):
        """ë°°ê²½ ë ˆì´ì–´ì— ê·¸ë¦´ ìš”ì†Œ (ì—°ê¸°, í¬ì‹ )"""
        if not self.is_active:
            return

        # ì—°ê¸° íŒŒí‹°í´ (ë°°ê²½ì— ë¸”ë Œë”©)
        for particle in self.smoke_particles:
            particle.draw(screen)

        # í¬ì‹  ë² ì´ìŠ¤ (ì›í˜•)
        pygame.draw.circle(screen, (60, 55, 50),
                          (int(self.base_pos.x), int(self.base_pos.y)), 25)
        pygame.draw.circle(screen, (80, 75, 70),
                          (int(self.base_pos.x), int(self.base_pos.y)), 20)

        # í¬ì‹  ë³¸ì²´
        muzzle_pos = self._get_muzzle_position()
        barrel_points = self._get_barrel_polygon()
        pygame.draw.polygon(screen, (70, 65, 60), barrel_points)

        # í¬ì‹  í•˜ì´ë¼ì´íŠ¸
        highlight_offset = pygame.math.Vector2(
            -math.sin(self.current_angle) * 3,
            math.cos(self.current_angle) * 3
        )
        highlight_start = self.base_pos + highlight_offset
        highlight_end = muzzle_pos + highlight_offset
        pygame.draw.line(screen, (90, 85, 80),
                        (int(highlight_start.x), int(highlight_start.y)),
                        (int(highlight_end.x), int(highlight_end.y)), 3)

        # ì¶©ì „ ê²½ê³ ì„ 
        if self.state == self.STATE_CHARGING and self.target_pos:
            self._draw_charge_warning(screen)

        # ë¨¸ì¦ í”Œë˜ì‹œ
        if self.state == self.STATE_FIRING:
            self._draw_muzzle_flash(screen)

    def _get_barrel_polygon(self) -> List[Tuple[int, int]]:
        """í¬ì‹  í´ë¦¬ê³¤ ê¼­ì§€ì  ë°˜í™˜"""
        # í¬ì‹  ë°©í–¥ ë²¡í„°
        direction = pygame.math.Vector2(
            math.cos(self.current_angle),
            math.sin(self.current_angle)
        )
        # ìˆ˜ì§ ë²¡í„°
        perpendicular = pygame.math.Vector2(-direction.y, direction.x)

        # ë°˜ë™ ì ìš©ëœ ê¸¸ì´
        effective_length = self.barrel_length - self.recoil_offset

        # 4ê°œì˜ ê¼­ì§€ì 
        half_width = self.barrel_width / 2
        base_left = self.base_pos + perpendicular * half_width
        base_right = self.base_pos - perpendicular * half_width
        tip_left = self.base_pos + direction * effective_length + perpendicular * (half_width * 0.7)
        tip_right = self.base_pos + direction * effective_length - perpendicular * (half_width * 0.7)

        return [
            (int(base_left.x), int(base_left.y)),
            (int(tip_left.x), int(tip_left.y)),
            (int(tip_right.x), int(tip_right.y)),
            (int(base_right.x), int(base_right.y)),
        ]

    def _draw_charge_warning(self, screen: pygame.Surface):
        """ì¶©ì „ ê²½ê³ ì„  (ì ì„ )"""
        if not self.target_pos:
            return

        muzzle_pos = self._get_muzzle_position()

        # ê¹œë°•ì„ íš¨ê³¼
        if int(self.charge_warning_blink) % 2 == 0:
            return

        # ì ì„  ê·¸ë¦¬ê¸°
        direction = self.target_pos - muzzle_pos
        if direction.length() == 0:
            return

        direction = direction.normalize()
        distance = (self.target_pos - muzzle_pos).length()

        dash_length = 15
        gap_length = 10
        current_dist = 0

        while current_dist < distance:
            start = muzzle_pos + direction * current_dist
            end_dist = min(current_dist + dash_length, distance)
            end = muzzle_pos + direction * end_dist

            # ë¹¨ê°„ìƒ‰ ê²½ê³ ì„ 
            pygame.draw.line(screen, (255, 80, 80),
                           (int(start.x), int(start.y)),
                           (int(end.x), int(end.y)), 2)

            current_dist += dash_length + gap_length

    def _draw_muzzle_flash(self, screen: pygame.Surface):
        """ë¨¸ì¦ í”Œë˜ì‹œ (3ë‹¨ê³„ ì„¬ê´‘)"""
        muzzle_pos = self._get_muzzle_position()
        progress = self.muzzle_flash_timer / self.muzzle_flash_duration

        if progress > 1:
            return

        # ì„¬ê´‘ í¬ê¸° (ì‹œê°„ì— ë”°ë¼ ê°ì†Œ)
        flash_scale = 1.0 - progress

        # 3ë‹¨ê³„ ê¸€ë¡œìš°
        sizes = [50, 35, 20]
        colors = [
            (255, 255, 200, int(60 * flash_scale)),
            (255, 200, 100, int(120 * flash_scale)),
            (255, 180, 80, int(200 * flash_scale)),
        ]

        for size, color in zip(sizes, colors):
            actual_size = int(size * flash_scale)
            if actual_size <= 0:
                continue

            surf = pygame.Surface((actual_size * 2, actual_size * 2), pygame.SRCALPHA)
            pygame.draw.circle(surf, color, (actual_size, actual_size), actual_size)
            screen.blit(surf, (int(muzzle_pos.x - actual_size),
                              int(muzzle_pos.y - actual_size)))

    def draw_foreground_layer(self, screen: pygame.Surface):
        """ì „ê²½ ë ˆì´ì–´ì— ê·¸ë¦´ ìš”ì†Œ (í¬íƒ„)"""
        if not self.is_active:
            return

        for shell in self.shells:
            shell.draw(screen)


class CombatMotionEffect:
    """
    ì „íˆ¬ ì¤‘ ê³ ì† ë¹„í–‰ ì—°ì¶œ íš¨ê³¼

    í”Œë ˆì´ì–´ê°€ ì›€ì§ì¼ ë•Œ combat_motion ì´ë¯¸ì§€ë¥¼ í™”ë©´ì— í‘œì‹œ
    - í”Œë ˆì´ì–´ ìœ„ì¹˜ ì¤‘ì‹¬ ì¤Œ/ì›Œí”„ ì¸íŠ¸ë¡œ
    - 5ë‹¨ê³„ ì†ë„ê° ì´ë¯¸ì§€ (combat_motion_00~04)
    - í”„ë ˆì„ ê°„ ë¶€ë“œëŸ¬ìš´ í¬ë¡œìŠ¤í˜ì´ë“œ ì „í™˜
    """

    def __init__(self, screen_size: Tuple[int, int]):
        self.screen_size = screen_size
        self.is_active = False
        self.elapsed = 0.0
        self.duration = 2.0  # íš¨ê³¼ ì§€ì† ì‹œê°„ (3ì´ˆ â†’ 2ì´ˆë¡œ ë‹¨ì¶•)

        # 5ë‹¨ê³„ ì†ë„ ì´ë¯¸ì§€
        self.motion_frames: List[pygame.Surface] = []
        self._load_motion_images()

        # ë¶€ë“œëŸ¬ìš´ í”„ë ˆì„ ì „í™˜ìš©
        self.frame_progress = 0.0  # 0.0 ~ 4.0 (ì—°ì†ì ì¸ í”„ë ˆì„ ìœ„ì¹˜)

        # ë°œë™ ì¡°ê±´ ì¶”ì 
        self.player_move_time = 0.0  # í”Œë ˆì´ì–´ê°€ ì—°ì† ì´ë™í•œ ì‹œê°„
        self.move_threshold = 3.0  # 3ì´ˆ ì´ìƒ ì´ë™í•´ì•¼ ë°œë™
        self.cooldown = 0.0  # ì¿¨ë‹¤ìš´
        self.cooldown_duration = 5.0  # ë‹¤ìŒ ë°œë™ê¹Œì§€ ëŒ€ê¸° ì‹œê°„

        # ë°©í–¥ ì „í™˜ ê°ì§€ìš©
        self.prev_direction = None  # ì´ì „ ì´ë™ ë°©í–¥ (dx, dy ì •ê·œí™”)

        # íš¨ê³¼ íŒŒë¼ë¯¸í„°
        self.flash_alpha = 0
        self.image_alpha = 230  # ì´ë¯¸ì§€ ë¶ˆíˆ¬ëª…ë„ 90% (255 * 0.90 â‰ˆ 230)

        # ì¤Œ/ì›Œí”„ ì¸íŠ¸ë¡œ
        self.intro_phase = False
        self.intro_elapsed = 0.0
        self.intro_duration = 1.0  # ì›Œí”„ ì¸íŠ¸ë¡œ ì§€ì† ì‹œê°„ (1.2ì´ˆ â†’ 1ì´ˆ)
        self.player_pos = None  # í”Œë ˆì´ì–´ ìœ„ì¹˜ (ì¤Œ ì¤‘ì‹¬ì )
        self.zoom_scale = 1.0  # í˜„ì¬ ì¤Œ ìŠ¤ì¼€ì¼

    def _load_motion_images(self):
        """5ë‹¨ê³„ ì†ë„ê° ì´ë¯¸ì§€ ë¡œë“œ (combat_motion_00~04)"""
        extensions = ['jpg', 'png', 'png', 'png', 'png']
        try:
            for i in range(5):
                img_path = Path(f"assets/images/effects/combat_motion_0{i}.{extensions[i]}")
                if img_path.exists():
                    img = pygame.image.load(str(img_path)).convert()
                    scaled = pygame.transform.scale(img, self.screen_size)
                    self.motion_frames.append(scaled)
                else:
                    print(f"WARNING: {img_path} not found")

            if len(self.motion_frames) > 0:
                print(f"INFO: CombatMotionEffect loaded ({len(self.motion_frames)} frames)")
        except Exception as e:
            print(f"WARNING: Failed to load combat_motion images: {e}")

    def reset_wave(self):
        """ìƒˆ ì›¨ì´ë¸Œ ì‹œì‘ ì‹œ í˜¸ì¶œ"""
        self.cooldown = 0.0
        self.player_move_time = 0.0
        self.is_active = False  # íš¨ê³¼ ê°•ì œ ì¢…ë£Œ
        self.elapsed = 0.0
        self.frame_progress = 0.0

    def reset_move_time(self):
        """ì´ë™ ì‹œê°„ ë¦¬ì…‹ (ì /ì‚¬ë¬¼ê³¼ ì¶©ëŒ ì‹œ í˜¸ì¶œ)"""
        self.player_move_time = 0.0

    def stop_effect(self):
        """íš¨ê³¼ ì¦‰ì‹œ ì¢…ë£Œ (ê³µê²© ì‹œ í˜¸ì¶œ)"""
        if self.is_active:
            self.is_active = False
            self.intro_phase = False
            self.elapsed = 0.0
            self.frame_progress = 0.0
            self.player_move_time = 0.0
            self.prev_direction = None

    def update_player_movement(self, is_moving: bool, dt: float, player_pos=None, move_direction=None):
        """í”Œë ˆì´ì–´ ì´ë™ ìƒíƒœ ì¶”ì 

        Args:
            is_moving: í”Œë ˆì´ì–´ê°€ ì´ë™ ì¤‘ì¸ì§€ ì—¬ë¶€
            dt: ë¸íƒ€ íƒ€ì„
            player_pos: í”Œë ˆì´ì–´ ìœ„ì¹˜ (x, y) - ì¤Œ/ì›Œí”„ ì¤‘ì‹¬ì 
            move_direction: ì´ë™ ë°©í–¥ (dx, dy) - ë°©í–¥ ì „í™˜ ê°ì§€ìš©
        """
        if self.is_active:
            return  # íš¨ê³¼ ì§„í–‰ ì¤‘ì—” ì¶”ì  ì•ˆ í•¨

        # ì¿¨ë‹¤ìš´ ê°ì†Œ
        if self.cooldown > 0:
            self.cooldown -= dt

        if is_moving:
            # ë°©í–¥ ì „í™˜ ê°ì§€
            if move_direction is not None and self.prev_direction is not None:
                # ë°©í–¥ ë²¡í„° ë‚´ì ìœ¼ë¡œ ë°©í–¥ ë³€í™” ê°ì§€
                # ë‚´ì ì´ 0.5 ë¯¸ë§Œì´ë©´ 45ë„ ì´ìƒ ë°©í–¥ ì „í™˜ìœ¼ë¡œ ê°„ì£¼
                import math
                dx, dy = move_direction
                pdx, pdy = self.prev_direction
                # ë²¡í„° ì •ê·œí™”
                mag = math.sqrt(dx * dx + dy * dy)
                pmag = math.sqrt(pdx * pdx + pdy * pdy)
                if mag > 0.01 and pmag > 0.01:
                    ndx, ndy = dx / mag, dy / mag
                    npdx, npdy = pdx / pmag, pdy / pmag
                    dot = ndx * npdx + ndy * npdy
                    if dot < 0.5:  # ì•½ 60ë„ ì´ìƒ ë°©í–¥ ì „í™˜
                        self.player_move_time = 0.0  # ëˆ„ì  ì‹œê°„ ë¦¬ì…‹

            # í˜„ì¬ ë°©í–¥ ì €ì¥
            if move_direction is not None:
                self.prev_direction = move_direction

            self.player_move_time += dt
        else:
            self.player_move_time = 0.0
            self.prev_direction = None

        # ë°œë™ ì¡°ê±´ ì²´í¬
        if self._can_trigger():
            self.trigger(player_pos)

    def _can_trigger(self) -> bool:
        """ë°œë™ ê°€ëŠ¥ ì—¬ë¶€ ì²´í¬ (2ì´ˆ ì´ìƒ ì—°ì† ì´ë™ ì‹œ ì–¸ì œë‚˜ ë°œë™)"""
        if self.is_active:
            return False
        if self.cooldown > 0:
            return False
        if self.player_move_time < self.move_threshold:
            return False
        if len(self.motion_frames) == 0:
            return False
        return True

    def trigger(self, player_pos=None):
        """íš¨ê³¼ ë°œë™ (ì¤Œ/ì›Œí”„ ì¸íŠ¸ë¡œ í¬í•¨)

        Args:
            player_pos: í”Œë ˆì´ì–´ ìœ„ì¹˜ (x, y) - ì¤Œ/ì›Œí”„ ì¤‘ì‹¬ì 
        """
        self.is_active = True
        self.elapsed = 0.0
        self.cooldown = self.cooldown_duration
        self.player_move_time = 0.0

        # í”Œë ˆì´ì–´ ìœ„ì¹˜ ì €ì¥ (ì¤Œ ì¤‘ì‹¬ì )
        self.player_pos = player_pos

        # ì¸íŠ¸ë¡œ í˜ì´ì¦ˆ ì´ˆê¸°í™” (ì¤Œ/ì›Œí”„)
        self.intro_phase = True
        self.intro_elapsed = 0.0
        self.zoom_scale = 1.0  # ì¤Œ ìŠ¤ì¼€ì¼ ì´ˆê¸°í™”

        # ë©”ì¸ íš¨ê³¼ ì´ˆê¸°í™”
        self.frame_progress = 0.0
        self.flash_alpha = 150

        print(f"INFO: CombatMotionEffect triggered with zoom/warp")

    def update(self, dt: float):
        """íš¨ê³¼ ì—…ë°ì´íŠ¸"""
        if not self.is_active:
            return

        # ì¸íŠ¸ë¡œ í˜ì´ì¦ˆ (í”Œë ˆì´ì–´ ì”ìƒ)
        if self.intro_phase:
            self.intro_elapsed += dt
            if self.intro_elapsed >= self.intro_duration:
                self.intro_phase = False
            return  # ì¸íŠ¸ë¡œ ì¤‘ì—ëŠ” ë©”ì¸ íš¨ê³¼ ì§„í–‰ ì•ˆ í•¨

        # ë©”ì¸ íš¨ê³¼
        self.elapsed += dt
        progress = self.elapsed / self.duration

        if progress >= 1.0:
            self.is_active = False
            return

        # ì—°ì†ì ì¸ í”„ë ˆì„ ì§„í–‰ (0.0 ~ 4.0 ì‚¬ì´ë¥¼ ë¶€ë“œëŸ½ê²Œ ì´ë™)
        # ê°€ì† êµ¬ê°„ (0~70%): 0 â†’ 4
        # ìµœê³ ì† ìœ ì§€ (70~85%): 4
        # ê°ì† êµ¬ê°„ (85~100%): 4 â†’ 0
        if progress < 0.70:
            # ê°€ì†: ease-out ì»¤ë¸Œë¡œ ë¶€ë“œëŸ½ê²Œ ì¦ê°€
            accel_progress = progress / 0.70
            eased = 1 - (1 - accel_progress) ** 2  # ease-out quad
            self.frame_progress = eased * 4.0
        elif progress < 0.85:
            # ìµœê³ ì† ìœ ì§€
            self.frame_progress = 4.0
        else:
            # ê°ì†: ease-in ì»¤ë¸Œë¡œ ë¶€ë“œëŸ½ê²Œ ê°ì†Œ
            decel_progress = (progress - 0.85) / 0.15
            eased = decel_progress ** 2  # ease-in quad
            self.frame_progress = 4.0 * (1 - eased)

        # í”Œë˜ì‹œ (ë¹ ë¥´ê²Œ ê°ì†Œ)
        if progress < 0.10:
            self.flash_alpha = int(120 * (1 - progress / 0.10))
        else:
            self.flash_alpha = 0

    def _draw_zoom_warp(self, screen: pygame.Surface, intro_progress: float):
        """ì¤Œ/ì›Œí”„ íš¨ê³¼ ê·¸ë¦¬ê¸° - í”Œë ˆì´ì–´ ìœ„ì¹˜ì—ì„œ ì›í˜•ìœ¼ë¡œ ì‹œì‘í•´ ì „ì²´ í™”ë©´ìœ¼ë¡œ í™•ëŒ€"""
        if not self.player_pos or len(self.motion_frames) == 0:
            return

        import math

        px, py = self.player_pos
        sw, sh = self.screen_size

        # ì»¤ìŠ¤í…€ ì´ì§•: ì´ˆë°˜ì— ì²œì²œíˆ â†’ í›„ë°˜ì— ë¹ ë¥´ê²Œ
        # ì‘ì€ ì› ìƒíƒœë¥¼ ë” ì˜¤ë˜ ë³¼ ìˆ˜ ìˆë„ë¡
        if intro_progress < 0.5:
            # ì´ˆë°˜ 50%: ì²œì²œíˆ í™•ëŒ€ (ì „ì²´ì˜ 20%ë§Œ ì§„í–‰)
            t = intro_progress / 0.5
            eased = 0.2 * (t ** 2)  # ease-in quad
        else:
            # í›„ë°˜ 50%: ë¹ ë¥´ê²Œ í™•ëŒ€ (ë‚˜ë¨¸ì§€ 80% ì§„í–‰)
            t = (intro_progress - 0.5) / 0.5
            eased = 0.2 + 0.8 * (1 - (1 - t) ** 2)  # ease-out quad

        # ì›í˜• ë§ˆìŠ¤í¬ ë°˜ê²½: ì‘ì€ ì› â†’ ì „ì²´ í™”ë©´ì„ ë®ì„ ë§Œí¼ í™•ëŒ€
        # ëŒ€ê°ì„  ê¸¸ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìµœëŒ€ ë°˜ê²½ ê³„ì‚°
        max_radius = math.sqrt(sw ** 2 + sh ** 2)
        min_radius = 60  # ì‹œì‘ ë°˜ê²½ (ë” í° ì›ìœ¼ë¡œ ì‹œì‘)
        current_radius = min_radius + (max_radius - min_radius) * eased

        # ì²« ë²ˆì§¸ ëª¨ì…˜ í”„ë ˆì„
        base_frame = self.motion_frames[0]

        # ì›í˜• ë§ˆìŠ¤í¬ Surface ìƒì„±
        mask_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)

        # ì›í˜• í´ë¦¬í•‘ ì˜ì—­ì— ì†ë„ê° ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        # ì› ë‚´ë¶€ë§Œ ë³´ì´ë„ë¡ ë§ˆìŠ¤í¬ ì ìš©
        pygame.draw.circle(mask_surf, (255, 255, 255, 255),
                          (int(px), int(py)), int(current_radius))

        # ì†ë„ê° ì´ë¯¸ì§€ë¥¼ ë§ˆìŠ¤í¬ì— ë¸”ë¦¿ (BLEND_RGBA_MINìœ¼ë¡œ ë§ˆìŠ¤í¬ ì ìš©)
        temp_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        temp_surf.blit(base_frame, (0, 0))
        temp_surf.blit(mask_surf, (0, 0), special_flags=pygame.BLEND_RGBA_MIN)

        # íˆ¬ëª…ë„ ì ìš© (30~40% â†’ ì•ŒíŒŒ 75~100)
        temp_surf.set_alpha(self.image_alpha)
        screen.blit(temp_surf, (0, 0))

        # ì›í˜• í…Œë‘ë¦¬ íš¨ê³¼ (í™•ëŒ€ë˜ëŠ” ì›ì˜ ê°€ì¥ìë¦¬ ê°•ì¡°) - ë” ì˜¤ë˜ í‘œì‹œ
        if current_radius < max_radius * 0.95:
            edge_alpha = int(255 * (1 - eased * 0.8))
            edge_color = (200, 220, 255, edge_alpha)
            edge_thickness = max(4, int(12 * (1 - eased)))
            pygame.draw.circle(screen, edge_color,
                             (int(px), int(py)), int(current_radius), edge_thickness)

        # ë°©ì‚¬í˜• ì†ë„ì„  ì œê±°ë¨

    def _draw_warp_lines(self, screen: pygame.Surface, cx: int, cy: int,
                          progress: float, alpha: int):
        """ì›Œí”„ ì†ë„ì„  ê·¸ë¦¬ê¸° (ì›í˜• ê°€ì¥ìë¦¬ì—ì„œ ë°”ê¹¥ìœ¼ë¡œ ë»—ì–´ë‚˜ê°)"""
        import math

        line_count = 16  # ë°©ì‚¬ì„  ê°œìˆ˜ (32 â†’ 16ìœ¼ë¡œ ì¶•ì†Œ)
        sw, sh = self.screen_size
        max_radius = math.sqrt(sw ** 2 + sh ** 2)

        # í˜„ì¬ ì›í˜• ë§ˆìŠ¤í¬ ë°˜ê²½
        min_radius = 30
        current_radius = min_radius + (max_radius - min_radius) * progress

        line_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)

        for i in range(line_count):
            angle = (i / line_count) * 2 * math.pi

            # ì‹œì‘ì : ì›í˜• ê°€ì¥ìë¦¬ ë°”ë¡œ ë°”ê¹¥
            start_dist = current_radius + 5
            start_x = cx + math.cos(angle) * start_dist
            start_y = cy + math.sin(angle) * start_dist

            # ëì : ì›í˜• ê°€ì¥ìë¦¬ì—ì„œ ë” ë°”ê¹¥ìœ¼ë¡œ
            line_length = 40 + 60 * progress  # ì„  ê¸¸ì´ (80~200 â†’ 40~100ìœ¼ë¡œ ì¶•ì†Œ)
            end_dist = start_dist + line_length
            end_x = cx + math.cos(angle) * end_dist
            end_y = cy + math.sin(angle) * end_dist

            # ì„  ìƒ‰ìƒ (í°ìƒ‰~í•˜ëŠ˜ìƒ‰, ê·¸ë¼ë°ì´ì…˜)
            color = (220, 235, 255, alpha)
            thickness = 2 + int(progress * 2)

            pygame.draw.line(line_surf, color,
                           (int(start_x), int(start_y)),
                           (int(end_x), int(end_y)), thickness)

        screen.blit(line_surf, (0, 0))

    def draw(self, screen: pygame.Surface):
        """íš¨ê³¼ ë Œë”ë§ (ì¤Œ/ì›Œí”„ ì¸íŠ¸ë¡œ + ë©”ì¸ ì†ë„ê°)"""
        if not self.is_active or len(self.motion_frames) == 0:
            return

        # === ì¸íŠ¸ë¡œ í˜ì´ì¦ˆ: ì¤Œ/ì›Œí”„ íš¨ê³¼ ===
        if self.intro_phase:
            intro_progress = self.intro_elapsed / self.intro_duration

            # ì¤Œ/ì›Œí”„ íš¨ê³¼ (í”Œë ˆì´ì–´ ìœ„ì¹˜ ì¤‘ì‹¬ìœ¼ë¡œ í™•ëŒ€ + ë°©ì‚¬í˜• ì†ë„ì„ )
            self._draw_zoom_warp(screen, intro_progress)

            # í”Œë˜ì‹œ ì˜¤ë²„ë ˆì´ (ì›Œí”„ ì‹œì‘ ì‹œ ê°•í•œ ë¹›)
            flash_alpha = int(200 * (1 - intro_progress ** 0.5))
            if flash_alpha > 0:
                flash_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
                flash_surf.fill((255, 255, 255, flash_alpha))
                screen.blit(flash_surf, (0, 0))
            return

        # === ë©”ì¸ í˜ì´ì¦ˆ: ê¸°ì¡´ ì†ë„ê° ì´ë¯¸ì§€ (íˆ¬ëª…ë„ ì ìš©) ===
        progress = self.elapsed / self.duration

        # í˜ì´ë“œ ì•„ì›ƒ ì•ŒíŒŒ ê³„ì‚° (ì¸íŠ¸ë¡œ í›„ì´ë¯€ë¡œ í˜ì´ë“œ ì¸ ë¶ˆí•„ìš”)
        # ê¸°ë³¸ íˆ¬ëª…ë„(image_alpha)ì—ì„œ í˜ì´ë“œ ì•„ì›ƒ
        if progress > 0.88:
            fade_factor = 1 - (progress - 0.88) / 0.12
            master_alpha = int(self.image_alpha * fade_factor)
        else:
            master_alpha = self.image_alpha

        # í”„ë ˆì„ ë¸”ë Œë”© ê³„ì‚°
        frame_idx = int(self.frame_progress)
        frame_idx = max(0, min(frame_idx, len(self.motion_frames) - 1))
        blend_factor = self.frame_progress - frame_idx  # 0.0 ~ 1.0

        # ë¸”ë Œë”©ìš© Surface ìƒì„± (SRCALPHAë¡œ íˆ¬ëª…ë„ ì§€ì›)
        blend_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)

        # í˜„ì¬ í”„ë ˆì„
        current_frame = self.motion_frames[frame_idx]
        blend_surf.blit(current_frame, (0, 0))

        # ë‹¤ìŒ í”„ë ˆì„ê³¼ í¬ë¡œìŠ¤í˜ì´ë“œ (ìˆëŠ” ê²½ìš°)
        next_idx = frame_idx + 1
        if next_idx < len(self.motion_frames) and blend_factor > 0:
            next_frame = self.motion_frames[next_idx]
            next_copy = next_frame.copy()
            next_copy.set_alpha(int(255 * blend_factor))
            blend_surf.blit(next_copy, (0, 0))

        # ë§ˆìŠ¤í„° ì•ŒíŒŒ ì ìš© (30~40% íˆ¬ëª…ë„)
        blend_surf.set_alpha(master_alpha)

        screen.blit(blend_surf, (0, 0))

        # í”Œë˜ì‹œ ì˜¤ë²„ë ˆì´
        if self.flash_alpha > 0:
            flash_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
            flash_surf.fill((255, 255, 255, self.flash_alpha))
            screen.blit(flash_surf, (0, 0))


# =========================================================
# Act 2: ê¸°ë°€ ë¬¸ì„œ ë·°ì–´ íš¨ê³¼
# =========================================================
class ClassifiedDocumentEffect:
    """
    Act 2 ì»·ì”¬: ê¸°ë°€ ë¬¸ì„œ ë·°ì–´ íš¨ê³¼

    ìƒˆë¡œìš´ ì—°ì¶œ ìˆœì„œ:
    1. ê±´ë¬¼ ì¤‘ì•™ ê²€ì€ë¬¸ìœ¼ë¡œ ì²œì²œíˆ í´ë¡œì¦ˆì—…
    2. gate01~04 ì „ì²´í™”ë©´ìœ¼ë¡œ ìì—°ìŠ¤ëŸ½ê²Œ ì—°ê²°
    3. gate ì—°ì¶œ í›„ ìºë¹„ë‹› ë“±ì¥
    4. ëŒ€í™” í´ë¦­ë§ˆë‹¤ ë¬¸ì„œ ë“±ì¥ ë° í™”ë©´ì— ìŒ“ì„
    5. ëª¨ë“  ë¬¸ì„œ ìŒ“ì¸ í›„ ê° ë¬¸ì„œ í™•ëŒ€â†’ì¶•ì†Œâ†’ì •ë ¬
    6. ëŒ€í™” ì¢…ë£Œì‹œ ì›ë˜ ë°°ê²½ìœ¼ë¡œ ë³µê·€
    """

    # í˜ì´ì¦ˆ ì •ì˜
    PHASE_ZOOM_IN = 0           # ë°°ê²½ ê±´ë¬¼ ì¤‘ì•™ìœ¼ë¡œ í´ë¡œì¦ˆì—…
    PHASE_GATE_SEQUENCE = 1     # gate ì´ë¯¸ì§€ ì‹œí€€ìŠ¤ (ì „ì²´í™”ë©´ ì „í™˜)
    PHASE_CABINET_SHOW = 2      # ìºë¹„ë‹› ë“±ì¥
    PHASE_DIALOGUE = 3          # ëŒ€í™” + ë¬¸ì„œ ë“±ì¥
    PHASE_DOC_REVIEW = 4        # ëª¨ë“  ë¬¸ì„œ ì¦‰ê° ì •ë ¬
    PHASE_DOC_VIEW = 5          # ì •ë ¬ í›„ ëŒ€ê¸° - í´ë¦­ìœ¼ë¡œ ë¬¸ì„œ í™•ëŒ€ ë³´ê¸°
    PHASE_ZOOM_OUT = 6          # ì›ë˜ ë°°ê²½ìœ¼ë¡œ ë³µê·€
    PHASE_DONE = 7

    def __init__(self, screen_size: tuple, document_paths: list,
                 background_path: str = None, dialogue_after: list = None,
                 sound_manager=None, special_effects: dict = None,
                 scene_id: str = "document_scene",
                 gate_image_paths: list = None):
        self.screen_size = screen_size
        self.document_paths = document_paths
        self.background_path = background_path
        self.dialogue_after = dialogue_after or []
        self.sound_manager = sound_manager
        self.special_effects = special_effects or {}
        self.scene_id = scene_id

        self.is_alive = True
        self.phase = self.PHASE_ZOOM_IN
        self.phase_timer = 0.0

        # gate ì´ë¯¸ì§€ ê²½ë¡œ (ê¸°ë³¸ê°’ - ì‹¤ì œ íŒŒì¼ ê¸°ì¤€)
        self.gate_image_paths = gate_image_paths or [
            "assets/story_mode/documents/bunker_gate_01.jpg",
            "assets/story_mode/documents/bunker_gate_02.jpg",
            "assets/story_mode/documents/bunker_gate_03.jpg",
        ]

        # íƒ€ì´ë° ì„¤ì • (ëª¨ë“  ë“±ì¥ ì²œì²œíˆ)
        self.zoom_in_duration = 4.5          # í´ë¡œì¦ˆì—… ì‹œê°„ (ë” ëŠë¦¬ê²Œ)
        self.gate_transition_duration = 3.0  # ê° gate ì´ë¯¸ì§€ ì „í™˜ ì‹œê°„ (ëŠë¦¬ê²Œ)
        self.gate_display_duration = 2.5     # ê° gate ì´ë¯¸ì§€ í‘œì‹œ ì‹œê°„ (ë” ì˜¤ë˜)
        self.cabinet_show_duration = 2.0     # ìºë¹„ë‹› ë“±ì¥ ì‹œê°„ (ì²œì²œíˆ)
        self.doc_rise_duration = 1.5         # ë¬¸ì„œ ì†Ÿì•„ì˜¤ë¥´ëŠ” ì‹œê°„ (ì²œì²œíˆ)
        self.doc_review_duration = 0.15      # ê° ë¬¸ì„œ ì •ë ¬ ì‹œê°„ (ê±°ì˜ ì¦‰ê°)
        self.zoom_out_duration = 4.0         # ì¤Œì•„ì›ƒ ì‹œê°„ (ì²œì²œíˆ)

        # ì¤Œ íš¨ê³¼
        self.zoom_scale = 1.0                # í˜„ì¬ ì¤Œ ë°°ìœ¨
        self.zoom_target_scale = 3.0         # ëª©í‘œ ì¤Œ ë°°ìœ¨ (ë” ê¹Šì´)
        self.zoom_center_x = 0.5             # ì¤Œ ì¤‘ì‹¬ X (ê±´ë¬¼ ì¤‘ì•™)
        self.zoom_center_y = 0.38            # ì¤Œ ì¤‘ì‹¬ Y (ê±´ë¬¼ ë¬¸ ìœ„ì¹˜)

        # ë°°ê²½
        self.background_original = None
        self.background = None
        if background_path:
            self._load_background(background_path)

        # gate ì´ë¯¸ì§€ë“¤
        self.gate_images = []
        self.current_gate_index = 0
        self.gate_transition_progress = 0.0
        self.gate_display_timer = 0.0
        self.gate_state = "display"  # "display" or "transition"
        self._load_gate_images()

        # ìºë¹„ë‹› ì´ë¯¸ì§€
        self.cabinet_image = None
        self.cabinet_y_offset = 0.0
        self._load_cabinet()

        # ë¬¸ì„œë“¤
        self.documents = []
        self.doc_final_positions = []  # ì •ë ¬ëœ ìµœì¢… ìœ„ì¹˜ (ë¨¼ì € ì´ˆê¸°í™”)
        self._prepare_documents()

        # í˜„ì¬ í‘œì‹œ ì¤‘ì¸ ë¬¸ì„œ
        self.current_doc_index = -1
        self.doc_rise_progress = 0.0
        self.doc_is_rising = False

        # ë¬¸ì„œ ë¦¬ë·° ê´€ë ¨ (ì¦‰ê° ì •ë ¬)
        self.review_doc_index = 0
        self.review_state = "arrange_all"  # "arrange_all" (ì¦‰ê° ì •ë ¬)
        self.review_progress = 0.0

        # ë¬¸ì„œ í™•ëŒ€ ë³´ê¸° ê´€ë ¨ (PHASE_DOC_VIEW)
        self.viewing_doc_index = -1      # í˜„ì¬ í™•ëŒ€ ë³´ê¸° ì¤‘ì¸ ë¬¸ì„œ (-1ì´ë©´ ì—†ìŒ)
        self.view_zoom_progress = 0.0    # í™•ëŒ€/ì¶•ì†Œ ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ë„
        self.view_zoom_duration = 0.25   # í™•ëŒ€ ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„ (ë¹ ë¥´ê²Œ)
        self.view_state = "idle"         # "idle", "zoom_in", "viewing", "zoom_out"
        self.doc_rects = []              # ê° ë¬¸ì„œì˜ í´ë¦­ ì˜ì—­

        # ëŒ€ì‚¬ ê´€ë ¨
        self.current_dialogue_index = 0
        self.dialogue_text = ""
        self.typing_progress = 0.0
        self.typing_speed = 30.0
        self.waiting_for_click = False

        # ì´ˆìƒí™” ìºì‹œ
        self.portrait_cache = {}

        # í°íŠ¸
        self.fonts = {}

        # ì½œë°±
        self.on_complete = None
        self.on_replay_request = None

        # í˜ì´ë“œ íš¨ê³¼ìš©
        self.fade_alpha = 0.0

        print(f"INFO: ClassifiedDocumentEffect created with {len(self.document_paths)} documents, {len(self.gate_image_paths)} gate images")

    def _load_background(self, path: str):
        """ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ"""
        try:
            img = pygame.image.load(path).convert()
            self.background_original = pygame.transform.smoothscale(img, self.screen_size)
            self.background = self.background_original.copy()
        except Exception as e:
            print(f"WARNING: Failed to load background: {path} - {e}")
            self.background_original = pygame.Surface(self.screen_size)
            self.background_original.fill((30, 35, 40))
            self.background = self.background_original.copy()

    def _load_gate_images(self):
        """gate ì´ë¯¸ì§€ë“¤ ë¡œë“œ (ì „ì²´í™”ë©´ìš©)"""
        for path in self.gate_image_paths:
            try:
                img = pygame.image.load(path).convert()
                img = pygame.transform.smoothscale(img, self.screen_size)
                self.gate_images.append(img)
            except Exception as e:
                print(f"WARNING: Failed to load gate image: {path} - {e}")
                # í”Œë ˆì´ìŠ¤í™€ë”
                placeholder = pygame.Surface(self.screen_size)
                placeholder.fill((40, 45, 50))
                self.gate_images.append(placeholder)

        if not self.gate_images:
            # gate ì´ë¯¸ì§€ê°€ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ í”Œë ˆì´ìŠ¤í™€ë” ì¶”ê°€
            placeholder = pygame.Surface(self.screen_size)
            placeholder.fill((40, 45, 50))
            self.gate_images.append(placeholder)

    def _load_cabinet(self):
        """ìºë¹„ë‹› ì´ë¯¸ì§€ ë¡œë“œ"""
        cabinet_path = "assets/story_mode/documents/doc_cabinet.png"
        try:
            img = pygame.image.load(cabinet_path).convert_alpha()
            cabinet_height = int(self.screen_size[1] * 0.55)
            orig_w, orig_h = img.get_size()
            ratio = cabinet_height / orig_h
            cabinet_width = int(orig_w * ratio)
            self.cabinet_image = pygame.transform.smoothscale(img, (cabinet_width, cabinet_height))
        except Exception as e:
            print(f"WARNING: Failed to load cabinet: {cabinet_path} - {e}")
            cabinet_width = int(self.screen_size[0] * 0.35)
            cabinet_height = int(self.screen_size[1] * 0.55)
            self.cabinet_image = pygame.Surface((cabinet_width, cabinet_height), pygame.SRCALPHA)
            pygame.draw.rect(self.cabinet_image, (50, 55, 60), (0, 0, cabinet_width, cabinet_height))
            pygame.draw.rect(self.cabinet_image, (80, 85, 90), (0, 0, cabinet_width, cabinet_height), 3)
            for i in range(3):
                handle_y = 80 + i * (cabinet_height // 4)
                pygame.draw.rect(self.cabinet_image, (100, 105, 110),
                               (cabinet_width // 2 - 30, handle_y, 60, 15))

    def _prepare_documents(self):
        """ë¬¸ì„œ ì´ë¯¸ì§€ ì¤€ë¹„ - ì›ë³¸ ë¹„ìœ¨ ìœ ì§€, íŠ¹ì • ë¬¸ì„œë§Œ ë†’ì´ ì¡°ì •"""
        screen_w, screen_h = self.screen_size

        # ë¬¸ì„œ ìµœëŒ€ í¬ê¸°
        max_width = int(screen_w * 0.26)
        max_height = int(screen_h * 0.58)

        # ë¬¸ì„œ 1, 2ë§Œ ë†’ì´ ì¤„ì„ (íŒŒì¼ëª… ê¸°ì¤€)
        height_reduction = {
            "doc_project_ark.png": 0.80,     # ë¬¸ì„œ 1: ë†’ì´ 80%ë¡œ ì¤„ì„
            "doc_survivor_list.png": 0.80,   # ë¬¸ì„œ 2: ë†’ì´ 80%ë¡œ ì¤„ì„
        }

        # ë¬¸ì„œ 4ë§Œ ì•½ê°„ í™•ëŒ€
        scale_up = {
            "doc_transmission.png": 1.05,    # ë¬¸ì„œ 4: 5% í™•ëŒ€
        }

        for i, path in enumerate(self.document_paths):
            doc_img = None
            filename = Path(path).name

            try:
                doc_img = pygame.image.load(path).convert_alpha()
                orig_w, orig_h = doc_img.get_size()

                # ë¹„ìœ¨ ìœ ì§€í•˜ë©´ì„œ ìµœëŒ€ í¬ê¸°ì— ë§ì¶¤
                ratio = min(max_width / orig_w, max_height / orig_h)

                # ë¬¸ì„œ 4 í™•ëŒ€
                if filename in scale_up:
                    ratio *= scale_up[filename]

                new_w = int(orig_w * ratio)
                new_h = int(orig_h * ratio)

                # ë¬¸ì„œ 1, 2ë§Œ ë†’ì´ ì¤„ì„
                if filename in height_reduction:
                    new_h = int(new_h * height_reduction[filename])

                doc_img = pygame.transform.smoothscale(doc_img, (new_w, new_h))
            except Exception as e:
                print(f"WARNING: Failed to load document: {path} - {e}")
                doc_img = pygame.Surface((max_width, max_height), pygame.SRCALPHA)
                doc_img.fill((200, 190, 170))

            self.documents.append({
                'image': doc_img,
                'filename': filename,
                'y_offset': 0.0,
                'alpha': 255,
                'visible': False,
                'scale': 1.0,
                'pos_x': screen_w // 2,
                'pos_y': screen_h // 2,
            })

        # ë¬¸ì„œ ìµœì¢… ì •ë ¬ ìœ„ì¹˜ ê³„ì‚° (ê°€ë¡œë¡œ ë‚˜ì—´)
        self._calculate_final_positions()

    def _calculate_final_positions(self):
        """ë¬¸ì„œë“¤ì˜ ìµœì¢… ì •ë ¬ ìœ„ì¹˜ ê³„ì‚°"""
        screen_w, screen_h = self.screen_size
        num_docs = len(self.documents)

        if num_docs == 0:
            return

        # ë¬¸ì„œë“¤ì„ ê°€ë¡œë¡œ ë‚˜ì—´ (ì¶•ì†Œí•´ì„œ)
        total_width = screen_w * 0.8
        spacing = total_width / (num_docs + 1)
        start_x = screen_w * 0.1 + spacing

        for i in range(num_docs):
            self.doc_final_positions.append({
                'x': start_x + i * spacing,
                'y': screen_h * 0.45,
                'scale': 0.5  # ì¶•ì†Œ ë¹„ìœ¨
            })

    def set_fonts(self, fonts: dict):
        """í°íŠ¸ ì„¤ì •"""
        self.fonts = fonts

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        if self.phase == self.PHASE_ZOOM_IN:
            self._update_zoom_in(dt)

        elif self.phase == self.PHASE_GATE_SEQUENCE:
            self._update_gate_sequence(dt)

        elif self.phase == self.PHASE_CABINET_SHOW:
            self._update_cabinet_show(dt)

        elif self.phase == self.PHASE_DIALOGUE:
            self._update_dialogue_phase(dt)

        elif self.phase == self.PHASE_DOC_REVIEW:
            self._update_doc_review(dt)

        elif self.phase == self.PHASE_DOC_VIEW:
            self._update_doc_view(dt)

        elif self.phase == self.PHASE_ZOOM_OUT:
            self._update_zoom_out(dt)

    def _update_zoom_in(self, dt: float):
        """ë°°ê²½ í´ë¡œì¦ˆì—… ì—…ë°ì´íŠ¸"""
        progress = min(1.0, self.phase_timer / self.zoom_in_duration)
        # ease-out cubic (ì²œì²œíˆ ê°ì†)
        eased = 1.0 - (1.0 - progress) ** 3
        self.zoom_scale = 1.0 + (self.zoom_target_scale - 1.0) * eased

        if progress >= 1.0:
            self.phase = self.PHASE_GATE_SEQUENCE
            self.phase_timer = 0.0
            self.current_gate_index = 0
            self.gate_state = "display"
            self.gate_display_timer = 0.0
            self.fade_alpha = 0.0

    def _update_gate_sequence(self, dt: float):
        """gate ì´ë¯¸ì§€ ì‹œí€€ìŠ¤ ì—…ë°ì´íŠ¸"""
        if self.gate_state == "display":
            # í˜„ì¬ ì´ë¯¸ì§€ í‘œì‹œ ì¤‘
            self.gate_display_timer += dt
            if self.gate_display_timer >= self.gate_display_duration:
                # ë‹¤ìŒ ì´ë¯¸ì§€ë¡œ ì „í™˜ ì‹œì‘
                self.gate_state = "transition"
                self.gate_transition_progress = 0.0
                self.gate_display_timer = 0.0

        elif self.gate_state == "transition":
            # í¬ë¡œìŠ¤í˜ì´ë“œ ì „í™˜ ì¤‘
            self.gate_transition_progress += dt / self.gate_transition_duration

            if self.gate_transition_progress >= 1.0:
                self.gate_transition_progress = 1.0
                self.current_gate_index += 1

                if self.current_gate_index >= len(self.gate_images):
                    # ëª¨ë“  gate ì´ë¯¸ì§€ ì™„ë£Œ -> ìºë¹„ë‹› ë“±ì¥
                    self.phase = self.PHASE_CABINET_SHOW
                    self.phase_timer = 0.0
                    self.fade_alpha = 255  # í˜ì´ë“œ ì•„ì›ƒ ì‹œì‘
                else:
                    self.gate_state = "display"
                    self.gate_display_timer = 0.0

    def _update_cabinet_show(self, dt: float):
        """ìºë¹„ë‹› ë“±ì¥ ì—…ë°ì´íŠ¸"""
        progress = min(1.0, self.phase_timer / self.cabinet_show_duration)
        # ease-out quad
        eased = 1.0 - (1.0 - progress) ** 2
        self.cabinet_y_offset = eased

        # í˜ì´ë“œ ì¸ (gateì—ì„œ ì „í™˜)
        if self.fade_alpha > 0:
            self.fade_alpha = max(0, self.fade_alpha - dt * 200)

        if progress >= 1.0:
            self.phase = self.PHASE_DIALOGUE
            self.phase_timer = 0.0
            self._start_next_document_and_dialogue()

    def _update_dialogue_phase(self, dt: float):
        """ëŒ€í™” + ë¬¸ì„œ ë“±ì¥ ì—…ë°ì´íŠ¸"""
        # ë¬¸ì„œ ì†Ÿì•„ì˜¤ë¥´ê¸° ì• ë‹ˆë©”ì´ì…˜
        if self.doc_is_rising:
            self.doc_rise_progress += dt / self.doc_rise_duration
            if self.doc_rise_progress >= 1.0:
                self.doc_rise_progress = 1.0
                self.doc_is_rising = False

        # ëŒ€í™” íƒ€ì´í•‘
        if self.current_dialogue_index < len(self.dialogue_after):
            if not self.waiting_for_click:
                self.typing_progress += dt * self.typing_speed
                if self.typing_progress >= len(self.dialogue_text):
                    self.typing_progress = len(self.dialogue_text)
                    self.waiting_for_click = True
        else:
            # ëª¨ë“  ëŒ€í™” ì™„ë£Œ -> ë¬¸ì„œ ë¦¬ë·° í˜ì´ì¦ˆë¡œ
            if len(self.documents) > 0:
                self.phase = self.PHASE_DOC_REVIEW
                self.phase_timer = 0.0
                self.review_doc_index = 0
                self.review_state = "arrange_all"  # ì¦‰ê° ì •ë ¬
                self.review_progress = 0.0
            else:
                self.phase = self.PHASE_ZOOM_OUT
                self.phase_timer = 0.0

    def _update_doc_review(self, dt: float):
        """ë¬¸ì„œ ë¦¬ë·° - ì¦‰ê° ì •ë ¬ í›„ DOC_VIEW í˜ì´ì¦ˆë¡œ ì „í™˜"""
        self.review_progress += dt / self.doc_review_duration

        if self.review_state == "arrange_all":
            # ëª¨ë“  ë¬¸ì„œë¥¼ ì¦‰ê° ì •ë ¬ ìœ„ì¹˜ë¡œ ì´ë™
            if self.review_progress >= 1.0:
                # ì •ë ¬ ì™„ë£Œ -> ë¬¸ì„œ í™•ëŒ€ ë³´ê¸° í˜ì´ì¦ˆë¡œ ì „í™˜
                self.phase = self.PHASE_DOC_VIEW
                self.phase_timer = 0.0
                self.view_state = "idle"
                self.viewing_doc_index = -1
                # ë¬¸ì„œ í´ë¦­ ì˜ì—­ ê³„ì‚°
                self._calculate_doc_rects()

    def _update_doc_view(self, dt: float):
        """ë¬¸ì„œ í™•ëŒ€ ë³´ê¸° í˜ì´ì¦ˆ ì—…ë°ì´íŠ¸"""
        if self.view_state == "zoom_in":
            self.view_zoom_progress += dt / self.view_zoom_duration
            if self.view_zoom_progress >= 1.0:
                self.view_zoom_progress = 1.0
                self.view_state = "viewing"

        elif self.view_state == "zoom_out":
            self.view_zoom_progress -= dt / self.view_zoom_duration
            if self.view_zoom_progress <= 0.0:
                self.view_zoom_progress = 0.0
                self.view_state = "idle"
                self.viewing_doc_index = -1

    def _calculate_doc_rects(self):
        """ì •ë ¬ëœ ë¬¸ì„œë“¤ì˜ í´ë¦­ ì˜ì—­ ê³„ì‚°"""
        self.doc_rects = []
        for i, doc in enumerate(self.documents):
            # visible ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ ëª¨ë“  ë¬¸ì„œì— ëŒ€í•´ rect ìƒì„±
            if i < len(self.doc_final_positions):
                pos = self.doc_final_positions[i]
                orig_w, orig_h = doc['image'].get_size()
                scale = pos['scale']
                w = int(orig_w * scale)
                h = int(orig_h * scale)
                rect = pygame.Rect(int(pos['x'] - w // 2), int(pos['y'] - h // 2), w, h)
                self.doc_rects.append(rect)
                # ë¬¸ì„œë¥¼ visibleë¡œ ì„¤ì • (ì •ë ¬ í›„ì—ëŠ” ëª¨ë‘ ë³´ì—¬ì•¼ í•¨)
                doc['visible'] = True

    def _update_zoom_out(self, dt: float):
        """ì›ë˜ ë°°ê²½ìœ¼ë¡œ ë³µê·€"""
        progress = min(1.0, self.phase_timer / self.zoom_out_duration)
        # ease-in-out quad
        if progress < 0.5:
            eased = 2 * progress * progress
        else:
            eased = 1 - ((-2 * progress + 2) ** 2) / 2

        self.zoom_scale = self.zoom_target_scale - (self.zoom_target_scale - 1.0) * eased
        self.cabinet_y_offset = 1.0 - eased

        # ë¬¸ì„œë“¤ í˜ì´ë“œ ì•„ì›ƒ
        for doc in self.documents:
            doc['alpha'] = int(255 * (1.0 - eased))

        if progress >= 1.0:
            self.phase = self.PHASE_DONE
            self.is_alive = False
            if self.on_complete:
                self.on_complete()

    def _start_next_document_and_dialogue(self):
        """ë‹¤ìŒ ë¬¸ì„œì™€ ëŒ€í™” ì‹œì‘"""
        self.current_doc_index += 1
        if self.current_doc_index < len(self.documents):
            self.documents[self.current_doc_index]['visible'] = True
            self.doc_rise_progress = 0.0
            self.doc_is_rising = True

        if self.current_dialogue_index < len(self.dialogue_after):
            self.dialogue_text = self.dialogue_after[self.current_dialogue_index].get("text", "")
            self.typing_progress = 0.0
            self.waiting_for_click = False

    def handle_event(self, event: pygame.event.Event):
        """ì´ë²¤íŠ¸ ì²˜ë¦¬"""
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            return self._handle_click()

        elif event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_SPACE, pygame.K_RETURN]:
                return self._handle_click()

        return False

    def _handle_click(self):
        """í´ë¦­ ì²˜ë¦¬"""
        if self.phase == self.PHASE_ZOOM_IN:
            # ì¤Œì¸ ìŠ¤í‚µ
            self.zoom_scale = self.zoom_target_scale
            self.phase = self.PHASE_GATE_SEQUENCE
            self.phase_timer = 0.0
            self.current_gate_index = 0
            self.gate_state = "display"
            return True

        elif self.phase == self.PHASE_GATE_SEQUENCE:
            # gate ì‹œí€€ìŠ¤ ìŠ¤í‚µ (ë‹¤ìŒ ì´ë¯¸ì§€ë¡œ)
            if self.gate_state == "display":
                self.gate_state = "transition"
                self.gate_transition_progress = 0.0
            else:
                self.gate_transition_progress = 1.0
            return True

        elif self.phase == self.PHASE_CABINET_SHOW:
            # ìºë¹„ë‹› ë“±ì¥ ìŠ¤í‚µ
            self.cabinet_y_offset = 1.0
            self.fade_alpha = 0
            self.phase = self.PHASE_DIALOGUE
            self.phase_timer = 0.0
            self._start_next_document_and_dialogue()
            return True

        elif self.phase == self.PHASE_DIALOGUE:
            if self.waiting_for_click:
                self.current_dialogue_index += 1
                if self.current_dialogue_index < len(self.dialogue_after):
                    self._start_next_document_and_dialogue()
                else:
                    # ëª¨ë“  ëŒ€í™” ì™„ë£Œ -> ë¬¸ì„œ ë¦¬ë·°
                    if len(self.documents) > 0:
                        self.phase = self.PHASE_DOC_REVIEW
                        self.phase_timer = 0.0
                        self.review_doc_index = 0
                        self.review_state = "arrange_all"  # ì¦‰ê° ì •ë ¬
                        self.review_progress = 0.0
                    else:
                        self.phase = self.PHASE_ZOOM_OUT
                        self.phase_timer = 0.0
            else:
                self.typing_progress = len(self.dialogue_text)
                self.waiting_for_click = True
            return True

        elif self.phase == self.PHASE_DOC_REVIEW:
            # ë¦¬ë·° ìŠ¤í‚µ (ì¦‰ê° ì •ë ¬ ì™„ë£Œ)
            self.review_progress = 1.0
            return True

        elif self.phase == self.PHASE_DOC_VIEW:
            return self._handle_doc_view_click(pygame.mouse.get_pos())

        return False

    def _handle_doc_view_click(self, mouse_pos):
        """ë¬¸ì„œ í™•ëŒ€ ë³´ê¸° í˜ì´ì¦ˆì—ì„œ í´ë¦­ ì²˜ë¦¬"""
        if self.view_state == "idle":
            # ë¬¸ì„œ í´ë¦­ í™•ì¸
            for i, rect in enumerate(self.doc_rects):
                if rect.collidepoint(mouse_pos):
                    # í•´ë‹¹ ë¬¸ì„œ í™•ëŒ€
                    self.viewing_doc_index = i
                    self.view_state = "zoom_in"
                    self.view_zoom_progress = 0.0
                    return True
            # ë¹ˆ ê³µê°„ í´ë¦­ - ì¤Œì•„ì›ƒìœ¼ë¡œ ì „í™˜
            self.phase = self.PHASE_ZOOM_OUT
            self.phase_timer = 0.0
            return True

        elif self.view_state == "viewing":
            # í™•ëŒ€ ë³´ê¸° ì¤‘ í´ë¦­ - ì¶•ì†Œ
            self.view_state = "zoom_out"
            return True

        elif self.view_state == "zoom_in":
            # í™•ëŒ€ ì¤‘ í´ë¦­ - ì¦‰ì‹œ í™•ëŒ€ ì™„ë£Œ
            self.view_zoom_progress = 1.0
            self.view_state = "viewing"
            return True

        elif self.view_state == "zoom_out":
            # ì¶•ì†Œ ì¤‘ í´ë¦­ - ì¦‰ì‹œ ì¶•ì†Œ ì™„ë£Œ
            self.view_zoom_progress = 0.0
            self.view_state = "idle"
            self.viewing_doc_index = -1
            return True

        return False

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        if self.phase == self.PHASE_ZOOM_IN:
            self._render_zoom_phase(screen)

        elif self.phase == self.PHASE_GATE_SEQUENCE:
            self._render_gate_sequence(screen)

        elif self.phase in [self.PHASE_CABINET_SHOW, self.PHASE_DIALOGUE, self.PHASE_DOC_REVIEW]:
            self._render_document_phase(screen)

        elif self.phase == self.PHASE_DOC_VIEW:
            self._render_doc_view_phase(screen)

        elif self.phase == self.PHASE_ZOOM_OUT:
            self._render_zoom_out_phase(screen)

    def _render_zoom_phase(self, screen: pygame.Surface):
        """ì¤Œì¸ í˜ì´ì¦ˆ ë Œë”ë§"""
        self._render_zoomed_background(screen)

        # ì–´ë‘ìš´ ì˜¤ë²„ë ˆì´ (ê±´ë¬¼ ë‚´ë¶€ë¡œ ë“¤ì–´ê°€ëŠ” ëŠë‚Œ)
        darkness = min(220, int((self.zoom_scale - 1.0) * 100))
        dark_overlay = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        dark_overlay.fill((0, 0, 0, darkness))
        screen.blit(dark_overlay, (0, 0))

    def _render_gate_sequence(self, screen: pygame.Surface):
        """gate ì´ë¯¸ì§€ ì‹œí€€ìŠ¤ ë Œë”ë§"""
        if not self.gate_images:
            screen.fill((30, 35, 40))
            return

        if self.gate_state == "display":
            # í˜„ì¬ ì´ë¯¸ì§€ë§Œ í‘œì‹œ
            if self.current_gate_index < len(self.gate_images):
                screen.blit(self.gate_images[self.current_gate_index], (0, 0))

        elif self.gate_state == "transition":
            # í¬ë¡œìŠ¤í˜ì´ë“œ ì „í™˜
            current_img = self.gate_images[self.current_gate_index] if self.current_gate_index < len(self.gate_images) else None
            next_idx = self.current_gate_index + 1
            next_img = self.gate_images[next_idx] if next_idx < len(self.gate_images) else None

            # ease-in-out ì „í™˜
            t = self.gate_transition_progress
            if t < 0.5:
                eased = 2 * t * t
            else:
                eased = 1 - ((-2 * t + 2) ** 2) / 2

            if current_img:
                current_img.set_alpha(int(255 * (1 - eased)))
                screen.blit(current_img, (0, 0))
                current_img.set_alpha(255)

            if next_img:
                next_img.set_alpha(int(255 * eased))
                screen.blit(next_img, (0, 0))
                next_img.set_alpha(255)

    def _render_document_phase(self, screen: pygame.Surface):
        """ë¬¸ì„œ í˜ì´ì¦ˆ (ìºë¹„ë‹›, ëŒ€í™”, ë¦¬ë·°) ë Œë”ë§"""
        screen_w, screen_h = self.screen_size

        # ì–´ë‘ìš´ ë°°ê²½
        screen.fill((25, 30, 35))

        # í˜ì´ë“œ ì˜¤ë²„ë ˆì´ (gateì—ì„œ ì „í™˜ ì‹œ)
        if self.fade_alpha > 0:
            fade_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
            fade_surf.fill((0, 0, 0, int(self.fade_alpha)))
            screen.blit(fade_surf, (0, 0))

        # ìºë¹„ë‹› ë Œë”ë§
        if self.cabinet_y_offset > 0:
            self._render_cabinet(screen)

        # ë¬¸ì„œ ë Œë”ë§
        if self.phase == self.PHASE_DIALOGUE:
            self._render_stacked_documents(screen)
        elif self.phase == self.PHASE_DOC_REVIEW:
            self._render_review_documents(screen)

        # ëŒ€í™” ë°•ìŠ¤
        if self.phase == self.PHASE_DIALOGUE:
            self._render_dialogue(screen)

        # ì§„í–‰ í‘œì‹œ
        if self.phase == self.PHASE_DIALOGUE and self.documents:
            self._render_progress(screen)

    def _render_zoom_out_phase(self, screen: pygame.Surface):
        """ì¤Œì•„ì›ƒ í˜ì´ì¦ˆ ë Œë”ë§"""
        self._render_zoomed_background(screen)

        # ë¬¸ì„œë“¤ í˜ì´ë“œ ì•„ì›ƒ
        progress = min(1.0, self.phase_timer / self.zoom_out_duration)
        if progress < 0.3:
            # ì´ˆë°˜ì—ëŠ” ë¬¸ì„œë“¤ì´ ë³´ì„
            doc_alpha = int(255 * (1 - progress / 0.3))
            self._render_final_documents(screen, doc_alpha)

    def _render_zoomed_background(self, screen: pygame.Surface):
        """ì¤Œëœ ë°°ê²½ ë Œë”ë§"""
        if not self.background_original:
            screen.fill((30, 35, 40))
            return

        screen_w, screen_h = self.screen_size

        zoom_w = screen_w / self.zoom_scale
        zoom_h = screen_h / self.zoom_scale

        center_x = screen_w * self.zoom_center_x
        center_y = screen_h * self.zoom_center_y

        src_x = max(0, center_x - zoom_w / 2)
        src_y = max(0, center_y - zoom_h / 2)

        if src_x + zoom_w > screen_w:
            src_x = screen_w - zoom_w
        if src_y + zoom_h > screen_h:
            src_y = screen_h - zoom_h

        src_rect = pygame.Rect(int(src_x), int(src_y), int(zoom_w), int(zoom_h))

        try:
            zoomed = self.background_original.subsurface(src_rect)
            zoomed = pygame.transform.smoothscale(zoomed, self.screen_size)
            screen.blit(zoomed, (0, 0))
        except:
            screen.blit(self.background_original, (0, 0))

    def _render_cabinet(self, screen: pygame.Surface):
        """ìºë¹„ë‹› ë Œë”ë§"""
        if not self.cabinet_image:
            return

        screen_w, screen_h = self.screen_size
        cab_w, cab_h = self.cabinet_image.get_size()

        cab_x = screen_w // 2 - cab_w // 2
        cab_y_base = screen_h - cab_h + 30
        cab_y_hidden = screen_h + 50
        cab_y = cab_y_hidden + (cab_y_base - cab_y_hidden) * self.cabinet_y_offset

        screen.blit(self.cabinet_image, (cab_x, int(cab_y)))

    def _render_stacked_documents(self, screen: pygame.Surface):
        """ìŒ“ì´ëŠ” ë¬¸ì„œë“¤ ë Œë”ë§"""
        screen_w, screen_h = self.screen_size

        for i, doc in enumerate(self.documents):
            if not doc['visible']:
                continue

            img = doc['image']
            img_w, img_h = img.get_size()

            base_x = screen_w // 2
            base_y = screen_h // 2 - 80

            if i == self.current_doc_index:
                # í˜„ì¬ ë¬¸ì„œ: ì†Ÿì•„ì˜¤ë¥´ëŠ” ì• ë‹ˆë©”ì´ì…˜
                rise_eased = 1.0 - (1.0 - self.doc_rise_progress) ** 3
                start_y = screen_h + img_h // 2
                doc_y = start_y + (base_y - start_y) * rise_eased
                alpha = int(255 * rise_eased)
                # ì•½ê°„ ê¸°ìš¸ì„
                angle = (1 - rise_eased) * 10
            else:
                # ì´ì „ ë¬¸ì„œë“¤: ë’¤ë¡œ ìŒ“ì„
                stack_offset = (self.current_doc_index - i)
                doc_y = base_y - stack_offset * 25
                # ì¢Œìš°ë¡œ ì•½ê°„ ì–´ê¸‹ë‚˜ê²Œ
                offset_x = (stack_offset % 2) * 30 - 15
                base_x += offset_x
                alpha = max(100, 255 - stack_offset * 40)
                angle = (stack_offset % 3 - 1) * 3

            img_copy = img.copy()
            if angle != 0:
                img_copy = pygame.transform.rotate(img_copy, angle)
            img_copy.set_alpha(alpha)

            rect = img_copy.get_rect(center=(base_x, int(doc_y)))
            screen.blit(img_copy, rect)

    def _render_review_documents(self, screen: pygame.Surface):
        """ë¬¸ì„œë“¤ ì¦‰ê° ì •ë ¬ ë Œë”ë§ (ì• ë‹ˆë©”ì´ì…˜ í¬í•¨)"""
        screen_w, screen_h = self.screen_size

        # ì •ë ¬ ì§„í–‰ë„ (0 -> 1)
        t = min(1.0, self.review_progress)
        eased = 1.0 - (1.0 - t) ** 2  # ease-out

        for i, doc in enumerate(self.documents):
            if not doc['visible']:
                continue

            img = doc['image']
            orig_w, orig_h = img.get_size()

            if i < len(self.doc_final_positions):
                pos = self.doc_final_positions[i]

                # ì‹œì‘ ìœ„ì¹˜ (ìŠ¤íƒ ìœ„ì¹˜)
                start_x = screen_w // 2 + (i % 2 - 0.5) * 30
                start_y = screen_h // 2 - 80 + i * 15
                start_scale = 1.0

                # ìµœì¢… ìœ„ì¹˜
                end_x = pos['x']
                end_y = pos['y']
                end_scale = pos['scale']

                # ë³´ê°„
                cur_x = start_x + (end_x - start_x) * eased
                cur_y = start_y + (end_y - start_y) * eased
                cur_scale = start_scale + (end_scale - start_scale) * eased

                new_w = int(orig_w * cur_scale)
                new_h = int(orig_h * cur_scale)
                scaled_img = pygame.transform.smoothscale(img, (new_w, new_h))
                rect = scaled_img.get_rect(center=(int(cur_x), int(cur_y)))
                screen.blit(scaled_img, rect)

    def _render_doc_view_phase(self, screen: pygame.Surface):
        """ë¬¸ì„œ í™•ëŒ€ ë³´ê¸° í˜ì´ì¦ˆ ë Œë”ë§"""
        screen_w, screen_h = self.screen_size

        # ì–´ë‘ìš´ ë°°ê²½
        screen.fill((25, 30, 35))

        # ìºë¹„ë‹› (ì–´ë‘¡ê²Œ)
        if self.cabinet_image:
            cab_w, cab_h = self.cabinet_image.get_size()
            cab_x = screen_w // 2 - cab_w // 2
            cab_y = screen_h - cab_h + 30
            dark_cab = self.cabinet_image.copy()
            dark_cab.set_alpha(80)
            screen.blit(dark_cab, (cab_x, cab_y))

        # í™•ëŒ€ ë³´ê¸° ì¤‘ì´ë©´ ë°°ê²½ ì–´ë‘¡ê²Œ
        if self.viewing_doc_index >= 0:
            dark_overlay = pygame.Surface(self.screen_size, pygame.SRCALPHA)
            alpha = int(180 * self.view_zoom_progress)
            dark_overlay.fill((0, 0, 0, alpha))
            screen.blit(dark_overlay, (0, 0))

        # ì •ë ¬ëœ ë¬¸ì„œë“¤ ë Œë”ë§
        mouse_pos = pygame.mouse.get_pos()
        for i, doc in enumerate(self.documents):
            if not doc['visible']:
                continue
            if i >= len(self.doc_final_positions):
                continue

            img = doc['image']
            orig_w, orig_h = img.get_size()
            pos = self.doc_final_positions[i]

            # í™•ëŒ€ ë³´ê¸° ì¤‘ì¸ ë¬¸ì„œ ì²˜ë¦¬
            if i == self.viewing_doc_index:
                # í™•ëŒ€ ì• ë‹ˆë©”ì´ì…˜
                t = self.view_zoom_progress
                eased = 1.0 - (1.0 - t) ** 2  # ease-out

                # ì‹œì‘: ì •ë ¬ ìœ„ì¹˜
                start_x, start_y = pos['x'], pos['y']
                start_scale = pos['scale']

                # ë: í™”ë©´ ì¤‘ì•™, ê±°ì˜ ì „ì²´í™”ë©´
                end_x, end_y = screen_w // 2, screen_h // 2
                end_scale = min(screen_w * 0.85 / orig_w, screen_h * 0.85 / orig_h)

                cur_x = start_x + (end_x - start_x) * eased
                cur_y = start_y + (end_y - start_y) * eased
                cur_scale = start_scale + (end_scale - start_scale) * eased

                new_w = int(orig_w * cur_scale)
                new_h = int(orig_h * cur_scale)
                scaled_img = pygame.transform.smoothscale(img, (new_w, new_h))
                rect = scaled_img.get_rect(center=(int(cur_x), int(cur_y)))
                screen.blit(scaled_img, rect)
            else:
                # ë‹¤ë¥¸ ë¬¸ì„œë“¤ (í™•ëŒ€ ë³´ê¸° ì¤‘ì´ë©´ ìˆ¨ê¹€)
                if self.viewing_doc_index >= 0:
                    continue

                scale = pos['scale']
                new_w = int(orig_w * scale)
                new_h = int(orig_h * scale)
                scaled_img = pygame.transform.smoothscale(img, (new_w, new_h))
                rect = scaled_img.get_rect(center=(int(pos['x']), int(pos['y'])))

                # í˜¸ë²„ íš¨ê³¼
                if i < len(self.doc_rects) and self.doc_rects[i].collidepoint(mouse_pos):
                    # í˜¸ë²„ ì‹œ ë°ê²Œ + í…Œë‘ë¦¬
                    pygame.draw.rect(screen, (100, 120, 140), rect.inflate(8, 8), 3, border_radius=5)
                    scaled_img.set_alpha(255)
                else:
                    scaled_img.set_alpha(220)

                screen.blit(scaled_img, rect)

        # ì•ˆë‚´ í…ìŠ¤íŠ¸
        if self.viewing_doc_index < 0 and "small" in self.fonts:
            hint_text = "í´ë¦­í•˜ì—¬ ë¬¸ì„œ í™•ëŒ€ | ë¹ˆ ê³µê°„ í´ë¦­í•˜ì—¬ ê³„ì†"
            hint_surf = self.fonts["small"].render(hint_text, True, (150, 160, 170))
            hint_rect = hint_surf.get_rect(center=(screen_w // 2, screen_h - 40))
            screen.blit(hint_surf, hint_rect)
        elif self.viewing_doc_index >= 0 and self.view_state == "viewing" and "small" in self.fonts:
            hint_text = "í´ë¦­í•˜ì—¬ ë‹«ê¸°"
            hint_surf = self.fonts["small"].render(hint_text, True, (200, 210, 220))
            hint_rect = hint_surf.get_rect(center=(screen_w // 2, screen_h - 40))
            screen.blit(hint_surf, hint_rect)

    def _render_final_documents(self, screen: pygame.Surface, alpha: int):
        """ìµœì¢… ì •ë ¬ëœ ë¬¸ì„œë“¤ ë Œë”ë§ (í˜ì´ë“œ ì•„ì›ƒìš©)"""
        for i, doc in enumerate(self.documents):
            if not doc['visible']:
                continue

            img = doc['image']
            orig_w, orig_h = img.get_size()

            if i < len(self.doc_final_positions):
                pos = self.doc_final_positions[i]
                scale = pos['scale']
                new_w = int(orig_w * scale)
                new_h = int(orig_h * scale)
                scaled_img = pygame.transform.smoothscale(img, (new_w, new_h))
                scaled_img.set_alpha(alpha)
                rect = scaled_img.get_rect(center=(int(pos['x']), int(pos['y'])))
                screen.blit(scaled_img, rect)

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€í™” ë°•ìŠ¤ ë Œë”ë§ (ì´ˆìƒí™” í¬í•¨)"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None
        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(20, 30, 40, 220), border_color=(80, 100, 80),
                           has_portrait=(portrait is not None), portrait=portrait)

    def _get_portrait(self, speaker: str) -> pygame.Surface:
        """ì´ˆìƒí™” ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸° (ìºì‹œ ì‚¬ìš©)"""
        if speaker in self.portrait_cache:
            return self.portrait_cache[speaker]

        try:
            from mode_configs.config_story_dialogue import CHARACTER_PORTRAITS
            path = CHARACTER_PORTRAITS.get(speaker)
        except ImportError:
            path = None

        if path:
            try:
                img = pygame.image.load(path).convert_alpha()
                target_size = (120, 120)
                img = pygame.transform.smoothscale(img, target_size)
                self.portrait_cache[speaker] = img
                return img
            except Exception as e:
                print(f"WARNING: Failed to load portrait for {speaker}: {e}")

        return None

    def _render_progress(self, screen: pygame.Surface):
        """ì§„í–‰ ìƒíƒœ í‘œì‹œ"""
        if "small" not in self.fonts:
            return

        total = len(self.documents)
        current = max(1, self.current_doc_index + 1)
        progress_text = f"ë¬¸ì„œ {current} / {total}"

        hint_surf = self.fonts["small"].render(progress_text, True, (150, 150, 150))
        screen.blit(hint_surf, (50, 30))


# =========================================================
# Act 3: ì†ìƒëœ í™€ë¡œê·¸ë¨ íš¨ê³¼
# =========================================================
# Act 3: ë¶ˆê½ƒ ì† ê¸°ë¡ íš¨ê³¼ (íƒ€ë“¤ì–´ê°€ëŠ” ì‚¬ì§„/ë¬¸ì„œ)
# =========================================================
class BurningRecordEffect:
    """
    Act 3 ì»·ì”¬: ë¶ˆê½ƒ ì† ê¸°ë¡ íš¨ê³¼

    íŠ¹ì§•:
    - ì–´ë‘ìš´ ë°°ê²½ì— ë¶ˆê½ƒ íŒŒí‹°í´
    - í° ì´ë¯¸ì§€ê°€ ê°€ì¥ìë¦¬ë¶€í„° íƒ€ë“¤ì–´ê°
    - íƒ€ëŠ” ì• ë‹ˆë©”ì´ì…˜ê³¼ í•¨ê»˜ ì´ë¯¸ì§€ ì „í™˜
    - ì—°êµ¬ì†Œ í™”ì¬ í…Œë§ˆì— ë§ëŠ” ë¶„ìœ„ê¸°
    """

    PHASE_FADEIN = 0
    PHASE_DISPLAY = 1         # ì´ë¯¸ì§€ + ëŒ€í™” ë™ì‹œ í‘œì‹œ
    PHASE_BURNING = 2         # íƒ€ë“¤ì–´ê°€ëŠ” ì• ë‹ˆë©”ì´ì…˜
    PHASE_FADEOUT = 3
    PHASE_DONE = 4

    def __init__(self, screen_size: tuple, film_paths: list,
                 background_path: str = None, dialogue_after: list = None,
                 sound_manager=None, special_effects: dict = None,
                 scene_id: str = "burning_scene"):
        self.screen_size = screen_size
        self.film_paths = film_paths
        self.background_path = background_path
        self.dialogue_after = dialogue_after or []
        self.sound_manager = sound_manager
        self.special_effects = special_effects or {}
        self.scene_id = scene_id

        self.is_alive = True
        self.phase = self.PHASE_FADEIN
        self.phase_timer = 0.0

        # íƒ€ì´ë°
        self.fadein_duration = 1.5
        self.fadeout_duration = 1.5
        self.fade_alpha = 0.0
        self.burn_duration = 2.0  # íƒ€ë“¤ì–´ê°€ëŠ” ì‹œê°„

        # ë°°ê²½
        self.background = None
        self._load_background(background_path)

        # ì´ë¯¸ì§€ í¬ê¸° (í™”ë©´ì˜ 40% - ì¤‘ê°„ í¬ê¸°, í©ì–´ì§„ ë°°ì¹˜)
        screen_w, screen_h = self.screen_size
        self.img_width = int(screen_w * 0.40)
        self.img_height = int(screen_h * 0.50)

        # ì´ë¯¸ì§€ë“¤
        self.records = []
        self._prepare_records()

        # í˜„ì¬ ì´ë¯¸ì§€ ì¸ë±ìŠ¤
        self.current_record_index = 0

        # í©ì–´ì§„ ë°°ì¹˜ ìœ„ì¹˜ (í´ë¼ë¡œì´ë“œì²˜ëŸ¼)
        self.scatter_positions = []
        self._setup_scatter_positions()

        # íƒ€ë“¤ì–´ê°€ëŠ” íš¨ê³¼
        self.burn_progress = 0.0  # 0~1 (ì–¼ë§ˆë‚˜ íƒ”ëŠ”ì§€)
        self.burn_mask = None
        self._create_burn_mask()

        # ë¶ˆê½ƒ íŒŒí‹°í´
        self.fire_particles = []
        self.ember_particles = []  # ë¶ˆì”¨/ì¬

        # ëŒ€ì‚¬ ê´€ë ¨
        self.current_dialogue_index = 0
        self.dialogue_text = ""
        self.typing_progress = 0.0
        self.typing_speed = 25.0
        self.waiting_for_click = False
        self.dialogue_complete = False

        # í°íŠ¸
        self.fonts = {}

        # ì½œë°±
        self.on_complete = None
        self.on_replay_request = None

        # ì´ë¯¸ì§€ì™€ ëŒ€í™” ë§¤í•‘
        self._setup_dialogue_per_image()

        print(f"INFO: BurningRecordEffect created with {len(self.records)} records")

    def _load_background(self, path: str):
        """ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ - ì–´ë‘ìš´ ë¶ˆíƒ€ëŠ” ë°°ê²½"""
        try:
            if path:
                img = pygame.image.load(path).convert()
                img = pygame.transform.scale(img, self.screen_size)
                # ì–´ë‘¡ê²Œ + ë¶‰ì€ í†¤
                overlay = pygame.Surface(self.screen_size, pygame.SRCALPHA)
                overlay.fill((40, 10, 5, 180))
                img.blit(overlay, (0, 0))
                self.background = img
            else:
                raise Exception("No path")
        except Exception as e:
            # ê¸°ë³¸ ì–´ë‘ìš´ ë°°ê²½
            self.background = pygame.Surface(self.screen_size)
            self.background.fill((20, 8, 5))

    def _prepare_records(self):
        """ì´ë¯¸ì§€ ì¤€ë¹„ - ì•„ì£¼ í¬ê²Œ"""
        for path in self.film_paths:
            record_img = None
            try:
                record_img = pygame.image.load(path).convert_alpha()
                orig_w, orig_h = record_img.get_size()
                # ê½‰ ì°¨ê²Œ í™•ëŒ€
                ratio = max(self.img_width / orig_w, self.img_height / orig_h)
                new_w, new_h = int(orig_w * ratio), int(orig_h * ratio)
                record_img = pygame.transform.smoothscale(record_img, (new_w, new_h))
                # ì¤‘ì•™ í¬ë¡­
                crop_x = (new_w - self.img_width) // 2
                crop_y = (new_h - self.img_height) // 2
                cropped = pygame.Surface((self.img_width, self.img_height), pygame.SRCALPHA)
                cropped.blit(record_img, (-crop_x, -crop_y))
                record_img = cropped
            except Exception as e:
                print(f"WARNING: Failed to load record: {path} - {e}")
                record_img = pygame.Surface((self.img_width, self.img_height), pygame.SRCALPHA)
                record_img.fill((80, 70, 60, 200))

            filename = Path(path).name
            effect_info = self.special_effects.get(filename, {})

            self.records.append({
                'image': record_img,
                'filename': filename,
                'effect': effect_info.get('effect', None),
            })

    def _setup_scatter_positions(self):
        """í´ë¼ë¡œì´ë“œì²˜ëŸ¼ í©ì–´ì§„ ë°°ì¹˜ ìœ„ì¹˜ ì„¤ì •"""
        screen_w, screen_h = self.screen_size
        center_x, center_y = screen_w // 2, screen_h // 2

        # ê° ì´ë¯¸ì§€ì˜ ìœ„ì¹˜, íšŒì „, ìŠ¤ì¼€ì¼ ì„¤ì •
        num_records = len(self.records)
        for _ in range(num_records):
            # í™”ë©´ ì¤‘ì•™ ê·¼ì²˜ì—ì„œ ì•½ê°„ì”© í©ì–´ì§„ ìœ„ì¹˜
            offset_x = random.randint(-150, 150)
            offset_y = random.randint(-100, 100)
            x = center_x - self.img_width // 2 + offset_x
            y = center_y - self.img_height // 2 + offset_y

            # ì•½ê°„ì˜ íšŒì „ (-15 ~ +15ë„)
            rotation = random.uniform(-15, 15)

            self.scatter_positions.append({
                'x': x,
                'y': y,
                'rotation': rotation,
                'offset_x': offset_x,
                'offset_y': offset_y,
            })

    def _create_burn_mask(self):
        """íƒ€ë“¤ì–´ê°€ëŠ” ë§ˆìŠ¤í¬ ìƒì„± (ê°€ì¥ìë¦¬ë¶€í„° ì•ˆìª½ìœ¼ë¡œ)"""
        # ê°„ë‹¨í•œ ë§ˆìŠ¤í¬ë§Œ ìƒì„± (ì‹¤ì œ í”½ì…€ ë‹¨ìœ„ëŠ” ì„±ëŠ¥ ì´ìŠˆë¡œ ìƒëµ)
        self.burn_mask = None  # ì˜¤ë²„ë ˆì´ ë°©ì‹ ì‚¬ìš©

    def _setup_dialogue_per_image(self):
        """ì´ë¯¸ì§€ë‹¹ ëŒ€í™” ìˆ˜ ê³„ì‚°"""
        num_images = len(self.records)
        num_dialogues = len(self.dialogue_after)
        if num_images == 0:
            self.dialogues_per_image = 0
        else:
            self.dialogues_per_image = max(1, (num_dialogues + num_images - 1) // num_images)

    def set_fonts(self, fonts: dict):
        self.fonts = fonts

    def update(self, dt: float):
        if not self.is_alive:
            return

        self.phase_timer += dt

        # ë¶ˆê½ƒ íŒŒí‹°í´ ì—…ë°ì´íŠ¸ (ë¹„í™œì„±í™”)
        # self._update_particles(dt)

        if self.phase == self.PHASE_FADEIN:
            self.fade_alpha = min(255, (self.phase_timer / self.fadein_duration) * 255)
            if self.phase_timer >= self.fadein_duration:
                self.phase = self.PHASE_DISPLAY
                self.phase_timer = 0.0
                self._start_dialogue()

        elif self.phase == self.PHASE_DISPLAY:
            self._update_dialogue(dt)

        elif self.phase == self.PHASE_BURNING:
            # íƒ€ë“¤ì–´ê°€ëŠ” ì§„í–‰
            self.burn_progress = min(1.0, self.phase_timer / self.burn_duration)
            # ë¶ˆê½ƒ íŒŒí‹°í´ ë¹„í™œì„±í™”
            # self._spawn_fire_particles(5)

            if self.burn_progress >= 1.0:
                # ë‹¤ìŒ ì´ë¯¸ì§€ë¡œ ì „í™˜
                self.current_record_index += 1
                self.burn_progress = 0.0
                self.phase_timer = 0.0

                if self.current_record_index >= len(self.records):
                    self.phase = self.PHASE_FADEOUT
                else:
                    self.phase = self.PHASE_DISPLAY
                    self._start_dialogue()

        elif self.phase == self.PHASE_FADEOUT:
            progress = self.phase_timer / self.fadeout_duration
            self.fade_alpha = 255 * (1.0 - progress)
            if self.phase_timer >= self.fadeout_duration:
                self.phase = self.PHASE_DONE
                self.is_alive = False
                if self.on_complete:
                    self.on_complete()

    def _update_particles(self, dt: float):
        """íŒŒí‹°í´ ì—…ë°ì´íŠ¸"""
        # ê¸°ë³¸ ë¶ˆê½ƒ íŒŒí‹°í´ ìƒì„±
        if self.phase in [self.PHASE_DISPLAY, self.PHASE_BURNING]:
            if random.random() < 0.3:
                self._spawn_fire_particles(1)

        # íŒŒí‹°í´ ì´ë™ ë° ì†Œë©¸
        for p in self.fire_particles[:]:
            p['y'] -= p['speed'] * dt
            p['life'] -= dt
            p['x'] += random.uniform(-30, 30) * dt
            if p['life'] <= 0:
                self.fire_particles.remove(p)

        for p in self.ember_particles[:]:
            p['y'] -= p['speed'] * dt * 0.5
            p['x'] += random.uniform(-50, 50) * dt
            p['life'] -= dt
            if p['life'] <= 0:
                self.ember_particles.remove(p)

    def _spawn_fire_particles(self, count: int):
        """ë¶ˆê½ƒ íŒŒí‹°í´ ìƒì„± (í˜„ì¬ ì´ë¯¸ì§€ ìœ„ì¹˜ ê¸°ì¤€)"""
        if self.current_record_index >= len(self.scatter_positions):
            return

        pos = self.scatter_positions[self.current_record_index]
        img_x = pos['x']
        img_y = pos['y']

        for _ in range(count):
            # ì´ë¯¸ì§€ ê°€ì¥ìë¦¬ ê·¼ì²˜ì—ì„œ ìƒì„±
            edge = random.choice(['top', 'bottom', 'left', 'right'])
            if edge == 'top':
                x = img_x + random.randint(0, self.img_width)
                y = img_y
            elif edge == 'bottom':
                x = img_x + random.randint(0, self.img_width)
                y = img_y + self.img_height
            elif edge == 'left':
                x = img_x
                y = img_y + random.randint(0, self.img_height)
            else:
                x = img_x + self.img_width
                y = img_y + random.randint(0, self.img_height)

            self.fire_particles.append({
                'x': x,
                'y': y,
                'speed': random.uniform(80, 200),
                'size': random.randint(3, 12),
                'life': random.uniform(0.5, 1.5),
                'color': random.choice([
                    (255, 200, 50),   # ë°ì€ ë…¸ë‘
                    (255, 150, 30),   # ì£¼í™©
                    (255, 100, 20),   # ì§„í•œ ì£¼í™©
                    (255, 60, 10),    # ë¹¨ê°•-ì£¼í™©
                ])
            })

            # ë¶ˆì”¨ë„ ìƒì„±
            if random.random() < 0.3:
                self.ember_particles.append({
                    'x': x + random.randint(-20, 20),
                    'y': y,
                    'speed': random.uniform(30, 80),
                    'size': random.randint(1, 3),
                    'life': random.uniform(1.0, 3.0),
                })

    def _start_dialogue(self):
        """í˜„ì¬ ëŒ€í™” ì‹œì‘"""
        if self.current_dialogue_index < len(self.dialogue_after):
            self.dialogue_text = self.dialogue_after[self.current_dialogue_index].get("text", "")
            self.typing_progress = 0.0
            self.waiting_for_click = False
            self.dialogue_complete = False
        else:
            self.dialogue_complete = True

    def _update_dialogue(self, dt: float):
        """ëŒ€ì‚¬ ì—…ë°ì´íŠ¸"""
        if self.current_dialogue_index >= len(self.dialogue_after):
            self.dialogue_complete = True
            return

        if not self.waiting_for_click:
            self.typing_progress += dt * self.typing_speed
            if self.typing_progress >= len(self.dialogue_text):
                self.typing_progress = len(self.dialogue_text)
                self.waiting_for_click = True

    def _advance_to_next(self):
        """ë‹¤ìŒ ëŒ€í™”/ì´ë¯¸ì§€ë¡œ ì§„í–‰"""
        self.current_dialogue_index += 1

        # ì¼ì • ëŒ€í™”ë§ˆë‹¤ íƒ€ë“¤ì–´ê°€ê¸° ì‹œì‘
        if self.dialogues_per_image > 0:
            expected_image = self.current_dialogue_index // self.dialogues_per_image
            if expected_image > self.current_record_index and self.current_record_index < len(self.records) - 1:
                self.phase = self.PHASE_BURNING
                self.phase_timer = 0.0
                self.burn_progress = 0.0
                return

        if self.current_dialogue_index < len(self.dialogue_after):
            self._start_dialogue()
        else:
            self.dialogue_complete = True
            if self.current_record_index >= len(self.records) - 1:
                self.phase = self.PHASE_FADEOUT
                self.phase_timer = 0.0

    def handle_event(self, event: pygame.event.Event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if self.phase == self.PHASE_DISPLAY:
                if self.waiting_for_click:
                    self._advance_to_next()
                else:
                    self.typing_progress = len(self.dialogue_text)
                    self.waiting_for_click = True
                return True

        elif event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_SPACE, pygame.K_RETURN]:
                return self.handle_event(pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1))

        return False

    def render(self, screen: pygame.Surface):
        # ë°°ê²½
        if self.background:
            bg_copy = self.background.copy()
            if self.fade_alpha < 255:
                bg_copy.set_alpha(int(self.fade_alpha))
            screen.blit(bg_copy, (0, 0))

        # ì´ë¯¸ì§€ ë Œë”ë§
        if self.phase in [self.PHASE_DISPLAY, self.PHASE_BURNING]:
            self._render_burning_record(screen)

        # ë¶ˆê½ƒ íŒŒí‹°í´ (ë¹„í™œì„±í™”)
        # self._render_particles(screen)

        # ë¹„ë„¤íŠ¸ (ì–´ë‘ìš´ ê°€ì¥ìë¦¬)
        self._render_vignette(screen)

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DISPLAY:
            self._render_dialogue(screen)

    def _render_burning_record(self, screen: pygame.Surface):
        """íƒ€ë“¤ì–´ê°€ëŠ” ê¸°ë¡ ì´ë¯¸ì§€ ë Œë”ë§ (í´ë¼ë¡œì´ë“œì²˜ëŸ¼ í©ì–´ì§„ ë°°ì¹˜)"""
        if self.current_record_index >= len(self.records):
            return

        # í˜„ì¬ ì´ë¯¸ì§€ì˜ í©ì–´ì§„ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
        pos = self.scatter_positions[self.current_record_index]
        img_x = pos['x']
        img_y = pos['y']
        rotation = pos['rotation']

        record = self.records[self.current_record_index]
        img = record['image'].copy()

        # íƒ€ë“¤ì–´ê°€ëŠ” íš¨ê³¼ ì ìš©
        if self.phase == self.PHASE_BURNING and self.burn_progress > 0:
            self._apply_burn_effect(img)

        # í…Œë‘ë¦¬ê°€ ìˆëŠ” ì‚¬ì§„ ì„œí”¼ìŠ¤ ìƒì„± (íƒ„ ì¢…ì´ ëŠë‚Œ)
        border_size = 15
        photo_surf = pygame.Surface((self.img_width + border_size * 2, self.img_height + border_size * 2), pygame.SRCALPHA)

        # íƒ„ ì¢…ì´ í…Œë‘ë¦¬ (ë¶ˆê·œì¹™í•œ ê°ˆìƒ‰)
        pygame.draw.rect(photo_surf, (70, 50, 35, 230), (0, 0, photo_surf.get_width(), photo_surf.get_height()), border_radius=3)
        # íƒ„ ìêµ­ í…Œë‘ë¦¬
        pygame.draw.rect(photo_surf, (40, 25, 15, 200), (0, 0, photo_surf.get_width(), photo_surf.get_height()), 3, border_radius=3)

        # ì´ë¯¸ì§€ ë°°ì¹˜
        photo_surf.blit(img, (border_size, border_size))

        # íšŒì „ ì ìš©
        if rotation != 0:
            photo_surf = pygame.transform.rotate(photo_surf, rotation)

        # í˜ì´ë“œ ì ìš©
        if self.fade_alpha < 255:
            photo_surf.set_alpha(int(self.fade_alpha))

        # íšŒì „ í›„ ì¤‘ì•™ ì •ë ¬ì„ ìœ„í•œ ìœ„ì¹˜ ì¡°ì •
        rotated_rect = photo_surf.get_rect(center=(img_x + self.img_width // 2, img_y + self.img_height // 2))
        screen.blit(photo_surf, rotated_rect)

        # íƒ€ëŠ” ì¤‘ì´ë©´ ê°€ì¥ìë¦¬ì— ë¹›ë‚˜ëŠ” íš¨ê³¼
        if self.phase == self.PHASE_BURNING:
            self._render_burning_edge(screen, rotated_rect.x, rotated_rect.y, photo_surf.get_width(), photo_surf.get_height())

    def _apply_burn_effect(self, img: pygame.Surface):
        """ì´ë¯¸ì§€ì— íƒ€ë“¤ì–´ê°€ëŠ” íš¨ê³¼ ì ìš©"""
        # ê°„ë‹¨í•œ êµ¬í˜„: ê°€ì¥ìë¦¬ë¶€í„° íˆ¬ëª…í•˜ê²Œ
        w, h = img.get_size()
        center_x, center_y = w // 2, h // 2
        max_dist = math.sqrt(center_x**2 + center_y**2)

        # burn_progressì— ë”°ë¼ ì–¼ë§ˆë‚˜ íƒ”ëŠ”ì§€
        burn_radius = max_dist * (1.0 - self.burn_progress)

        # í”½ì…€ ë‹¨ìœ„ ì²˜ë¦¬ëŠ” ëŠë¦¬ë¯€ë¡œ ì˜¤ë²„ë ˆì´ë¡œ í‘œí˜„
        burn_overlay = pygame.Surface((w, h), pygame.SRCALPHA)

        # íƒ„ ì˜ì—­ (ê²€ì€ìƒ‰ + íˆ¬ëª…)
        for i in range(20):  # ì—¬ëŸ¬ ì›ìœ¼ë¡œ ê·¸ë¼ë°ì´ì…˜
            radius = int(burn_radius + i * 10)
            alpha = int(min(255, (i / 20) * 255 * self.burn_progress))
            color = (20, 10, 5, alpha)
            pygame.draw.circle(burn_overlay, color, (center_x, center_y), radius, 5)

        # ê°€ì¥ìë¦¬ì— ì£¼í™©/ë¹¨ê°„ ë¶ˆê½ƒ ìƒ‰
        edge_radius = int(burn_radius)
        if edge_radius > 10:
            pygame.draw.circle(burn_overlay, (255, 100, 30, 100), (center_x, center_y), edge_radius + 5, 8)
            pygame.draw.circle(burn_overlay, (255, 200, 50, 80), (center_x, center_y), edge_radius + 2, 4)

        img.blit(burn_overlay, (0, 0))

    def _render_burning_edge(self, screen: pygame.Surface, img_x: int, img_y: int, width: int = None, height: int = None):
        """íƒ€ëŠ” ê°€ì¥ìë¦¬ ë¹› íš¨ê³¼"""
        w = width or self.img_width
        h = height or self.img_height
        center_x = img_x + w // 2
        center_y = img_y + h // 2
        max_dist = math.sqrt((w // 2)**2 + (h // 2)**2)
        burn_radius = int(max_dist * (1.0 - self.burn_progress))

        glow_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        # ë¹›ë‚˜ëŠ” ì› (ë¶ˆê½ƒ ìƒ‰)
        for i in range(5):
            alpha = 40 - i * 7
            pygame.draw.circle(glow_surf, (255, 150, 50, max(0, alpha)), (center_x, center_y), burn_radius + i * 15, 4)

        screen.blit(glow_surf, (0, 0), special_flags=pygame.BLEND_RGBA_ADD)

    def _render_particles(self, screen: pygame.Surface):
        """íŒŒí‹°í´ ë Œë”ë§"""
        for p in self.fire_particles:
            alpha = int(255 * (p['life'] / 1.5))
            color = (*p['color'][:3], min(255, alpha))
            surf = pygame.Surface((p['size'] * 2, p['size'] * 2), pygame.SRCALPHA)
            pygame.draw.circle(surf, color, (p['size'], p['size']), p['size'])
            screen.blit(surf, (int(p['x'] - p['size']), int(p['y'] - p['size'])), special_flags=pygame.BLEND_RGBA_ADD)

        for p in self.ember_particles:
            alpha = int(200 * (p['life'] / 3.0))
            color = (255, 180, 100, min(255, alpha))
            surf = pygame.Surface((p['size'] * 2, p['size'] * 2), pygame.SRCALPHA)
            pygame.draw.circle(surf, color, (p['size'], p['size']), p['size'])
            screen.blit(surf, (int(p['x'] - p['size']), int(p['y'] - p['size'])))

    def _render_vignette(self, screen: pygame.Surface):
        """ë¹„ë„¤íŠ¸ íš¨ê³¼ (ë¶‰ì€ í†¤)"""
        vignette = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        screen_w, screen_h = self.screen_size
        center_x, center_y = screen_w // 2, screen_h // 2
        max_dist = math.sqrt(center_x**2 + center_y**2)

        # ê°€ì¥ìë¦¬ ì–´ë‘¡ê²Œ + ë¶‰ì€ í†¤
        for i in range(10):
            radius = int(max_dist * (1.0 - i * 0.08))
            alpha = i * 15
            pygame.draw.circle(vignette, (30, 10, 5, alpha), (center_x, center_y), radius, 50)

        screen.blit(vignette, (0, 0))

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€ì‚¬ ë°•ìŠ¤ ë Œë”ë§ (ì´ˆìƒí™” í¬í•¨)"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            if self.dialogue_complete and self.current_record_index < len(self.records) - 1:
                self._render_hint(screen, "í´ë¦­í•˜ì—¬ ë‹¤ìŒ ê¸°ë¡")
            elif self.dialogue_complete:
                self._render_hint(screen, "í´ë¦­í•˜ì—¬ ê³„ì†")
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None
        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(30, 15, 10, 220), border_color=(150, 80, 40, 150),
                           text_color=(255, 240, 220), box_height=160,
                           has_portrait=(portrait is not None), portrait=portrait)

    def _get_portrait(self, speaker: str) -> pygame.Surface:
        """ì´ˆìƒí™” ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸° (ìºì‹œ ì‚¬ìš©)"""
        if speaker in self.portrait_cache:
            return self.portrait_cache[speaker]

        try:
            from mode_configs.config_story_dialogue import CHARACTER_PORTRAITS
            path = CHARACTER_PORTRAITS.get(speaker)
        except ImportError:
            path = None

        if path:
            try:
                img = pygame.image.load(path).convert_alpha()
                target_size = (120, 120)
                img = pygame.transform.smoothscale(img, target_size)
                self.portrait_cache[speaker] = img
                return img
            except Exception as e:
                print(f"WARNING: Failed to load portrait for {speaker}: {e}")

        return None

    def _render_hint(self, screen: pygame.Surface, text: str):
        if "small" not in self.fonts:
            return
        hint_surf = self.fonts["small"].render(text, True, (255, 200, 150))
        x = self.screen_size[0] // 2 - hint_surf.get_width() // 2
        y = self.screen_size[1] - 50
        screen.blit(hint_surf, (x, y))


# DamagedHologramEffectëŠ” BurningRecordEffectì˜ ë³„ì¹­ìœ¼ë¡œ ìœ ì§€ (í˜¸í™˜ì„±)
DamagedHologramEffect = BurningRecordEffect


# =========================================================
# Act 3: í•„ë¦„ ë¦´ íš¨ê³¼ - ì´ë¯¸ì§€ ì›ë³¸ ìƒ‰ìƒ 100% ìœ ì§€
# =========================================================
class FilmReelEffect:
    """
    Act 3 ì»·ì”¬: í•„ë¦„ ë¦´ íš¨ê³¼

    íŠ¹ì§•:
    - ì´ë¯¸ì§€ ì›ë³¸ ìƒ‰ìƒ 100% ìœ ì§€ (í‹´íŠ¸ ì—†ìŒ!)
    - ì¢Œìš°ì— ìŠ¤í”„ë¡œí‚· êµ¬ë©ì´ ìˆëŠ” í•„ë¦„ í”„ë ˆì„
    - í•„ë¦„ì´ ìœ„ì—ì„œ ì•„ë˜ë¡œ ë¡¤ë§í•˜ëŠ” ì• ë‹ˆë©”ì´ì…˜
    - í”„ë ˆì„ ë²ˆí˜¸ í‘œì‹œ (FRAME 001)
    - ì•½í•œ ë¹„ë„¤íŠ¸ì™€ í•„ë¦„ ìŠ¤í¬ë˜ì¹˜ íš¨ê³¼
    - ê°„í—ì  ê¹œë¹¡ì„ (ì˜›ë‚  ì˜ì‚¬ê¸° ëŠë‚Œ)
    """

    PHASE_FADEIN = 0
    PHASE_FILM_ROLL = 1      # í•„ë¦„ì´ ìœ„ì—ì„œ ë‚´ë ¤ì˜´
    PHASE_DISPLAY = 2        # ì´ë¯¸ì§€ í‘œì‹œ, ëŒ€í™”
    PHASE_FILM_ADVANCE = 3   # ë‹¤ìŒ í”„ë ˆì„ìœ¼ë¡œ ì „í™˜ (ìœ„ë¡œ ë¡¤ì•„ì›ƒ)
    PHASE_FADEOUT = 4
    PHASE_DONE = 5

    def __init__(self, screen_size: tuple, film_paths: list,
                 background_path: str = None, dialogue_after: list = None,
                 sound_manager=None, special_effects: dict = None,
                 scene_id: str = "film_scene"):
        self.screen_size = screen_size
        self.film_paths = film_paths
        self.background_path = background_path
        self.dialogue_after = dialogue_after or []
        self.sound_manager = sound_manager
        self.special_effects = special_effects or {}
        self.scene_id = scene_id

        self.is_alive = True
        self.phase = self.PHASE_FADEIN
        self.phase_timer = 0.0

        # íƒ€ì´ë°
        self.fadein_duration = 1.5
        self.fadeout_duration = 1.5
        self.roll_duration = 0.8       # ë¡¤ë§ ì• ë‹ˆë©”ì´ì…˜ ì‹œê°„
        self.advance_duration = 0.6    # ë‹¤ìŒ í”„ë ˆì„ ì „í™˜ ì‹œê°„
        self.fade_alpha = 0.0

        # ë°°ê²½ (ì–´ë‘¡ê²Œ ì²˜ë¦¬í•˜ë˜ ë¶‰ì€ í†¤ì€ ì¤„ì„)
        self.background = None
        self._load_background(background_path)

        # í•„ë¦„ í”„ë ˆì„ í¬ê¸° (í™”ë©´ì˜ 50% ì •ë„)
        screen_w, screen_h = self.screen_size
        self.film_width = int(screen_w * 0.45)
        self.film_height = int(screen_h * 0.55)

        # ìŠ¤í”„ë¡œí‚· êµ¬ë© ì„¤ì •
        self.sprocket_margin = 50      # ì¢Œìš° ì—¬ë°± (êµ¬ë© ì˜ì—­)
        self.sprocket_hole_radius = 12
        self.sprocket_hole_spacing = 40

        # í•„ë¦„ ì „ì²´ í”„ë ˆì„ í¬ê¸° (ìŠ¤í”„ë¡œí‚· í¬í•¨)
        self.frame_width = self.film_width + self.sprocket_margin * 2
        self.frame_height = self.film_height + 80  # í•˜ë‹¨ì— í”„ë ˆì„ ë²ˆí˜¸ ê³µê°„

        # ì´ë¯¸ì§€ë“¤
        self.films = []
        self._prepare_films()

        # í˜„ì¬ í”„ë ˆì„ ì¸ë±ìŠ¤
        self.current_frame_index = 0

        # ë¡¤ë§ ì• ë‹ˆë©”ì´ì…˜ìš©
        self.roll_offset = 0.0  # í˜„ì¬ ë¡¤ë§ ì˜¤í”„ì…‹ (í”½ì…€)

        # í•„ë¦„ íš¨ê³¼
        self.flicker_timer = 0.0
        self.flicker_alpha = 0       # ê¹œë¹¡ì„ ì•ŒíŒŒ (0~30 ì •ë„)
        self.scratch_lines = []      # ìŠ¤í¬ë˜ì¹˜ ë¼ì¸ë“¤
        self._generate_scratch_lines()

        # ëŒ€ì‚¬ ê´€ë ¨
        self.current_dialogue_index = 0
        self.dialogue_text = ""
        self.typing_progress = 0.0
        self.typing_speed = 25.0
        self.waiting_for_click = False
        self.dialogue_complete = False

        # í°íŠ¸
        self.fonts = {}

        # ì½œë°±
        self.on_complete = None
        self.on_replay_request = None

        # ì´ë¯¸ì§€ì™€ ëŒ€í™” ë§¤í•‘
        self._setup_dialogue_per_image()

        print(f"INFO: FilmReelEffect created with {len(self.films)} frames")

    def _load_background(self, path: str):
        """ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ - ì–´ë‘¡ê²Œ (ë¶‰ì€ í†¤ ìµœì†Œí™”)"""
        try:
            if path:
                img = pygame.image.load(path).convert()
                img = pygame.transform.scale(img, self.screen_size)
                # ì–´ë‘¡ê²Œë§Œ (ë¶‰ì€ í†¤ ì—†ì´)
                overlay = pygame.Surface(self.screen_size, pygame.SRCALPHA)
                overlay.fill((20, 20, 25, 200))
                img.blit(overlay, (0, 0))
                self.background = img
            else:
                raise Exception("No path")
        except Exception as e:
            # ê¸°ë³¸ ì–´ë‘ìš´ ë°°ê²½
            self.background = pygame.Surface(self.screen_size)
            self.background.fill((15, 15, 20))

    def _prepare_films(self):
        """í•„ë¦„ ì´ë¯¸ì§€ ì¤€ë¹„ - ì›ë³¸ ìƒ‰ìƒ ìœ ì§€!"""
        for path in self.film_paths:
            film_img = None
            try:
                film_img = pygame.image.load(path).convert_alpha()
                orig_w, orig_h = film_img.get_size()
                # ë¹„ìœ¨ ìœ ì§€í•˜ë©° í™•ëŒ€
                ratio = max(self.film_width / orig_w, self.film_height / orig_h)
                new_w, new_h = int(orig_w * ratio), int(orig_h * ratio)
                film_img = pygame.transform.smoothscale(film_img, (new_w, new_h))
                # ì¤‘ì•™ í¬ë¡­
                crop_x = (new_w - self.film_width) // 2
                crop_y = (new_h - self.film_height) // 2
                cropped = pygame.Surface((self.film_width, self.film_height), pygame.SRCALPHA)
                cropped.blit(film_img, (-crop_x, -crop_y))
                film_img = cropped
            except Exception as e:
                print(f"WARNING: Failed to load film: {path} - {e}")
                film_img = pygame.Surface((self.film_width, self.film_height), pygame.SRCALPHA)
                film_img.fill((60, 60, 65, 200))

            filename = Path(path).name
            effect_info = self.special_effects.get(filename, {})

            self.films.append({
                'image': film_img,
                'filename': filename,
                'effect': effect_info.get('effect', None),
            })

    def _generate_scratch_lines(self):
        """í•„ë¦„ ìŠ¤í¬ë˜ì¹˜ ë¼ì¸ ìƒì„±"""
        screen_h = self.screen_size[1]
        # 3~5ê°œì˜ ì„¸ë¡œ ìŠ¤í¬ë˜ì¹˜ ë¼ì¸
        for _ in range(random.randint(3, 5)):
            self.scratch_lines.append({
                'x': random.randint(100, self.screen_size[0] - 100),
                'alpha': random.randint(15, 40),
                'width': random.randint(1, 2),
            })

    def _setup_dialogue_per_image(self):
        """ì´ë¯¸ì§€ë‹¹ ëŒ€í™” ìˆ˜ ê³„ì‚°"""
        num_images = len(self.films)
        num_dialogues = len(self.dialogue_after)
        if num_images == 0:
            self.dialogues_per_image = 0
        else:
            self.dialogues_per_image = max(1, (num_dialogues + num_images - 1) // num_images)

    def set_fonts(self, fonts: dict):
        self.fonts = fonts

    def update(self, dt: float):
        if not self.is_alive:
            return

        self.phase_timer += dt

        # í•„ë¦„ ê¹œë¹¡ì„ íš¨ê³¼
        self._update_flicker(dt)

        if self.phase == self.PHASE_FADEIN:
            self.fade_alpha = min(255, (self.phase_timer / self.fadein_duration) * 255)
            if self.phase_timer >= self.fadein_duration:
                self.phase = self.PHASE_FILM_ROLL
                self.phase_timer = 0.0
                self.roll_offset = -self.frame_height  # í™”ë©´ ìœ„ì—ì„œ ì‹œì‘

        elif self.phase == self.PHASE_FILM_ROLL:
            # í•„ë¦„ì´ ìœ„ì—ì„œ ì•„ë˜ë¡œ ë¡¤ë§
            progress = min(1.0, self.phase_timer / self.roll_duration)
            eased = self._ease_out_cubic(progress)
            self.roll_offset = -self.frame_height * (1.0 - eased)

            if progress >= 1.0:
                self.roll_offset = 0
                self.phase = self.PHASE_DISPLAY
                self.phase_timer = 0.0
                self._start_dialogue()

        elif self.phase == self.PHASE_DISPLAY:
            self._update_dialogue(dt)

        elif self.phase == self.PHASE_FILM_ADVANCE:
            # í˜„ì¬ í”„ë ˆì„ì´ ìœ„ë¡œ ë¡¤ì•„ì›ƒ
            progress = min(1.0, self.phase_timer / self.advance_duration)
            eased = self._ease_in_cubic(progress)
            self.roll_offset = self.frame_height * eased

            if progress >= 1.0:
                self.current_frame_index += 1
                self.roll_offset = -self.frame_height

                if self.current_frame_index >= len(self.films):
                    self.phase = self.PHASE_FADEOUT
                    self.phase_timer = 0.0
                else:
                    # ë‹¤ìŒ í”„ë ˆì„ ë¡¤ì¸
                    self.phase = self.PHASE_FILM_ROLL
                    self.phase_timer = 0.0

        elif self.phase == self.PHASE_FADEOUT:
            progress = self.phase_timer / self.fadeout_duration
            self.fade_alpha = 255 * (1.0 - progress)
            if self.phase_timer >= self.fadeout_duration:
                self.phase = self.PHASE_DONE
                self.is_alive = False
                if self.on_complete:
                    self.on_complete()

    def _ease_out_cubic(self, t: float) -> float:
        """Ease-out cubic for smooth deceleration"""
        return 1 - pow(1 - t, 3)

    def _ease_in_cubic(self, t: float) -> float:
        """Ease-in cubic for smooth acceleration"""
        return t * t * t

    def _update_flicker(self, dt: float):
        """í•„ë¦„ ê¹œë¹¡ì„ ì—…ë°ì´íŠ¸"""
        self.flicker_timer += dt
        # ê°„í—ì ìœ¼ë¡œ ê¹œë¹¡ì„ (2~4ì´ˆë§ˆë‹¤)
        if random.random() < dt * 0.3:  # ì•½ 30% í™•ë¥ /ì´ˆ
            self.flicker_alpha = random.randint(10, 30)
        else:
            self.flicker_alpha = max(0, self.flicker_alpha - dt * 100)

    def _start_dialogue(self):
        """í˜„ì¬ ëŒ€í™” ì‹œì‘"""
        if self.current_dialogue_index < len(self.dialogue_after):
            self.dialogue_text = self.dialogue_after[self.current_dialogue_index].get("text", "")
            self.typing_progress = 0.0
            self.waiting_for_click = False
            self.dialogue_complete = False
        else:
            self.dialogue_complete = True

    def _update_dialogue(self, dt: float):
        """ëŒ€ì‚¬ ì—…ë°ì´íŠ¸"""
        if self.current_dialogue_index >= len(self.dialogue_after):
            self.dialogue_complete = True
            return

        if not self.waiting_for_click:
            self.typing_progress += dt * self.typing_speed
            if self.typing_progress >= len(self.dialogue_text):
                self.typing_progress = len(self.dialogue_text)
                self.waiting_for_click = True

    def _advance_to_next(self):
        """ë‹¤ìŒ ëŒ€í™”/ì´ë¯¸ì§€ë¡œ ì§„í–‰"""
        self.current_dialogue_index += 1

        # ì¼ì • ëŒ€í™”ë§ˆë‹¤ ë‹¤ìŒ í”„ë ˆì„ìœ¼ë¡œ ì „í™˜
        if self.dialogues_per_image > 0:
            expected_image = self.current_dialogue_index // self.dialogues_per_image
            if expected_image > self.current_frame_index and self.current_frame_index < len(self.films) - 1:
                self.phase = self.PHASE_FILM_ADVANCE
                self.phase_timer = 0.0
                return

        if self.current_dialogue_index < len(self.dialogue_after):
            self._start_dialogue()
        else:
            self.dialogue_complete = True
            if self.current_frame_index >= len(self.films) - 1:
                self.phase = self.PHASE_FADEOUT
                self.phase_timer = 0.0

    def handle_event(self, event: pygame.event.Event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if self.phase == self.PHASE_DISPLAY:
                if self.waiting_for_click:
                    self._advance_to_next()
                else:
                    self.typing_progress = len(self.dialogue_text)
                    self.waiting_for_click = True
                return True

        elif event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_SPACE, pygame.K_RETURN]:
                return self.handle_event(pygame.event.Event(pygame.MOUSEBUTTONDOWN, button=1))

        return False

    def render(self, screen: pygame.Surface):
        # ë°°ê²½
        if self.background:
            bg_copy = self.background.copy()
            if self.fade_alpha < 255:
                bg_copy.set_alpha(int(self.fade_alpha))
            screen.blit(bg_copy, (0, 0))

        # í•„ë¦„ í”„ë ˆì„ ë Œë”ë§
        if self.phase in [self.PHASE_FILM_ROLL, self.PHASE_DISPLAY, self.PHASE_FILM_ADVANCE]:
            self._render_film_frame(screen)

        # í•„ë¦„ ìŠ¤í¬ë˜ì¹˜
        self._render_scratches(screen)

        # í•„ë¦„ ê¹œë¹¡ì„
        self._render_flicker(screen)

        # ë¹„ë„¤íŠ¸ (ì•½í•˜ê²Œ)
        self._render_vignette(screen)

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DISPLAY:
            self._render_dialogue(screen)

    def _render_film_frame(self, screen: pygame.Surface):
        """í•„ë¦„ í”„ë ˆì„ ë Œë”ë§ - ì´ë¯¸ì§€ ì›ë³¸ ê·¸ëŒ€ë¡œ!"""
        if self.current_frame_index >= len(self.films):
            return

        screen_w, screen_h = self.screen_size
        center_x = screen_w // 2
        center_y = screen_h // 2

        # í”„ë ˆì„ ìœ„ì¹˜ (ë¡¤ë§ ì˜¤í”„ì…‹ ì ìš©)
        frame_x = center_x - self.frame_width // 2
        frame_y = center_y - self.frame_height // 2 + int(self.roll_offset)

        # í•„ë¦„ í”„ë ˆì„ ì„œí”¼ìŠ¤ ìƒì„±
        frame_surf = pygame.Surface((self.frame_width, self.frame_height), pygame.SRCALPHA)

        # í•„ë¦„ ë² ì´ìŠ¤ (ê²€ì€ìƒ‰ í•„ë¦„ ìŠ¤íŠ¸ë¦½)
        pygame.draw.rect(frame_surf, (25, 25, 30, 255),
                        (0, 0, self.frame_width, self.frame_height))

        # ì¢Œìš° ìŠ¤í”„ë¡œí‚· êµ¬ë©
        hole_start_y = 30
        hole_end_y = self.frame_height - 30
        for y in range(hole_start_y, hole_end_y, self.sprocket_hole_spacing):
            # ì™¼ìª½ êµ¬ë©
            pygame.draw.circle(frame_surf, (10, 10, 12, 255),
                             (self.sprocket_margin // 2, y), self.sprocket_hole_radius)
            # êµ¬ë© í…Œë‘ë¦¬
            pygame.draw.circle(frame_surf, (40, 40, 45, 255),
                             (self.sprocket_margin // 2, y), self.sprocket_hole_radius, 2)
            # ì˜¤ë¥¸ìª½ êµ¬ë©
            pygame.draw.circle(frame_surf, (10, 10, 12, 255),
                             (self.frame_width - self.sprocket_margin // 2, y), self.sprocket_hole_radius)
            pygame.draw.circle(frame_surf, (40, 40, 45, 255),
                             (self.frame_width - self.sprocket_margin // 2, y), self.sprocket_hole_radius, 2)

        # ì´ë¯¸ì§€ ì˜ì—­ ë°°ê²½ (ì•½ê°„ ë°ì€ íšŒìƒ‰)
        img_area_x = self.sprocket_margin
        img_area_y = 20
        pygame.draw.rect(frame_surf, (45, 45, 50, 255),
                        (img_area_x, img_area_y, self.film_width, self.film_height))

        # ì´ë¯¸ì§€ ì›ë³¸ ê·¸ëŒ€ë¡œ í‘œì‹œ! (í‹´íŠ¸ ì—†ìŒ!)
        film = self.films[self.current_frame_index]
        frame_surf.blit(film['image'], (img_area_x, img_area_y))

        # ì´ë¯¸ì§€ í…Œë‘ë¦¬
        pygame.draw.rect(frame_surf, (60, 60, 65, 255),
                        (img_area_x, img_area_y, self.film_width, self.film_height), 2)

        # í”„ë ˆì„ ë²ˆí˜¸ í…ìŠ¤íŠ¸
        frame_num_y = img_area_y + self.film_height + 15
        if "small" in self.fonts:
            frame_text = f"FRAME {self.current_frame_index + 1:03d}"
            text_surf = self.fonts["small"].render(frame_text, True, (180, 170, 150))
            text_x = self.frame_width // 2 - text_surf.get_width() // 2
            frame_surf.blit(text_surf, (text_x, frame_num_y))

        # í˜ì´ë“œ ì ìš©
        if self.fade_alpha < 255:
            frame_surf.set_alpha(int(self.fade_alpha))

        screen.blit(frame_surf, (frame_x, frame_y))

    def _render_scratches(self, screen: pygame.Surface):
        """í•„ë¦„ ìŠ¤í¬ë˜ì¹˜ ë Œë”ë§"""
        for scratch in self.scratch_lines:
            color = (200, 190, 170, scratch['alpha'])
            scratch_surf = pygame.Surface((scratch['width'], self.screen_size[1]), pygame.SRCALPHA)
            scratch_surf.fill(color)
            screen.blit(scratch_surf, (scratch['x'], 0))

    def _render_flicker(self, screen: pygame.Surface):
        """í•„ë¦„ ê¹œë¹¡ì„ ë Œë”ë§"""
        if self.flicker_alpha > 0:
            flicker_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
            flicker_surf.fill((255, 250, 240, self.flicker_alpha))
            screen.blit(flicker_surf, (0, 0))

    def _render_vignette(self, screen: pygame.Surface):
        """ë¹„ë„¤íŠ¸ íš¨ê³¼ (ì•½í•˜ê²Œ, ì¤‘ë¦½ ìƒ‰ìƒ)"""
        vignette = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        screen_w, screen_h = self.screen_size
        center_x, center_y = screen_w // 2, screen_h // 2
        max_dist = math.sqrt(center_x**2 + center_y**2)

        # ê°€ì¥ìë¦¬ë§Œ ì•½ê°„ ì–´ë‘¡ê²Œ (ì¤‘ë¦½ í†¤)
        for i in range(8):
            radius = int(max_dist * (1.0 - i * 0.08))
            alpha = i * 10  # ì•½í•œ ë¹„ë„¤íŠ¸
            pygame.draw.circle(vignette, (15, 15, 20, alpha), (center_x, center_y), radius, 60)

        screen.blit(vignette, (0, 0))

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€ì‚¬ ë°•ìŠ¤ ë Œë”ë§ (ì´ˆìƒí™” í¬í•¨)"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            if self.dialogue_complete and self.current_frame_index < len(self.films) - 1:
                self._render_hint(screen, "í´ë¦­í•˜ì—¬ ë‹¤ìŒ í”„ë ˆì„")
            elif self.dialogue_complete:
                self._render_hint(screen, "í´ë¦­í•˜ì—¬ ê³„ì†")
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        # ì¤‘ë¦½ì ì¸ ì–´ë‘ìš´ ìƒ‰ìƒì˜ ëŒ€í™” ìƒì
        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(25, 25, 30, 230), border_color=(80, 80, 90, 180),
                           text_color=(240, 235, 220), box_height=160,
                           has_portrait=(portrait is not None), portrait=portrait)

    def _render_hint(self, screen: pygame.Surface, text: str):
        if "small" not in self.fonts:
            return
        hint_surf = self.fonts["small"].render(text, True, (180, 175, 160))
        x = self.screen_size[0] // 2 - hint_surf.get_width() // 2
        y = self.screen_size[1] - 50
        screen.blit(hint_surf, (x, y))

    def _reset_for_replay(self):
        """ë¦¬í”Œë ˆì´ë¥¼ ìœ„í•œ ìƒíƒœ ì´ˆê¸°í™”"""
        self.phase = self.PHASE_FADEIN
        self.phase_timer = 0.0
        self.fade_alpha = 0.0
        self.current_frame_index = 0
        self.roll_offset = 0.0
        self.current_dialogue_index = 0
        self.dialogue_text = ""
        self.typing_progress = 0.0
        self.waiting_for_click = False
        self.dialogue_complete = False
        self.is_alive = True


# =========================================================
# Act 4: ê¹¨ì§„ ê±°ìš¸ íŒŒí¸ íš¨ê³¼ (BaseCutsceneEffect ìƒì†)
# =========================================================
class ShatteredMirrorEffect(BaseCutsceneEffect):
    """
    Act 4 ì»·ì”¬: ê¹¨ì§„ ê±°ìš¸/ê¸°ì–µ íŒŒí¸ íš¨ê³¼

    íŠ¹ì§•:
    - ê²€ì€ ë°°ê²½ì— ë– ë‹¤ë‹ˆëŠ” ê±°ìš¸ íŒŒí¸
    - ê° íŒŒí¸ ì•ˆì— ë‹¤ë¥¸ ì´ë¯¸ì§€
    - íŒŒí¸ë“¤ì´ ì²œì²œíˆ íšŒì „í•˜ë©° ë¹› ë°˜ì‚¬
    - ë§ˆì§€ë§‰ì— í•©ì³ì ¸ì„œ ì™„ì „í•œ ê·¸ë¦¼ í˜•ì„±
    """

    # ì¶”ê°€ í˜ì´ì¦ˆ ìƒìˆ˜ (ë² ì´ìŠ¤ í´ë˜ìŠ¤ í™•ì¥)
    PHASE_FRAGMENTS = 10
    PHASE_ASSEMBLE = 11

    def __init__(self, screen_size: tuple, fragment_paths: list,
                 background_path: str = None, dialogue_after: list = None,
                 sound_manager=None, special_effects: dict = None,
                 scene_id: str = "mirror_scene"):
        # ë² ì´ìŠ¤ í´ë˜ìŠ¤ ì´ˆê¸°í™”
        super().__init__(screen_size, background_path, dialogue_after,
                        sound_manager, special_effects, scene_id)

        self.fragment_paths = fragment_paths
        self.typing_speed = 25.0  # ì˜¤ë²„ë¼ì´ë“œ

        # ì–´ë‘ìš´ ë°°ê²½ ì˜¤ë²„ë ˆì´ ì ìš©
        if background_path:
            self._load_background(background_path, overlay_alpha=220)

        # íŒŒí¸ ê´€ë ¨
        self.fragments = []
        self._prepare_fragments()

        self.frag_animation_progress = 0.0
        self.assemble_duration = 3.0

    def _prepare_fragments(self):
        """íŒŒí¸ ì´ë¯¸ì§€ ì¤€ë¹„"""
        screen_w, screen_h = self.screen_size
        frag_size = int(min(screen_w, screen_h) * 0.25)

        # íŒŒí¸ ìœ„ì¹˜ë“¤ (ì›í˜• ë°°ì¹˜)
        center_x, center_y = screen_w // 2, screen_h // 2 - 30
        radius = min(screen_w, screen_h) * 0.25

        for i, path in enumerate(self.fragment_paths):
            frag_img = None
            try:
                frag_img = pygame.image.load(path).convert_alpha()
                frag_img = pygame.transform.smoothscale(frag_img, (frag_size, frag_size))
            except Exception as e:
                print(f"WARNING: Failed to load fragment: {path} - {e}")
                frag_img = pygame.Surface((frag_size, frag_size), pygame.SRCALPHA)
                frag_img.fill((100, 100, 120, 200))

            filename = Path(path).name
            effect_info = self.special_effects.get(filename, {})
            is_final = effect_info.get('is_final', False)

            # ì›í˜• ë°°ì¹˜ ë˜ëŠ” ìµœì¢… ì´ë¯¸ì§€
            if is_final:
                target_x, target_y = center_x, center_y
                start_x, start_y = center_x, center_y
            else:
                angle = (2 * math.pi * i) / max(len(self.fragment_paths) - 1, 1)
                target_x = center_x + radius * math.cos(angle)
                target_y = center_y + radius * math.sin(angle)
                # ì‹œì‘ ìœ„ì¹˜ (í™”ë©´ ë°–ì—ì„œ)
                start_x = center_x + (radius * 2) * math.cos(angle)
                start_y = center_y + (radius * 2) * math.sin(angle)

            self.fragments.append({
                'image': frag_img,
                'filename': filename,
                'is_final': is_final,
                'x': start_x,
                'y': start_y,
                'target_x': target_x,
                'target_y': target_y,
                'start_x': start_x,
                'start_y': start_y,
                'alpha': 0,
                'rotation': random.uniform(0, 360),
                'rotation_speed': random.uniform(-30, 30),
                'scale': 0.5 if is_final else 1.0,
                'glow': 0.0,
            })

    # set_fontsëŠ” ë² ì´ìŠ¤ í´ë˜ìŠ¤ì—ì„œ ìƒì†

    def _on_fadein_complete(self):
        """í˜ì´ë“œì¸ ì™„ë£Œ í›„ íŒŒí¸ ë“±ì¥ í˜ì´ì¦ˆë¡œ ì „í™˜"""
        self.phase = self.PHASE_FRAGMENTS
        self.phase_timer = 0.0

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸ - íŒŒí¸ ê³ ìœ  ë¡œì§ ì¶”ê°€"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        # íŒŒí¸ íšŒì „ (í•­ìƒ ì—…ë°ì´íŠ¸)
        for frag in self.fragments:
            if not frag['is_final']:
                frag['rotation'] += frag['rotation_speed'] * dt
            frag['glow'] = 0.5 + 0.5 * math.sin(self.phase_timer * 2 + frag['rotation'])

        # í˜ì´ì¦ˆë³„ ì²˜ë¦¬
        if self.phase == self.PHASE_FADEIN:
            if self._update_fadein(dt):
                self._on_fadein_complete()

        elif self.phase == self.PHASE_FRAGMENTS:
            self._update_fragments(dt)

        elif self.phase == self.PHASE_ASSEMBLE:
            self._update_assemble(dt)

        elif self.phase == self.PHASE_DIALOGUE:
            if self._update_dialogue(dt):
                self._transition_to_fadeout()

        elif self.phase == self.PHASE_FADEOUT:
            if self._update_fadeout(dt):
                self._on_fadeout_complete()

    def _update_fragments(self, dt: float):
        """íŒŒí¸ ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜"""
        self.frag_animation_progress += dt * 1.2
        visible_count = int(self.frag_animation_progress)

        for i, frag in enumerate(self.fragments):
            if frag['is_final']:
                continue
            if i < visible_count:
                progress = min(1.0, self.frag_animation_progress - i)
                eased = 1.0 - (1.0 - progress) ** 3
                frag['alpha'] = int(220 * eased)
                frag['x'] = frag['start_x'] + (frag['target_x'] - frag['start_x']) * eased
                frag['y'] = frag['start_y'] + (frag['target_y'] - frag['start_y']) * eased

        # ëª¨ë“  íŒŒí¸ ë“±ì¥ í›„ í´ë¦­ ëŒ€ê¸°
        non_final_count = sum(1 for f in self.fragments if not f['is_final'])
        if visible_count >= non_final_count:
            self.waiting_for_click = True

    def _update_assemble(self, dt: float):
        """íŒŒí¸ ì¡°ë¦½ ì• ë‹ˆë©”ì´ì…˜"""
        progress = min(1.0, self.phase_timer / self.assemble_duration)
        eased = 1.0 - (1.0 - progress) ** 2

        # íŒŒí¸ë“¤ì´ ì¤‘ì•™ìœ¼ë¡œ ëª¨ì„
        for frag in self.fragments:
            if not frag['is_final']:
                frag['alpha'] = int(220 * (1.0 - progress))
                frag['scale'] = 1.0 - 0.5 * progress
            else:
                # ìµœì¢… ì´ë¯¸ì§€ ë“±ì¥
                frag['alpha'] = int(255 * eased)
                frag['scale'] = 0.5 + 0.5 * eased

        if progress >= 1.0:
            self._transition_to_dialogue()

    def _handle_click(self) -> bool:
        """í´ë¦­ ì²˜ë¦¬ - íŒŒí¸ í˜ì´ì¦ˆ ì¶”ê°€"""
        if self.phase == self.PHASE_FRAGMENTS and self.waiting_for_click:
            self.phase = self.PHASE_ASSEMBLE
            self.phase_timer = 0.0
            self.waiting_for_click = False
            return True

        # ëŒ€í™” í˜ì´ì¦ˆëŠ” ë² ì´ìŠ¤ í´ë˜ìŠ¤ ë¡œì§ ì‚¬ìš©
        return super()._handle_click()

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        # ë°°ê²½
        self._render_background(screen)

        # íŒŒí¸ë“¤ (ìµœì¢… ì´ë¯¸ì§€ê°€ ì•„ë‹Œ ê²ƒë“¤ ë¨¼ì €)
        for frag in self.fragments:
            if not frag['is_final']:
                self._render_fragment(screen, frag)

        # ìµœì¢… ì´ë¯¸ì§€
        for frag in self.fragments:
            if frag['is_final']:
                self._render_fragment(screen, frag)

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DIALOGUE:
            self._render_dialogue(screen)

        # ì•ˆë‚´
        if self.waiting_for_click and self.phase == self.PHASE_FRAGMENTS:
            self._render_click_hint(screen, "í´ë¦­í•˜ì—¬ ì§„ì‹¤ í™•ì¸")

    def _render_fragment(self, screen: pygame.Surface, frag: dict):
        if frag['alpha'] <= 0:
            return

        img = frag['image']

        # ìŠ¤ì¼€ì¼
        scaled_w = int(img.get_width() * frag['scale'])
        scaled_h = int(img.get_height() * frag['scale'])
        if scaled_w <= 0 or scaled_h <= 0:
            return
        scaled = pygame.transform.smoothscale(img, (scaled_w, scaled_h))

        # íšŒì „ (ìµœì¢… ì´ë¯¸ì§€ëŠ” íšŒì „ ì•ˆ í•¨)
        if not frag['is_final']:
            rotated = pygame.transform.rotate(scaled, frag['rotation'])
        else:
            rotated = scaled

        # ê¸€ë¡œìš° íš¨ê³¼
        glow_surf = pygame.Surface((rotated.get_width() + 20, rotated.get_height() + 20), pygame.SRCALPHA)
        glow_alpha = int(50 * frag['glow'])
        pygame.draw.rect(glow_surf, (150, 180, 255, glow_alpha),
                        (0, 0, glow_surf.get_width(), glow_surf.get_height()), border_radius=5)
        screen.blit(glow_surf, (frag['x'] - glow_surf.get_width() // 2,
                                frag['y'] - glow_surf.get_height() // 2))

        # ì•ŒíŒŒ
        rotated.set_alpha(frag['alpha'])

        # ìœ„ì¹˜
        rect = rotated.get_rect(center=(frag['x'], frag['y']))
        screen.blit(rotated, rect)

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€í™”ì°½ ë Œë”ë§ (ì´ˆìƒí™” í¬í•¨)"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(20, 25, 40, 230), border_color=(120, 140, 180),
                           text_color=(220, 220, 240), box_height=180,
                           has_portrait=(portrait is not None), portrait=portrait)


# =========================================================
# Act 5: ì„±ê°„ í•­í•´ ì¸í„°í˜ì´ìŠ¤ íš¨ê³¼ (BaseCutsceneEffect ìƒì†)
# =========================================================
class StarMapEffect(BaseCutsceneEffect):
    """
    Act 5 ì»·ì”¬: ì„±ê°„ í•­í•´ ì¸í„°í˜ì´ìŠ¤ íš¨ê³¼

    íŠ¹ì§•:
    - ë³„ì´ ë¹›ë‚˜ëŠ” ìš°ì£¼ ë°°ê²½
    - í™€ë¡œê·¸ë¨ ìŠ¤íƒ€ ë§µ ê·¸ë¦¬ë“œ
    - ì´ë¯¸ì§€ê°€ í–‰ì„±/ê¸°ì§€ ë§ˆì»¤ì²˜ëŸ¼ í‘œì‹œ
    - ì—°ê²°ì„ ìœ¼ë¡œ ê²½ë¡œ í‘œì‹œ
    """

    # ì¶”ê°€ í˜ì´ì¦ˆ ìƒìˆ˜ (ë² ì´ìŠ¤ í´ë˜ìŠ¤ í™•ì¥)
    PHASE_MARKERS = 10
    PHASE_ROUTE = 11

    def __init__(self, screen_size: tuple, marker_paths: list,
                 marker_positions: dict = None, route_order: list = None,
                 background_path: str = None, dialogue_after: list = None,
                 sound_manager=None, special_effects: dict = None,
                 scene_id: str = "starmap_scene"):
        # ë² ì´ìŠ¤ í´ë˜ìŠ¤ ì´ˆê¸°í™”
        super().__init__(screen_size, background_path, dialogue_after,
                        sound_manager, special_effects, scene_id)

        self.marker_paths = marker_paths
        self.marker_positions = marker_positions or {}
        self.route_order = route_order or []
        self.typing_speed = 25.0  # ì˜¤ë²„ë¼ì´ë“œ

        # ë°°ê²½ì— ìš°ì£¼ í‹´íŠ¸ ì˜¤ë²„ë ˆì´ ì ìš©
        if background_path:
            self._load_background(background_path, overlay_alpha=150)

        # ë³„ íŒŒí‹°í´
        self.stars = []
        self._create_stars()

        # ë§ˆì»¤ë“¤
        self.markers = []
        self._prepare_markers()

        # ê²½ë¡œ
        self.route_progress = 0.0
        self.route_duration = 3.0
        self.route_points = []

        # ë§ˆì»¤ ì• ë‹ˆë©”ì´ì…˜
        self.marker_animation_progress = 0.0

    def _create_stars(self):
        """ë°°ê²½ ë³„ ìƒì„±"""
        for _ in range(150):
            self.stars.append({
                'x': random.randint(0, self.screen_size[0]),
                'y': random.randint(0, self.screen_size[1]),
                'size': random.uniform(1, 3),
                'brightness': random.uniform(0.3, 1.0),
                'twinkle_speed': random.uniform(1, 4),
                'twinkle_offset': random.uniform(0, math.pi * 2),
            })

    # _load_backgroundëŠ” ë² ì´ìŠ¤ í´ë˜ìŠ¤ì—ì„œ ìƒì†

    def _prepare_markers(self):
        """ë§ˆì»¤ ì¤€ë¹„"""
        screen_w, screen_h = self.screen_size
        marker_size = 80

        for path in self.marker_paths:
            marker_img = None
            try:
                marker_img = pygame.image.load(path).convert_alpha()
                marker_img = pygame.transform.smoothscale(marker_img, (marker_size, marker_size))
            except Exception as e:
                print(f"WARNING: Failed to load marker: {path} - {e}")
                marker_img = pygame.Surface((marker_size, marker_size), pygame.SRCALPHA)
                pygame.draw.circle(marker_img, (200, 150, 100), (marker_size // 2, marker_size // 2), marker_size // 2)

            filename = Path(path).name
            pos_info = self.marker_positions.get(filename, {})
            rel_pos = pos_info.get('rel_pos', (0.5, 0.5))
            label = pos_info.get('label', '')
            color = pos_info.get('color', (255, 255, 255))

            self.markers.append({
                'image': marker_img,
                'filename': filename,
                'x': int(screen_w * rel_pos[0]),
                'y': int(screen_h * rel_pos[1]),
                'label': label,
                'color': color,
                'alpha': 0,
                'scale': 0.5,
                'pulse': 0.0,
            })

        # ê²½ë¡œ í¬ì¸íŠ¸ ìƒì„±
        for filename in self.route_order:
            for marker in self.markers:
                if marker['filename'] == filename:
                    self.route_points.append((marker['x'], marker['y']))
                    break

    # set_fonts, _start_dialogueëŠ” ë² ì´ìŠ¤ í´ë˜ìŠ¤ì—ì„œ ìƒì†

    def _on_fadein_complete(self):
        """í˜ì´ë“œì¸ ì™„ë£Œ í›„ ë§ˆì»¤ ë“±ì¥ í˜ì´ì¦ˆë¡œ ì „í™˜"""
        self.phase = self.PHASE_MARKERS
        self.phase_timer = 0.0

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸ - ë§ˆì»¤/ê²½ë¡œ ê³ ìœ  ë¡œì§ ì¶”ê°€"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        # ë§ˆì»¤ í„ìŠ¤ (í•­ìƒ ì—…ë°ì´íŠ¸)
        for marker in self.markers:
            marker['pulse'] = 0.5 + 0.5 * math.sin(self.phase_timer * 2 + marker['x'] * 0.01)

        # í˜ì´ì¦ˆë³„ ì²˜ë¦¬
        if self.phase == self.PHASE_FADEIN:
            if self._update_fadein(dt):
                self._on_fadein_complete()

        elif self.phase == self.PHASE_MARKERS:
            self._update_markers(dt)

        elif self.phase == self.PHASE_ROUTE:
            self._update_route(dt)

        elif self.phase == self.PHASE_DIALOGUE:
            if self._update_dialogue(dt):
                self._transition_to_fadeout()

        elif self.phase == self.PHASE_FADEOUT:
            if self._update_fadeout(dt):
                self._on_fadeout_complete()

    def _update_markers(self, dt: float):
        """ë§ˆì»¤ ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜"""
        self.marker_animation_progress += dt * 1.5
        visible_count = int(self.marker_animation_progress)

        for i, marker in enumerate(self.markers):
            if i < visible_count:
                progress = min(1.0, self.marker_animation_progress - i)
                eased = 1.0 - (1.0 - progress) ** 3
                marker['alpha'] = int(255 * eased)
                marker['scale'] = 0.5 + 0.5 * eased

        if visible_count >= len(self.markers):
            self.waiting_for_click = True

    def _update_route(self, dt: float):
        """ê²½ë¡œ ì• ë‹ˆë©”ì´ì…˜"""
        self.route_progress = min(1.0, self.phase_timer / self.route_duration)

        if self.route_progress >= 1.0:
            self._transition_to_dialogue()

    def _handle_click(self) -> bool:
        """í´ë¦­ ì²˜ë¦¬ - ë§ˆì»¤ í˜ì´ì¦ˆ ì¶”ê°€"""
        if self.phase == self.PHASE_MARKERS and self.waiting_for_click:
            self.phase = self.PHASE_ROUTE
            self.phase_timer = 0.0
            self.waiting_for_click = False
            return True

        # ëŒ€í™” í˜ì´ì¦ˆëŠ” ë² ì´ìŠ¤ í´ë˜ìŠ¤ ë¡œì§ ì‚¬ìš©
        return super()._handle_click()

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        # ë°°ê²½ ë˜ëŠ” ìš°ì£¼ ë°°ê²½
        if self.background:
            bg_copy = self.background.copy()
            if self.fade_alpha < 255:
                bg_copy.set_alpha(int(self.fade_alpha))
            screen.blit(bg_copy, (0, 0))
        else:
            screen.fill((5, 5, 20))

        # ë³„
        self._render_stars(screen)

        # ê·¸ë¦¬ë“œ
        self._render_grid(screen)

        # ê²½ë¡œ (PHASE_ROUTE ì´í›„)
        if self.phase >= self.PHASE_ROUTE:
            self._render_route(screen)

        # ë§ˆì»¤ë“¤
        for marker in self.markers:
            self._render_marker(screen, marker)

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DIALOGUE:
            self._render_dialogue(screen)

        # ì•ˆë‚´
        if self.waiting_for_click and self.phase == self.PHASE_MARKERS:
            self._render_click_hint(screen, "í´ë¦­í•˜ì—¬ í•­ë¡œ í™•ì¸")

    def _render_stars(self, screen: pygame.Surface):
        """ë³„ ë Œë”ë§"""
        for star in self.stars:
            twinkle = 0.5 + 0.5 * math.sin(self.phase_timer * star['twinkle_speed'] + star['twinkle_offset'])
            brightness = int(255 * star['brightness'] * twinkle * (self.fade_alpha / 255))
            color = (brightness, brightness, int(brightness * 0.9))
            pygame.draw.circle(screen, color, (int(star['x']), int(star['y'])), int(star['size']))

    def _render_grid(self, screen: pygame.Surface):
        """í™€ë¡œê·¸ë¨ ê·¸ë¦¬ë“œ"""
        grid_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        grid_color = (100, 150, 255, 30)

        # ìˆ˜í‰ì„ 
        for y in range(0, self.screen_size[1], 50):
            pygame.draw.line(grid_surf, grid_color, (0, y), (self.screen_size[0], y))

        # ìˆ˜ì§ì„ 
        for x in range(0, self.screen_size[0], 50):
            pygame.draw.line(grid_surf, grid_color, (x, 0), (x, self.screen_size[1]))

        screen.blit(grid_surf, (0, 0))

    def _render_route(self, screen: pygame.Surface):
        """ê²½ë¡œ ë Œë”ë§"""
        if len(self.route_points) < 2:
            return

        # ì „ì²´ ê²½ë¡œ ê¸¸ì´ ê³„ì‚°
        total_length = 0
        segments = []
        for i in range(len(self.route_points) - 1):
            p1, p2 = self.route_points[i], self.route_points[i + 1]
            length = math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)
            segments.append((p1, p2, length))
            total_length += length

        # í˜„ì¬ ì§„í–‰ ê±°ë¦¬
        current_dist = total_length * self.route_progress
        drawn_dist = 0

        route_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)

        for p1, p2, length in segments:
            if drawn_dist + length <= current_dist:
                # ì „ì²´ ì„¸ê·¸ë¨¼íŠ¸ ê·¸ë¦¬ê¸°
                pygame.draw.line(route_surf, (255, 200, 100, 200), p1, p2, 3)
                drawn_dist += length
            elif drawn_dist < current_dist:
                # ë¶€ë¶„ ì„¸ê·¸ë¨¼íŠ¸
                ratio = (current_dist - drawn_dist) / length
                mid_x = p1[0] + (p2[0] - p1[0]) * ratio
                mid_y = p1[1] + (p2[1] - p1[1]) * ratio
                pygame.draw.line(route_surf, (255, 200, 100, 200), p1, (mid_x, mid_y), 3)
                break

        screen.blit(route_surf, (0, 0))

    def _render_marker(self, screen: pygame.Surface, marker: dict):
        if marker['alpha'] <= 0:
            return

        img = marker['image']

        # ìŠ¤ì¼€ì¼
        scaled_w = int(img.get_width() * marker['scale'])
        scaled_h = int(img.get_height() * marker['scale'])
        if scaled_w <= 0 or scaled_h <= 0:
            return
        scaled = pygame.transform.smoothscale(img, (scaled_w, scaled_h))

        # ê¸€ë¡œìš°
        glow_size = int(scaled_w * 1.5)
        glow_surf = pygame.Surface((glow_size, glow_size), pygame.SRCALPHA)
        glow_alpha = int(80 * marker['pulse'])
        pygame.draw.circle(glow_surf, (*marker['color'], glow_alpha),
                          (glow_size // 2, glow_size // 2), glow_size // 2)
        screen.blit(glow_surf, (marker['x'] - glow_size // 2, marker['y'] - glow_size // 2))

        # ë§ˆì»¤
        scaled.set_alpha(marker['alpha'])
        rect = scaled.get_rect(center=(marker['x'], marker['y']))
        screen.blit(scaled, rect)

        # ë¼ë²¨
        if marker['label'] and marker['alpha'] > 200 and "small" in self.fonts:
            label_surf = self.fonts["small"].render(marker['label'], True, marker['color'])
            label_x = marker['x'] - label_surf.get_width() // 2
            label_y = marker['y'] + scaled_h // 2 + 10
            screen.blit(label_surf, (label_x, label_y))

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€í™”ì°½ ë Œë”ë§ (ì´ˆìƒí™” í¬í•¨)"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(10, 20, 40, 220), border_color=(100, 150, 255),
                           text_color=(220, 230, 255), box_height=180,
                           has_portrait=(portrait is not None), portrait=portrait)


# =========================================================
# ì•ˆë“œë¡œë©”ë‹¤ ì„¸ê³„ íš¨ê³¼ (ì‚¬ì´ë²„í‘í¬ ê³ ëŒ€ ë„ì‹œ)
# =========================================================
class AndromedaWorldEffect(BaseCutsceneEffect):
    """
    ì•ˆë“œë¡œë©”ë‹¤ ì»·ì”¬: ì‚¬ì´ë²„í‘í¬ ê³ ëŒ€ ë„ì‹œ íš¨ê³¼

    íŠ¹ì§•:
    - ì§™ì€ ë³´ë¼/ê²€ì€ìƒ‰ í•˜ëŠ˜ (ë³€í™” ì—†ìŒ)
    - ë„¤ì˜¨ íšŒë¡œê°€ ìƒˆê²¨ì§„ í”¼ë¼ë¯¸ë“œí˜• ê±´ë¬¼
    - í™€ë¡œê·¸ë¨ ê³ ëŒ€ ë¬¸ì
    - ì œí•œì  ìƒ‰ê° (ë„¤ì˜¨ ì²­ë¡/ë³´ë¼/ì£¼í™©ë§Œ)
    - ì˜ì›í•œ í™©í˜¼ ë¶„ìœ„ê¸°
    """

    def __init__(self, screen_size: tuple, background_path: str = None,
                 dialogue_after: list = None, sound_manager=None,
                 special_effects: dict = None, scene_id: str = "andromeda_scene"):
        super().__init__(screen_size, background_path, dialogue_after,
                        sound_manager, special_effects, scene_id)

        self.typing_speed = 25.0

        # ì•ˆë“œë¡œë©”ë‹¤ ìƒ‰ìƒ íŒ”ë ˆíŠ¸ (ì œí•œì )
        self.neon_colors = [
            (0, 255, 255),      # ì²­ë¡
            (200, 100, 255),    # ë³´ë¼
            (255, 150, 50),     # ì£¼í™©
        ]
        self.sky_color = (40, 20, 60)  # ì§™ì€ ë³´ë¼/ê²€ì€ìƒ‰

        # í”¼ë¼ë¯¸ë“œ ê±´ë¬¼ë“¤
        self.buildings = []
        self._create_buildings()

        # ë„¤ì˜¨ íšŒë¡œ ë¼ì¸
        self.circuit_lines = []
        self._create_circuits()

        # í™€ë¡œê·¸ë¨ ë¬¸ì
        self.holo_chars = []
        self._create_hologram_chars()

        # íŒŒí‹°í´
        self.particles = []
        self._create_particles()

        # ì• ë‹ˆë©”ì´ì…˜ íƒ€ì´ë¨¸
        self.glow_timer = 0.0

    def _create_buildings(self):
        """í”¼ë¼ë¯¸ë“œí˜• ê±´ë¬¼ ìƒì„±"""
        screen_w, screen_h = self.screen_size
        for i in range(5):
            x = random.randint(50, screen_w - 50)
            width = random.randint(80, 150)
            height = random.randint(150, 300)
            color_idx = random.randint(0, len(self.neon_colors) - 1)
            self.buildings.append({
                'x': x,
                'y': screen_h - height // 2,
                'width': width,
                'height': height,
                'color': self.neon_colors[color_idx],
                'glow_offset': random.uniform(0, math.pi * 2),
            })

    def _create_circuits(self):
        """ë„¤ì˜¨ íšŒë¡œ ë¼ì¸ ìƒì„±"""
        screen_w, screen_h = self.screen_size
        for _ in range(15):
            start_x = random.randint(0, screen_w)
            start_y = random.randint(screen_h // 2, screen_h)
            length = random.randint(50, 150)
            horizontal = random.choice([True, False])
            color_idx = random.randint(0, len(self.neon_colors) - 1)
            self.circuit_lines.append({
                'start': (start_x, start_y),
                'length': length,
                'horizontal': horizontal,
                'color': self.neon_colors[color_idx],
                'pulse_offset': random.uniform(0, math.pi * 2),
            })

    def _create_hologram_chars(self):
        """í™€ë¡œê·¸ë¨ ê³ ëŒ€ ë¬¸ì ìƒì„±"""
        screen_w, screen_h = self.screen_size
        # ê°„ë‹¨í•œ ê¸°í˜¸ë“¤ë¡œ ê³ ëŒ€ ë¬¸ì í‘œí˜„
        symbols = ['â—†', 'â—‡', 'â—‹', 'â–³', 'â–½', 'â–¡', 'â˜†', 'â¬¡', 'â¬¢']
        for _ in range(20):
            self.holo_chars.append({
                'x': random.randint(50, screen_w - 50),
                'y': random.randint(50, screen_h - 200),
                'char': random.choice(symbols),
                'size': random.randint(15, 30),
                'alpha': random.randint(50, 150),
                'drift_speed': random.uniform(0.2, 0.5),
                'drift_offset': random.uniform(0, math.pi * 2),
            })

    def _create_particles(self):
        """ë„¤ì˜¨ íŒŒí‹°í´ ìƒì„±"""
        for _ in range(30):
            self.particles.append({
                'x': random.randint(0, self.screen_size[0]),
                'y': random.randint(0, self.screen_size[1]),
                'size': random.uniform(1, 3),
                'color': random.choice(self.neon_colors),
                'speed': random.uniform(10, 30),
                'alpha': random.randint(100, 200),
            })

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt
        self.glow_timer += dt

        # íŒŒí‹°í´ ì´ë™
        for p in self.particles:
            p['y'] -= p['speed'] * dt
            if p['y'] < 0:
                p['y'] = self.screen_size[1]
                p['x'] = random.randint(0, self.screen_size[0])

        # í˜ì´ì¦ˆ ì²˜ë¦¬
        if self.phase == self.PHASE_FADEIN:
            if self._update_fadein(dt):
                self._transition_to_dialogue()

        elif self.phase == self.PHASE_DIALOGUE:
            if self._update_dialogue(dt):
                self._transition_to_fadeout()

        elif self.phase == self.PHASE_FADEOUT:
            if self._update_fadeout(dt):
                self._on_fadeout_complete()

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        # ë°°ê²½ìƒ‰ (ì˜ì›í•œ í™©í˜¼)
        screen.fill(self.sky_color)

        # ë°°ê²½ ì´ë¯¸ì§€ (ìˆìœ¼ë©´)
        if self.background:
            bg_copy = self.background.copy()
            bg_copy.set_alpha(int(self.fade_alpha * 0.5))
            screen.blit(bg_copy, (0, 0))

        # í”¼ë¼ë¯¸ë“œ ê±´ë¬¼
        self._render_buildings(screen)

        # ë„¤ì˜¨ íšŒë¡œ
        self._render_circuits(screen)

        # í™€ë¡œê·¸ë¨ ë¬¸ì
        self._render_hologram(screen)

        # íŒŒí‹°í´
        self._render_particles(screen)

        # ìŠ¤ìº”ë¼ì¸ íš¨ê³¼
        self._render_scanlines(screen)

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DIALOGUE:
            self._render_dialogue(screen)

    def _render_buildings(self, screen: pygame.Surface):
        """í”¼ë¼ë¯¸ë“œ ê±´ë¬¼ ë Œë”ë§"""
        for bld in self.buildings:
            # í”¼ë¼ë¯¸ë“œ í˜•íƒœ
            points = [
                (bld['x'], bld['y']),  # ìƒë‹¨ ì¤‘ì•™
                (bld['x'] - bld['width'] // 2, bld['y'] + bld['height']),  # ì¢Œí•˜ë‹¨
                (bld['x'] + bld['width'] // 2, bld['y'] + bld['height']),  # ìš°í•˜ë‹¨
            ]

            # ê¸€ë¡œìš° íš¨ê³¼
            glow = 0.5 + 0.5 * math.sin(self.glow_timer * 2 + bld['glow_offset'])
            color = tuple(int(c * glow) for c in bld['color'])

            # ì™¸ê³½ì„ 
            pygame.draw.polygon(screen, color, points, 2)

            # ë‚´ë¶€ íšŒë¡œ ë¼ì¸
            for i in range(3):
                y_offset = bld['height'] * (i + 1) // 4
                line_y = bld['y'] + y_offset
                half_width = bld['width'] * (bld['height'] - y_offset) // (2 * bld['height'])
                pygame.draw.line(screen, (*color[:3], int(100 * glow)),
                               (bld['x'] - half_width, line_y),
                               (bld['x'] + half_width, line_y), 1)

    def _render_circuits(self, screen: pygame.Surface):
        """ë„¤ì˜¨ íšŒë¡œ ë Œë”ë§"""
        circuit_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        for circuit in self.circuit_lines:
            pulse = 0.3 + 0.7 * math.sin(self.glow_timer * 3 + circuit['pulse_offset'])
            alpha = int(200 * pulse)
            color = (*circuit['color'], alpha)

            start = circuit['start']
            if circuit['horizontal']:
                end = (start[0] + circuit['length'], start[1])
            else:
                end = (start[0], start[1] - circuit['length'])

            pygame.draw.line(circuit_surf, color, start, end, 2)

        screen.blit(circuit_surf, (0, 0))

    def _render_hologram(self, screen: pygame.Surface):
        """í™€ë¡œê·¸ë¨ ë¬¸ì ë Œë”ë§"""
        if "small" not in self.fonts:
            return

        holo_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        for char in self.holo_chars:
            # ë¶€ìœ  íš¨ê³¼
            drift = math.sin(self.glow_timer * char['drift_speed'] + char['drift_offset']) * 10
            y = char['y'] + drift

            # ê¹œë¹¡ì„
            flicker = 0.5 + 0.5 * math.sin(self.glow_timer * 5 + char['drift_offset'])
            alpha = int(char['alpha'] * flicker)

            color = (0, 255, 255, alpha)  # ì²­ë¡ìƒ‰
            text = self.fonts["small"].render(char['char'], True, color[:3])
            text.set_alpha(alpha)
            holo_surf.blit(text, (char['x'], y))

        screen.blit(holo_surf, (0, 0))

    def _render_particles(self, screen: pygame.Surface):
        """íŒŒí‹°í´ ë Œë”ë§"""
        for p in self.particles:
            alpha = int(p['alpha'] * (self.fade_alpha / 255))
            color = (*p['color'], alpha)
            pygame.draw.circle(screen, color, (int(p['x']), int(p['y'])), int(p['size']))

    def _render_scanlines(self, screen: pygame.Surface):
        """ìŠ¤ìº”ë¼ì¸ íš¨ê³¼ (CRT ëŠë‚Œ)"""
        scanline_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        for y in range(0, self.screen_size[1], 4):
            pygame.draw.line(scanline_surf, (0, 0, 0, 30), (0, y), (self.screen_size[0], y))
        screen.blit(scanline_surf, (0, 0))

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€í™”ì°½ ë Œë”ë§"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(20, 10, 40, 230), border_color=(0, 255, 255),
                           text_color=(200, 230, 255), box_height=180,
                           has_portrait=(portrait is not None), portrait=portrait)


# =========================================================
# ë‘ ì„¸ê³„ ë¹„êµ íš¨ê³¼ (í™”ë©´ ë¶„í• )
# =========================================================
class TwoWorldsEffect(BaseCutsceneEffect):
    """
    ë‘ ì„¸ê³„ ë¹„êµ ì»·ì”¬: í™”ë©´ ë¶„í•  íš¨ê³¼

    íŠ¹ì§•:
    - í™”ë©´ ì™¼ìª½: ì•ˆë“œë¡œë©”ë‹¤ (ì‚¬ì´ë²„í‘í¬ ê³ ëŒ€ ë„ì‹œ, ì •ì )
    - í™”ë©´ ì˜¤ë¥¸ìª½: ì§€êµ¬ ì‚¬ê³„ì ˆ (ë‹¤ì±„ìƒ‰, ë™ì )
    - ì ì§„ì ìœ¼ë¡œ ì˜¤ë¥¸ìª½ì´ ì™¼ìª½ì„ ë®ëŠ” ì• ë‹ˆë©”ì´ì…˜
    """

    PHASE_SPLIT = 10
    PHASE_MERGE = 11

    def __init__(self, screen_size: tuple, andromeda_bg: str = None,
                 earth_bg: str = None, dialogue_after: list = None,
                 sound_manager=None, special_effects: dict = None,
                 scene_id: str = "two_worlds_scene"):
        super().__init__(screen_size, None, dialogue_after,
                        sound_manager, special_effects, scene_id)

        self.typing_speed = 25.0

        # ë°°ê²½ ì´ë¯¸ì§€ ë¡œë“œ
        self.andromeda_bg = None
        self.earth_bg = None

        if andromeda_bg:
            try:
                img = pygame.image.load(andromeda_bg).convert()
                self.andromeda_bg = pygame.transform.smoothscale(img, screen_size)
            except:
                pass

        if earth_bg:
            try:
                img = pygame.image.load(earth_bg).convert()
                self.earth_bg = pygame.transform.smoothscale(img, screen_size)
            except:
                pass

        # ë¶„í• ì„  ìœ„ì¹˜ (0.0 ~ 1.0)
        self.split_position = 0.5
        self.target_split = 0.5
        self.merge_progress = 0.0
        self.merge_duration = 3.0

        # ê½ƒì íŒŒí‹°í´ (ì§€êµ¬ ìª½)
        self.petals = []
        self._create_petals()

        # ë„¤ì˜¨ íŒŒí‹°í´ (ì•ˆë“œë¡œë©”ë‹¤ ìª½)
        self.neon_particles = []
        self._create_neon_particles()

    def _create_petals(self):
        """ë²šê½ƒ ê½ƒì ìƒì„±"""
        for _ in range(30):
            self.petals.append({
                'x': random.randint(self.screen_size[0] // 2, self.screen_size[0]),
                'y': random.randint(-50, self.screen_size[1]),
                'size': random.randint(5, 12),
                'speed_y': random.uniform(20, 50),
                'speed_x': random.uniform(-20, 20),
                'rotation': random.uniform(0, 360),
                'rot_speed': random.uniform(-90, 90),
                'alpha': random.randint(150, 255),
            })

    def _create_neon_particles(self):
        """ë„¤ì˜¨ íŒŒí‹°í´ ìƒì„±"""
        for _ in range(20):
            self.neon_particles.append({
                'x': random.randint(0, self.screen_size[0] // 2),
                'y': random.randint(0, self.screen_size[1]),
                'size': random.uniform(1, 3),
                'color': random.choice([(0, 255, 255), (200, 100, 255), (255, 150, 50)]),
                'speed': random.uniform(10, 30),
                'alpha': random.randint(100, 200),
            })

    def _on_fadein_complete(self):
        """í˜ì´ë“œì¸ ì™„ë£Œ í›„ ë¶„í•  í™”ë©´ í˜ì´ì¦ˆ"""
        self.phase = self.PHASE_SPLIT
        self.phase_timer = 0.0

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        # ê½ƒì ì´ë™
        for petal in self.petals:
            petal['y'] += petal['speed_y'] * dt
            petal['x'] += petal['speed_x'] * dt
            petal['rotation'] += petal['rot_speed'] * dt
            if petal['y'] > self.screen_size[1]:
                petal['y'] = -20
                petal['x'] = random.randint(int(self.screen_size[0] * self.split_position), self.screen_size[0])

        # ë„¤ì˜¨ íŒŒí‹°í´ ì´ë™
        for p in self.neon_particles:
            p['y'] -= p['speed'] * dt
            if p['y'] < 0:
                p['y'] = self.screen_size[1]
                p['x'] = random.randint(0, int(self.screen_size[0] * self.split_position))

        # í˜ì´ì¦ˆ ì²˜ë¦¬
        if self.phase == self.PHASE_FADEIN:
            if self._update_fadein(dt):
                self._on_fadein_complete()

        elif self.phase == self.PHASE_SPLIT:
            # ë¶„í•  í™”ë©´ ëŒ€ê¸° (í´ë¦­ìœ¼ë¡œ ë‹¤ìŒ)
            self.waiting_for_click = True

        elif self.phase == self.PHASE_MERGE:
            # ì§€êµ¬ê°€ ì•ˆë“œë¡œë©”ë‹¤ë¥¼ ë®ëŠ” ì• ë‹ˆë©”ì´ì…˜
            self.merge_progress = min(1.0, self.phase_timer / self.merge_duration)
            self.split_position = 0.5 - 0.5 * self._ease_out_cubic(self.merge_progress)

            if self.merge_progress >= 1.0:
                self._transition_to_dialogue()

        elif self.phase == self.PHASE_DIALOGUE:
            if self._update_dialogue(dt):
                self._transition_to_fadeout()

        elif self.phase == self.PHASE_FADEOUT:
            if self._update_fadeout(dt):
                self._on_fadeout_complete()

    def _ease_out_cubic(self, t):
        return 1 - pow(1 - t, 3)

    def _handle_click(self) -> bool:
        """í´ë¦­ ì²˜ë¦¬"""
        if self.phase == self.PHASE_SPLIT and self.waiting_for_click:
            self.phase = self.PHASE_MERGE
            self.phase_timer = 0.0
            self.waiting_for_click = False
            return True
        return super()._handle_click()

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        split_x = int(self.screen_size[0] * self.split_position)

        # ì™¼ìª½: ì•ˆë“œë¡œë©”ë‹¤
        if self.andromeda_bg:
            screen.blit(self.andromeda_bg, (0, 0), (0, 0, split_x, self.screen_size[1]))
        else:
            pygame.draw.rect(screen, (40, 20, 60), (0, 0, split_x, self.screen_size[1]))

        # ì˜¤ë¥¸ìª½: ì§€êµ¬
        if self.earth_bg:
            screen.blit(self.earth_bg, (split_x, 0),
                       (split_x, 0, self.screen_size[0] - split_x, self.screen_size[1]))
        else:
            pygame.draw.rect(screen, (100, 150, 200),
                           (split_x, 0, self.screen_size[0] - split_x, self.screen_size[1]))

        # ë„¤ì˜¨ íŒŒí‹°í´ (ì•ˆë“œë¡œë©”ë‹¤ ìª½)
        for p in self.neon_particles:
            if p['x'] < split_x:
                alpha = int(p['alpha'] * (self.fade_alpha / 255))
                pygame.draw.circle(screen, (*p['color'], alpha), (int(p['x']), int(p['y'])), int(p['size']))

        # ê½ƒì (ì§€êµ¬ ìª½)
        for petal in self.petals:
            if petal['x'] >= split_x:
                self._render_petal(screen, petal)

        # ë¶„í• ì„  (ê¸€ë¡œìš° íš¨ê³¼)
        glow_width = 10
        glow_surf = pygame.Surface((glow_width * 2, self.screen_size[1]), pygame.SRCALPHA)
        for i in range(glow_width):
            alpha = int(150 * (1 - i / glow_width))
            pygame.draw.line(glow_surf, (255, 255, 255, alpha),
                           (glow_width - i, 0), (glow_width - i, self.screen_size[1]))
            pygame.draw.line(glow_surf, (255, 255, 255, alpha),
                           (glow_width + i, 0), (glow_width + i, self.screen_size[1]))
        screen.blit(glow_surf, (split_x - glow_width, 0))

        # ë¼ë²¨
        if self.phase == self.PHASE_SPLIT and "small" in self.fonts:
            # ì•ˆë“œë¡œë©”ë‹¤ ë¼ë²¨
            label_a = self.fonts["small"].render("ì•ˆë“œë¡œë©”ë‹¤", True, (0, 255, 255))
            screen.blit(label_a, (split_x // 2 - label_a.get_width() // 2, 30))

            # ì§€êµ¬ ë¼ë²¨
            label_e = self.fonts["small"].render("ì§€êµ¬", True, (255, 200, 150))
            screen.blit(label_e, (split_x + (self.screen_size[0] - split_x) // 2 - label_e.get_width() // 2, 30))

        # ì•ˆë‚´
        if self.waiting_for_click and self.phase == self.PHASE_SPLIT:
            self._render_click_hint(screen, "í´ë¦­í•˜ì—¬ ê³„ì†")

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DIALOGUE:
            self._render_dialogue(screen)

    def _render_petal(self, screen: pygame.Surface, petal: dict):
        """ë²šê½ƒ ê½ƒì ë Œë”ë§"""
        size = petal['size']
        surf = pygame.Surface((size * 2, size * 2), pygame.SRCALPHA)

        # ê½ƒì ëª¨ì–‘ (íƒ€ì›)
        color = (255, 200, 220, petal['alpha'])
        pygame.draw.ellipse(surf, color, (0, size // 2, size * 2, size))

        # íšŒì „
        rotated = pygame.transform.rotate(surf, petal['rotation'])
        rect = rotated.get_rect(center=(petal['x'], petal['y']))
        screen.blit(rotated, rect)

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€í™”ì°½ ë Œë”ë§"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(20, 20, 30, 230), border_color=(200, 180, 255),
                           text_color=(240, 240, 255), box_height=180,
                           has_portrait=(portrait is not None), portrait=portrait)


# =========================================================
# ê³„ì ˆ ê¸°ì–µ íš¨ê³¼ (ë¹ ë¥¸ ê³„ì ˆ ì „í™˜)
# =========================================================
class SeasonMemoryEffect(BaseCutsceneEffect):
    """
    ê³„ì ˆ ê¸°ì–µ ì»·ì”¬: ë¹ ë¥¸ ê³„ì ˆ ì „í™˜ íš¨ê³¼

    íŠ¹ì§•:
    - ë´„/ì—¬ë¦„/ê°€ì„/ê²¨ìš¸ ì´ë¯¸ì§€ ë¹ ë¥´ê²Œ ì „í™˜
    - ê° ê³„ì ˆì— ë§ëŠ” íŒŒí‹°í´ íš¨ê³¼
    - ê°ì •ê³¼ ì—°ê²°ëœ ëŒ€ì‚¬
    """

    PHASE_SEASONS = 10

    def __init__(self, screen_size: tuple, season_images: list = None,
                 dialogue_after: list = None, sound_manager=None,
                 special_effects: dict = None, scene_id: str = "season_memory_scene"):
        super().__init__(screen_size, None, dialogue_after,
                        sound_manager, special_effects, scene_id)

        self.typing_speed = 25.0

        # ê³„ì ˆ ì´ë¯¸ì§€ (ë´„, ì—¬ë¦„, ê°€ì„, ê²¨ìš¸)
        self.season_images = []
        self.season_names = ["ë´„", "ì—¬ë¦„", "ê°€ì„", "ê²¨ìš¸"]
        self.season_colors = [
            (255, 200, 220),  # ë´„: ë¶„í™
            (100, 200, 100),  # ì—¬ë¦„: ì´ˆë¡
            (255, 180, 100),  # ê°€ì„: ì£¼í™©
            (200, 220, 255),  # ê²¨ìš¸: í•˜ëŠ˜ìƒ‰
        ]

        if season_images:
            for path in season_images:
                try:
                    img = pygame.image.load(path).convert()
                    img = pygame.transform.smoothscale(img, screen_size)
                    self.season_images.append(img)
                except:
                    # ëŒ€ì²´ ìƒ‰ìƒ ë°°ê²½
                    surf = pygame.Surface(screen_size)
                    idx = len(self.season_images) % 4
                    surf.fill(self.season_colors[idx])
                    self.season_images.append(surf)

        # ìµœì†Œ 4ê°œ ë³´ì¥
        while len(self.season_images) < 4:
            surf = pygame.Surface(screen_size)
            surf.fill(self.season_colors[len(self.season_images)])
            self.season_images.append(surf)

        # í˜„ì¬ ê³„ì ˆ ì¸ë±ìŠ¤
        self.current_season = 0
        self.season_timer = 0.0
        self.season_duration = 2.0  # ê° ê³„ì ˆ í‘œì‹œ ì‹œê°„
        self.transition_duration = 0.5  # ì „í™˜ ì‹œê°„
        self.transitioning = False
        self.transition_progress = 0.0

        # íŒŒí‹°í´ (ê³„ì ˆë³„)
        self.particles = []
        self._create_season_particles()

    def _create_season_particles(self):
        """ê³„ì ˆë³„ íŒŒí‹°í´ ìƒì„±"""
        self.particles = []
        for _ in range(40):
            self.particles.append({
                'x': random.randint(0, self.screen_size[0]),
                'y': random.randint(-50, self.screen_size[1]),
                'size': random.randint(3, 8),
                'speed_y': random.uniform(30, 80),
                'speed_x': random.uniform(-30, 30),
                'rotation': random.uniform(0, 360),
                'rot_speed': random.uniform(-180, 180),
            })

    def _on_fadein_complete(self):
        """í˜ì´ë“œì¸ ì™„ë£Œ í›„ ê³„ì ˆ ì „í™˜ í˜ì´ì¦ˆ"""
        self.phase = self.PHASE_SEASONS
        self.phase_timer = 0.0
        self.current_season = 0

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        # íŒŒí‹°í´ ì´ë™
        for p in self.particles:
            p['y'] += p['speed_y'] * dt
            p['x'] += p['speed_x'] * dt
            p['rotation'] += p['rot_speed'] * dt
            if p['y'] > self.screen_size[1] + 50:
                p['y'] = -50
                p['x'] = random.randint(0, self.screen_size[0])

        # í˜ì´ì¦ˆ ì²˜ë¦¬
        if self.phase == self.PHASE_FADEIN:
            if self._update_fadein(dt):
                self._on_fadein_complete()

        elif self.phase == self.PHASE_SEASONS:
            self.season_timer += dt

            if self.transitioning:
                self.transition_progress = min(1.0, self.transition_progress + dt / self.transition_duration)
                if self.transition_progress >= 1.0:
                    self.transitioning = False
                    self.current_season = (self.current_season + 1) % 4
                    self.season_timer = 0.0
                    self.transition_progress = 0.0

                    # 4ê³„ì ˆ ì™„ë£Œ ì‹œ ëŒ€í™”ë¡œ ì „í™˜
                    if self.current_season == 0:
                        self._transition_to_dialogue()
            else:
                if self.season_timer >= self.season_duration:
                    self.transitioning = True
                    self.transition_progress = 0.0

        elif self.phase == self.PHASE_DIALOGUE:
            if self._update_dialogue(dt):
                self._transition_to_fadeout()

        elif self.phase == self.PHASE_FADEOUT:
            if self._update_fadeout(dt):
                self._on_fadeout_complete()

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        # í˜„ì¬ ê³„ì ˆ ë°°ê²½
        if self.season_images:
            current_img = self.season_images[self.current_season]

            if self.transitioning and len(self.season_images) > 1:
                # í˜ì´ë“œ ì „í™˜
                next_season = (self.current_season + 1) % len(self.season_images)
                next_img = self.season_images[next_season]

                current_img.set_alpha(int(255 * (1 - self.transition_progress)))
                screen.blit(current_img, (0, 0))

                next_img.set_alpha(int(255 * self.transition_progress))
                screen.blit(next_img, (0, 0))
            else:
                current_img.set_alpha(int(self.fade_alpha))
                screen.blit(current_img, (0, 0))

        # ê³„ì ˆ íŒŒí‹°í´
        self._render_particles(screen)

        # ê³„ì ˆ ì´ë¦„
        if self.phase == self.PHASE_SEASONS and "large" in self.fonts:
            season_name = self.season_names[self.current_season]
            color = self.season_colors[self.current_season]

            # ê¸€ë¡œìš° íš¨ê³¼
            glow_alpha = int(150 * (1 - self.transition_progress if self.transitioning else 1))
            text = self.fonts["large"].render(season_name, True, color)
            text.set_alpha(glow_alpha)

            x = self.screen_size[0] // 2 - text.get_width() // 2
            y = 50
            screen.blit(text, (x, y))

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DIALOGUE:
            self._render_dialogue(screen)

    def _render_particles(self, screen: pygame.Surface):
        """ê³„ì ˆë³„ íŒŒí‹°í´ ë Œë”ë§"""
        season = self.current_season

        for p in self.particles:
            if season == 0:  # ë´„: ê½ƒì
                self._render_petal(screen, p, (255, 200, 220))
            elif season == 1:  # ì—¬ë¦„: ë‚˜ë­‡ì
                self._render_leaf(screen, p, (100, 200, 100))
            elif season == 2:  # ê°€ì„: ë‚™ì—½
                self._render_leaf(screen, p, (255, 150, 50))
            elif season == 3:  # ê²¨ìš¸: ëˆˆ
                self._render_snow(screen, p)

    def _render_petal(self, screen: pygame.Surface, p: dict, color: tuple):
        """ê½ƒì ë Œë”ë§"""
        size = p['size']
        surf = pygame.Surface((size * 2, size * 2), pygame.SRCALPHA)
        pygame.draw.ellipse(surf, (*color, 200), (0, size // 2, size * 2, size))
        rotated = pygame.transform.rotate(surf, p['rotation'])
        rect = rotated.get_rect(center=(p['x'], p['y']))
        screen.blit(rotated, rect)

    def _render_leaf(self, screen: pygame.Surface, p: dict, color: tuple):
        """ë‚˜ë­‡ì ë Œë”ë§"""
        size = p['size']
        surf = pygame.Surface((size * 2, size), pygame.SRCALPHA)
        # ì ëª¨ì–‘ (ë‹¤ì´ì•„ëª¬ë“œ)
        points = [(size, 0), (size * 2, size // 2), (size, size), (0, size // 2)]
        pygame.draw.polygon(surf, (*color, 200), points)
        rotated = pygame.transform.rotate(surf, p['rotation'])
        rect = rotated.get_rect(center=(p['x'], p['y']))
        screen.blit(rotated, rect)

    def _render_snow(self, screen: pygame.Surface, p: dict):
        """ëˆˆ ë Œë”ë§"""
        alpha = int(200 * (self.fade_alpha / 255))
        pygame.draw.circle(screen, (255, 255, 255, alpha), (int(p['x']), int(p['y'])), p['size'])

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€í™”ì°½ ë Œë”ë§"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(30, 25, 40, 230), border_color=(200, 180, 150),
                           text_color=(255, 250, 240), box_height=180,
                           has_portrait=(portrait is not None), portrait=portrait)


class BrokenToyEffect(BaseCutsceneEffect):
    """
    ë¶€ì„œì§„ ì¥ë‚œê° ì»·ì”¬ (Act 1)

    íŠ¹ì§•:
    - íí—ˆ ì†ì—ì„œ ë°œê²¬ëœ ë‚¡ì€ ì¸í˜•/ì¥ë‚œê°
    - ì²œì²œíˆ ë–¨ì–´ì§€ëŠ” ë¨¼ì§€ íŒŒí‹°í´
    - ê·¸ì„ë¦° ìêµ­, ì°¢ì–´ì§„ ë¶€ë¶„ ê°•ì¡°
    - ì•„ë¥´í…Œë¯¸ìŠ¤ì˜ ì–´ë¦° ì‹œì ˆ íšŒìƒ ì—°ê²°
    """

    PHASE_ZOOM_IN = 10
    PHASE_MEMORIES = 11

    def __init__(self, screen_size: tuple, toy_image_path: str = None,
                 dialogue_after: list = None, sound_manager=None,
                 special_effects: dict = None, scene_id: str = "broken_toy_scene"):
        super().__init__(screen_size, None, dialogue_after,
                        sound_manager, special_effects, scene_id)

        self.typing_speed = 25.0

        # ì¥ë‚œê° ì´ë¯¸ì§€
        self.toy_image = None
        self.toy_size = (200, 200)
        self.toy_pos = (screen_size[0] // 2, screen_size[1] // 2)
        self.toy_rotation = 15  # ì•½ê°„ ê¸°ìš¸ì–´ì§„ ëª¨ìŠµ

        if toy_image_path:
            try:
                img = pygame.image.load(toy_image_path).convert_alpha()
                self.toy_image = pygame.transform.smoothscale(img, self.toy_size)
            except:
                self._create_placeholder_toy()
        else:
            self._create_placeholder_toy()

        # ì¤Œ ì• ë‹ˆë©”ì´ì…˜
        self.zoom_scale = 0.3
        self.target_zoom = 1.0
        self.zoom_speed = 0.5

        # ë¨¼ì§€ íŒŒí‹°í´
        self.dust_particles = []
        for _ in range(50):
            self.dust_particles.append({
                'x': random.randint(0, screen_size[0]),
                'y': random.randint(0, screen_size[1]),
                'size': random.uniform(1, 3),
                'speed_y': random.uniform(5, 15),
                'speed_x': random.uniform(-5, 5),
                'alpha': random.randint(50, 150),
            })

        # íšŒìƒ í”Œë˜ì‹œ íš¨ê³¼
        self.flash_alpha = 0
        self.flash_timer = 0.0
        self.memory_flashes = []  # ì§§ì€ íšŒìƒ ì´ë¯¸ì§€ë“¤

        # ë°°ê²½ ìƒ‰ìƒ (íí—ˆ/ì–´ë‘ìš´ í†¤)
        self.bg_color = (30, 25, 20)

    def _create_placeholder_toy(self):
        """ëŒ€ì²´ ì¥ë‚œê° ì´ë¯¸ì§€ ìƒì„± (ê³°ì¸í˜• í˜•íƒœ)"""
        surf = pygame.Surface(self.toy_size, pygame.SRCALPHA)

        # ëª¸í†µ
        body_color = (139, 90, 43, 200)
        pygame.draw.ellipse(surf, body_color, (50, 80, 100, 110))

        # ë¨¸ë¦¬
        pygame.draw.circle(surf, body_color, (100, 60), 45)

        # ê·€
        pygame.draw.circle(surf, body_color, (60, 25), 18)
        pygame.draw.circle(surf, body_color, (140, 25), 18)

        # ëˆˆ (í•˜ë‚˜ëŠ” Xí‘œì‹œ - ë¶€ì„œì§„ ëŠë‚Œ)
        pygame.draw.circle(surf, (20, 20, 20), (85, 55), 8)
        # X í‘œì‹œ ëˆˆ
        pygame.draw.line(surf, (20, 20, 20), (107, 47), (123, 63), 3)
        pygame.draw.line(surf, (20, 20, 20), (107, 63), (123, 47), 3)

        # ì½”
        pygame.draw.circle(surf, (60, 40, 30), (100, 75), 6)

        # ì°¢ì–´ì§„ ìêµ­ (ëŒ€ê°ì„  ì„ ë“¤)
        tear_color = (80, 50, 30, 150)
        pygame.draw.line(surf, tear_color, (70, 100), (90, 140), 2)
        pygame.draw.line(surf, tear_color, (85, 95), (75, 130), 2)

        # ê·¸ì„ë¦° ìêµ­
        burn_surf = pygame.Surface((40, 40), pygame.SRCALPHA)
        pygame.draw.circle(burn_surf, (40, 30, 25, 100), (20, 20), 20)
        surf.blit(burn_surf, (110, 120))

        self.toy_image = surf

    def _on_fadein_complete(self):
        """í˜ì´ë“œì¸ ì™„ë£Œ í›„ ì¤Œì¸ ì‹œì‘"""
        self.phase = self.PHASE_ZOOM_IN
        self.phase_timer = 0.0

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        # ë¨¼ì§€ íŒŒí‹°í´ ì—…ë°ì´íŠ¸
        for p in self.dust_particles:
            p['y'] += p['speed_y'] * dt
            p['x'] += p['speed_x'] * dt
            if p['y'] > self.screen_size[1]:
                p['y'] = -10
                p['x'] = random.randint(0, self.screen_size[0])

        # íšŒìƒ í”Œë˜ì‹œ íš¨ê³¼
        self.flash_timer += dt
        if self.phase == self.PHASE_MEMORIES:
            if self.flash_timer > 2.0:
                self.flash_alpha = max(0, self.flash_alpha - 200 * dt)
                if random.random() < 0.02:
                    self.flash_alpha = 100
                    self.flash_timer = 0

        # í˜ì´ì¦ˆ ì²˜ë¦¬
        if self.phase == self.PHASE_FADEIN:
            if self._update_fadein(dt):
                self._on_fadein_complete()

        elif self.phase == self.PHASE_ZOOM_IN:
            # ì¤Œì¸ ì• ë‹ˆë©”ì´ì…˜
            self.zoom_scale = min(self.target_zoom, self.zoom_scale + self.zoom_speed * dt)
            if self.zoom_scale >= self.target_zoom:
                self.phase = self.PHASE_MEMORIES
                self.phase_timer = 0.0
                # 2ì´ˆ í›„ ëŒ€í™”ë¡œ ì „í™˜
            if self.phase == self.PHASE_MEMORIES and self.phase_timer > 2.0:
                self._transition_to_dialogue()

        elif self.phase == self.PHASE_MEMORIES:
            if self.phase_timer > 2.0:
                self._transition_to_dialogue()

        elif self.phase == self.PHASE_DIALOGUE:
            if self._update_dialogue(dt):
                self._transition_to_fadeout()

        elif self.phase == self.PHASE_FADEOUT:
            if self._update_fadeout(dt):
                self._on_fadeout_complete()

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        # ë°°ê²½
        screen.fill(self.bg_color)

        # íí—ˆ ëŠë‚Œì˜ ê·¸ë¼ë°ì´ì…˜
        for i in range(20):
            alpha = 10 + i * 3
            y = self.screen_size[1] - i * 30
            pygame.draw.rect(screen, (40 + i * 2, 35 + i, 30), (0, y, self.screen_size[0], 30))

        # ë¨¼ì§€ íŒŒí‹°í´
        for p in self.dust_particles:
            color = (180, 170, 150, p['alpha'])
            surf = pygame.Surface((int(p['size'] * 2), int(p['size'] * 2)), pygame.SRCALPHA)
            pygame.draw.circle(surf, color, (int(p['size']), int(p['size'])), int(p['size']))
            screen.blit(surf, (int(p['x']), int(p['y'])))

        # ì¥ë‚œê°
        if self.toy_image:
            scaled_size = (int(self.toy_size[0] * self.zoom_scale),
                          int(self.toy_size[1] * self.zoom_scale))
            scaled_toy = pygame.transform.smoothscale(self.toy_image, scaled_size)
            rotated_toy = pygame.transform.rotate(scaled_toy, self.toy_rotation)

            toy_rect = rotated_toy.get_rect(center=self.toy_pos)
            screen.blit(rotated_toy, toy_rect)

            # ìŠ¤í¬íŠ¸ë¼ì´íŠ¸ íš¨ê³¼
            if self.phase in [self.PHASE_ZOOM_IN, self.PHASE_MEMORIES]:
                spotlight = pygame.Surface(self.screen_size, pygame.SRCALPHA)
                center = self.toy_pos
                for r in range(150, 0, -10):
                    alpha = int(30 * (r / 150))
                    pygame.draw.circle(spotlight, (255, 240, 200, alpha), center, r)
                screen.blit(spotlight, (0, 0))

        # íšŒìƒ í”Œë˜ì‹œ
        if self.flash_alpha > 0:
            flash_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
            flash_surf.fill((255, 255, 255, int(self.flash_alpha)))
            screen.blit(flash_surf, (0, 0))

        # ë¹„ë„¤íŠ¸ íš¨ê³¼
        vignette = pygame.Surface(self.screen_size, pygame.SRCALPHA)
        for i in range(100):
            alpha = int(i * 1.5)
            pygame.draw.rect(vignette, (0, 0, 0, alpha), (i, i, self.screen_size[0] - i * 2, self.screen_size[1] - i * 2), 1)
        screen.blit(vignette, (0, 0))

        # í˜ì´ë“œ
        if self.phase == self.PHASE_FADEIN:
            fade_surf = pygame.Surface(self.screen_size)
            fade_surf.fill((0, 0, 0))
            fade_surf.set_alpha(255 - int(self.fade_alpha))
            screen.blit(fade_surf, (0, 0))

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DIALOGUE:
            self._render_dialogue(screen)

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€í™”ì°½ ë Œë”ë§"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(40, 30, 25, 230), border_color=(150, 120, 80),
                           text_color=(255, 250, 240), box_height=180,
                           has_portrait=(portrait is not None), portrait=portrait)


class HologramMessageEffect(BaseCutsceneEffect):
    """
    ì•„ë²„ì§€ í™€ë¡œê·¸ë¨ ë©”ì‹œì§€ ì»·ì”¬ (Act 2)

    íŠ¹ì§•:
    - ë²™ì»¤ì—ì„œ ë°œê²¬ëœ í™€ë¡œê·¸ë¨ ì¥ì¹˜
    - ê¹œë¹¡ì´ëŠ” í™€ë¡œê·¸ë¨ íˆ¬ì˜
    - ì•„ë²„ì§€ì˜ ë…¹í™”ëœ ë©”ì‹œì§€
    - ìŠ¤ìº”ë¼ì¸, ê¸€ë¦¬ì¹˜ íš¨ê³¼
    """

    PHASE_DEVICE_ACTIVATE = 10
    PHASE_HOLOGRAM_FLICKER = 11
    PHASE_MESSAGE_PLAY = 12

    def __init__(self, screen_size: tuple, father_image_path: str = None,
                 dialogue_after: list = None, sound_manager=None,
                 special_effects: dict = None, scene_id: str = "hologram_message_scene"):
        super().__init__(screen_size, None, dialogue_after,
                        sound_manager, special_effects, scene_id)

        self.typing_speed = 22.0

        # ì•„ë²„ì§€ í™€ë¡œê·¸ë¨ ì´ë¯¸ì§€
        self.father_image = None
        self.hologram_size = (300, 400)
        self.hologram_pos = (screen_size[0] // 2, screen_size[1] // 2 - 50)

        if father_image_path:
            try:
                img = pygame.image.load(father_image_path).convert_alpha()
                self.father_image = pygame.transform.smoothscale(img, self.hologram_size)
            except:
                self._create_placeholder_silhouette()
        else:
            self._create_placeholder_silhouette()

        # í™€ë¡œê·¸ë¨ íš¨ê³¼
        self.hologram_alpha = 0
        self.hologram_flicker = 0.0
        self.glitch_offset = 0
        self.scanline_offset = 0

        # ì¥ì¹˜ í™œì„±í™” íŒŒí‹°í´
        self.activation_particles = []
        self.device_glow = 0.0

        # ë°°ê²½ (ì–´ë‘ìš´ ë²™ì»¤)
        self.bg_color = (15, 20, 30)

        # í™€ë¡œê·¸ë¨ ìƒ‰ìƒ (ì²­ë¡ìƒ‰)
        self.holo_color = (100, 200, 255)

    def _create_placeholder_silhouette(self):
        """ëŒ€ì²´ ì•„ë²„ì§€ ì‹¤ë£¨ì—£ ì´ë¯¸ì§€"""
        surf = pygame.Surface(self.hologram_size, pygame.SRCALPHA)

        # ë¨¸ë¦¬
        head_center = (self.hologram_size[0] // 2, 80)
        pygame.draw.circle(surf, (*self.holo_color, 150), head_center, 50)

        # ì–´ê¹¨/ìƒì²´
        body_points = [
            (self.hologram_size[0] // 2 - 80, 400),
            (self.hologram_size[0] // 2 - 60, 150),
            (self.hologram_size[0] // 2, 130),
            (self.hologram_size[0] // 2 + 60, 150),
            (self.hologram_size[0] // 2 + 80, 400),
        ]
        pygame.draw.polygon(surf, (*self.holo_color, 120), body_points)

        self.father_image = surf

    def _on_fadein_complete(self):
        """í˜ì´ë“œì¸ ì™„ë£Œ í›„ ì¥ì¹˜ í™œì„±í™”"""
        self.phase = self.PHASE_DEVICE_ACTIVATE
        self.phase_timer = 0.0

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        # ìŠ¤ìº”ë¼ì¸ ì´ë™
        self.scanline_offset = (self.scanline_offset + 100 * dt) % self.screen_size[1]

        # ê¸€ë¦¬ì¹˜ íš¨ê³¼
        if random.random() < 0.05:
            self.glitch_offset = random.randint(-10, 10)
        else:
            self.glitch_offset = int(self.glitch_offset * 0.8)

        # í˜ì´ì¦ˆ ì²˜ë¦¬
        if self.phase == self.PHASE_FADEIN:
            if self._update_fadein(dt):
                self._on_fadein_complete()

        elif self.phase == self.PHASE_DEVICE_ACTIVATE:
            self.device_glow = min(1.0, self.device_glow + dt * 0.5)
            if self.phase_timer > 2.0:
                self.phase = self.PHASE_HOLOGRAM_FLICKER
                self.phase_timer = 0.0

        elif self.phase == self.PHASE_HOLOGRAM_FLICKER:
            # í™€ë¡œê·¸ë¨ ê¹œë¹¡ì„
            self.hologram_flicker += dt * 10
            flicker_value = (math.sin(self.hologram_flicker * 5) + 1) / 2
            self.hologram_alpha = int(flicker_value * 200)

            if self.phase_timer > 2.0:
                self.phase = self.PHASE_MESSAGE_PLAY
                self.phase_timer = 0.0
                self.hologram_alpha = 200

        elif self.phase == self.PHASE_MESSAGE_PLAY:
            # ì•ˆì •ëœ í™€ë¡œê·¸ë¨
            self.hologram_alpha = 200 + int(math.sin(self.phase_timer * 2) * 30)

            if self.phase_timer > 3.0:
                self._transition_to_dialogue()

        elif self.phase == self.PHASE_DIALOGUE:
            if self._update_dialogue(dt):
                self._transition_to_fadeout()

        elif self.phase == self.PHASE_FADEOUT:
            if self._update_fadeout(dt):
                self._on_fadeout_complete()

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        # ë°°ê²½
        screen.fill(self.bg_color)

        # ë²™ì»¤ ë‚´ë¶€ ëŠë‚Œ
        for i in range(0, self.screen_size[0], 100):
            pygame.draw.line(screen, (25, 30, 40), (i, 0), (i, self.screen_size[1]), 2)
        for i in range(0, self.screen_size[1], 100):
            pygame.draw.line(screen, (25, 30, 40), (0, i), (self.screen_size[0], i), 2)

        # ì¥ì¹˜ (ë°”ë‹¥ì˜ ì›í˜• í”Œë«í¼)
        device_center = (self.screen_size[0] // 2, self.screen_size[1] - 100)
        glow_radius = int(100 + self.device_glow * 50)
        for r in range(glow_radius, 0, -10):
            alpha = int(self.device_glow * 50 * (r / glow_radius))
            pygame.draw.circle(screen, (*self.holo_color, alpha), device_center, r)
        pygame.draw.circle(screen, (50, 60, 80), device_center, 80)
        pygame.draw.circle(screen, self.holo_color, device_center, 80, 3)

        # í™€ë¡œê·¸ë¨
        if self.phase in [self.PHASE_HOLOGRAM_FLICKER, self.PHASE_MESSAGE_PLAY, self.PHASE_DIALOGUE]:
            if self.father_image:
                holo_surf = self.father_image.copy()
                holo_surf.set_alpha(self.hologram_alpha)

                # ê¸€ë¦¬ì¹˜ ì˜¤í”„ì…‹ ì ìš©
                pos = (self.hologram_pos[0] - self.hologram_size[0] // 2 + self.glitch_offset,
                      self.hologram_pos[1] - self.hologram_size[1] // 2)
                screen.blit(holo_surf, pos)

                # ìŠ¤ìº”ë¼ì¸ íš¨ê³¼
                for y in range(0, self.screen_size[1], 4):
                    alpha = 30 if (y + int(self.scanline_offset)) % 8 < 4 else 0
                    if alpha > 0:
                        pygame.draw.line(screen, (0, 0, 0, alpha), (0, y), (self.screen_size[0], y))

                # í™€ë¡œê·¸ë¨ ì™¸ê³½ ê¸€ë¡œìš°
                glow_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
                glow_rect = pygame.Rect(pos[0] - 20, pos[1] - 20,
                                       self.hologram_size[0] + 40, self.hologram_size[1] + 40)
                pygame.draw.rect(glow_surf, (*self.holo_color, 30), glow_rect, border_radius=10)
                screen.blit(glow_surf, (0, 0))

        # í˜ì´ë“œ
        if self.phase == self.PHASE_FADEIN:
            fade_surf = pygame.Surface(self.screen_size)
            fade_surf.fill((0, 0, 0))
            fade_surf.set_alpha(255 - int(self.fade_alpha))
            screen.blit(fade_surf, (0, 0))

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DIALOGUE:
            self._render_dialogue(screen)

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€í™”ì°½ ë Œë”ë§"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(20, 30, 50, 230), border_color=(100, 180, 220),
                           text_color=(200, 240, 255), box_height=180,
                           has_portrait=(portrait is not None), portrait=portrait)


class DualMemoryEffect(BaseCutsceneEffect):
    """
    ì´ì¤‘ íšŒìƒ ì»·ì”¬ (Act 3)

    íŠ¹ì§•:
    - í™”ë©´ì´ ë‘˜ë¡œ ë¶„í• 
    - ì™¼ìª½: í–‰ë³µí–ˆë˜ ê³¼ê±° (ë”°ëœ»í•œ ìƒ‰ì¡°)
    - ì˜¤ë¥¸ìª½: í˜„ì¬ì˜ íí—ˆ (ì°¨ê°€ìš´ ìƒ‰ì¡°)
    - ë‘ ì‹œê°„ëŒ€ê°€ ë™ì‹œì— ë³´ì„
    """

    PHASE_SPLIT_SCREEN = 10
    PHASE_MERGE = 11

    def __init__(self, screen_size: tuple, past_image_path: str = None,
                 present_image_path: str = None, dialogue_after: list = None,
                 sound_manager=None, special_effects: dict = None,
                 scene_id: str = "dual_memory_scene"):
        super().__init__(screen_size, None, dialogue_after,
                        sound_manager, special_effects, scene_id)

        self.typing_speed = 24.0

        # ê³¼ê±°/í˜„ì¬ ì´ë¯¸ì§€
        self.past_image = None
        self.present_image = None
        half_size = (screen_size[0] // 2, screen_size[1])

        if past_image_path:
            try:
                img = pygame.image.load(past_image_path).convert()
                self.past_image = pygame.transform.smoothscale(img, half_size)
            except:
                self._create_placeholder_past(half_size)
        else:
            self._create_placeholder_past(half_size)

        if present_image_path:
            try:
                img = pygame.image.load(present_image_path).convert()
                self.present_image = pygame.transform.smoothscale(img, half_size)
            except:
                self._create_placeholder_present(half_size)
        else:
            self._create_placeholder_present(half_size)

        # ë¶„í• ì„  ìœ„ì¹˜
        self.split_x = screen_size[0] // 2
        self.split_wave = 0.0

        # íŒŒí‹°í´ (ê³¼ê±°: ë”°ëœ»í•œ ë¹›, í˜„ì¬: ì¬)
        self.past_particles = []
        self.present_particles = []
        self._create_particles()

        # ìƒ‰ìƒ ì˜¤ë²„ë ˆì´
        self.past_tint = (255, 230, 200)  # ë”°ëœ»í•œ ì„¸í”¼ì•„
        self.present_tint = (150, 170, 200)  # ì°¨ê°€ìš´ ë¸”ë£¨

    def _create_placeholder_past(self, size):
        """ê³¼ê±° ì´ë¯¸ì§€ ëŒ€ì²´"""
        surf = pygame.Surface(size)
        # ë”°ëœ»í•œ ê·¸ë¼ë°ì´ì…˜
        for y in range(size[1]):
            ratio = y / size[1]
            r = int(255 - ratio * 50)
            g = int(200 - ratio * 50)
            b = int(150 - ratio * 50)
            pygame.draw.line(surf, (r, g, b), (0, y), (size[0], y))

        # ì§‘ ì‹¤ë£¨ì—£
        house_color = (200, 180, 150)
        pygame.draw.rect(surf, house_color, (100, 300, 200, 150))
        pygame.draw.polygon(surf, house_color, [(100, 300), (200, 200), (300, 300)])

        # íƒœì–‘
        pygame.draw.circle(surf, (255, 220, 100), (350, 100), 50)

        self.past_image = surf

    def _create_placeholder_present(self, size):
        """í˜„ì¬ ì´ë¯¸ì§€ ëŒ€ì²´"""
        surf = pygame.Surface(size)
        # ì°¨ê°€ìš´ ê·¸ë¼ë°ì´ì…˜
        for y in range(size[1]):
            ratio = y / size[1]
            r = int(40 + ratio * 20)
            g = int(50 + ratio * 20)
            b = int(70 + ratio * 20)
            pygame.draw.line(surf, (r, g, b), (0, y), (size[0], y))

        # íí—ˆ ì‹¤ë£¨ì—£
        ruin_color = (60, 55, 50)
        # ë¬´ë„ˆì§„ ê±´ë¬¼
        pygame.draw.rect(surf, ruin_color, (80, 320, 100, 130))
        pygame.draw.rect(surf, ruin_color, (200, 280, 80, 170))
        # ì”í•´
        for i in range(10):
            x = random.randint(50, 350)
            y = random.randint(400, 450)
            w = random.randint(20, 50)
            h = random.randint(10, 30)
            pygame.draw.rect(surf, (50, 45, 40), (x, y, w, h))

        self.present_image = surf

    def _create_particles(self):
        """íŒŒí‹°í´ ìƒì„±"""
        half_w = self.screen_size[0] // 2

        # ê³¼ê±°: ë¹›ë‚˜ëŠ” ë¨¼ì§€
        for _ in range(30):
            self.past_particles.append({
                'x': random.randint(0, half_w),
                'y': random.randint(0, self.screen_size[1]),
                'size': random.uniform(2, 4),
                'speed': random.uniform(-20, 20),
                'alpha': random.randint(100, 200),
            })

        # í˜„ì¬: ì¬/ì—°ê¸°
        for _ in range(40):
            self.present_particles.append({
                'x': random.randint(half_w, self.screen_size[0]),
                'y': random.randint(0, self.screen_size[1]),
                'size': random.uniform(3, 6),
                'speed_y': random.uniform(-30, -10),
                'speed_x': random.uniform(-10, 10),
                'alpha': random.randint(50, 100),
            })

    def _on_fadein_complete(self):
        """í˜ì´ë“œì¸ ì™„ë£Œ"""
        self.phase = self.PHASE_SPLIT_SCREEN
        self.phase_timer = 0.0

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        # ë¶„í• ì„  ì›¨ì´ë¸Œ
        self.split_wave += dt * 3
        wave_offset = int(math.sin(self.split_wave) * 5)

        # íŒŒí‹°í´ ì—…ë°ì´íŠ¸
        for p in self.past_particles:
            p['y'] += p['speed'] * dt
            if p['y'] < 0 or p['y'] > self.screen_size[1]:
                p['speed'] = -p['speed']

        for p in self.present_particles:
            p['y'] += p['speed_y'] * dt
            p['x'] += p['speed_x'] * dt
            if p['y'] < -10:
                p['y'] = self.screen_size[1] + 10
                p['x'] = random.randint(self.screen_size[0] // 2, self.screen_size[0])

        # í˜ì´ì¦ˆ ì²˜ë¦¬
        if self.phase == self.PHASE_FADEIN:
            if self._update_fadein(dt):
                self._on_fadein_complete()

        elif self.phase == self.PHASE_SPLIT_SCREEN:
            if self.phase_timer > 4.0:
                self._transition_to_dialogue()

        elif self.phase == self.PHASE_DIALOGUE:
            if self._update_dialogue(dt):
                self._transition_to_fadeout()

        elif self.phase == self.PHASE_FADEOUT:
            if self._update_fadeout(dt):
                self._on_fadeout_complete()

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        half_w = self.screen_size[0] // 2

        # ê³¼ê±° (ì™¼ìª½)
        if self.past_image:
            screen.blit(self.past_image, (0, 0))
            # ë”°ëœ»í•œ ì˜¤ë²„ë ˆì´
            warm_overlay = pygame.Surface((half_w, self.screen_size[1]), pygame.SRCALPHA)
            warm_overlay.fill((*self.past_tint, 30))
            screen.blit(warm_overlay, (0, 0))

        # í˜„ì¬ (ì˜¤ë¥¸ìª½)
        if self.present_image:
            screen.blit(self.present_image, (half_w, 0))
            # ì°¨ê°€ìš´ ì˜¤ë²„ë ˆì´
            cold_overlay = pygame.Surface((half_w, self.screen_size[1]), pygame.SRCALPHA)
            cold_overlay.fill((*self.present_tint, 40))
            screen.blit(cold_overlay, (half_w, 0))

        # ê³¼ê±° íŒŒí‹°í´ (ë¹›)
        for p in self.past_particles:
            glow_surf = pygame.Surface((int(p['size'] * 4), int(p['size'] * 4)), pygame.SRCALPHA)
            pygame.draw.circle(glow_surf, (255, 240, 200, p['alpha']),
                             (int(p['size'] * 2), int(p['size'] * 2)), int(p['size']))
            screen.blit(glow_surf, (int(p['x']), int(p['y'])))

        # í˜„ì¬ íŒŒí‹°í´ (ì¬)
        for p in self.present_particles:
            pygame.draw.circle(screen, (80, 80, 80, p['alpha']),
                             (int(p['x']), int(p['y'])), int(p['size']))

        # ë¶„í• ì„  (ê¸€ë¡œìš° íš¨ê³¼)
        wave_offset = int(math.sin(self.split_wave) * 5)
        for i in range(-10, 11, 2):
            alpha = 255 - abs(i) * 20
            x = half_w + wave_offset + i
            pygame.draw.line(screen, (255, 255, 255, max(0, alpha)), (x, 0), (x, self.screen_size[1]), 1)

        # ë ˆì´ë¸”
        if self.phase == self.PHASE_SPLIT_SCREEN and "medium" in self.fonts:
            past_label = self.fonts["medium"].render("ê³¼ê±°", True, self.past_tint)
            present_label = self.fonts["medium"].render("í˜„ì¬", True, self.present_tint)

            screen.blit(past_label, (half_w // 2 - past_label.get_width() // 2, 30))
            screen.blit(present_label, (half_w + half_w // 2 - present_label.get_width() // 2, 30))

        # í˜ì´ë“œ
        if self.phase == self.PHASE_FADEIN:
            fade_surf = pygame.Surface(self.screen_size)
            fade_surf.fill((0, 0, 0))
            fade_surf.set_alpha(255 - int(self.fade_alpha))
            screen.blit(fade_surf, (0, 0))

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DIALOGUE:
            self._render_dialogue(screen)

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€í™”ì°½ ë Œë”ë§"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(30, 30, 40, 230), border_color=(200, 200, 220),
                           text_color=(255, 255, 255), box_height=180,
                           has_portrait=(portrait is not None), portrait=portrait)


class RadioWaveEffect(BaseCutsceneEffect):
    """
    ì–´ë¨¸ë‹ˆ ì‹ í˜¸ ì»·ì”¬ (Act 4)

    íŠ¹ì§•:
    - í†µì‹  ê¸°ì§€ì—ì„œ ìˆ˜ì‹ ëœ í¬ë¯¸í•œ ì‹ í˜¸
    - ë¼ë””ì˜¤ ì›¨ì´ë¸Œ ì‹œê°í™”
    - ë…¸ì´ì¦ˆ ì† ì–´ë¨¸ë‹ˆ ëª©ì†Œë¦¬
    - ì‹ í˜¸ ê°•ë„ ê²Œì´ì§€
    """

    PHASE_SCANNING = 10
    PHASE_SIGNAL_FOUND = 11
    PHASE_VOICE_DETECTED = 12

    def __init__(self, screen_size: tuple, mother_voice_text: str = None,
                 dialogue_after: list = None, sound_manager=None,
                 special_effects: dict = None, scene_id: str = "radio_wave_scene"):
        super().__init__(screen_size, None, dialogue_after,
                        sound_manager, special_effects, scene_id)

        self.typing_speed = 20.0

        # ë¼ë””ì˜¤ ì›¨ì´ë¸Œ ë°ì´í„°
        self.wave_data = [0.0] * 200
        self.wave_speed = 50.0
        self.signal_strength = 0.0
        self.target_signal = 0.0

        # ë…¸ì´ì¦ˆ
        self.noise_intensity = 1.0
        self.noise_particles = []
        for _ in range(100):
            self.noise_particles.append({
                'x': random.randint(0, screen_size[0]),
                'y': random.randint(0, screen_size[1]),
                'size': random.randint(1, 3),
            })

        # ì–´ë¨¸ë‹ˆ ëª©ì†Œë¦¬ í…ìŠ¤íŠ¸ (ì‹ í˜¸ì—ì„œ ì¶”ì¶œ)
        self.mother_voice_text = mother_voice_text or "...ì•„ë¥´í…Œë¯¸ìŠ¤... ì‚´ì•„ìˆë‹¤ë©´... ìš°ë¦¬ë¥¼ ì°¾ì•„..."
        self.decoded_text = ""
        self.decode_progress = 0.0

        # ìŠ¤ìº” ì£¼íŒŒìˆ˜
        self.frequency = 0.0
        self.target_frequency = 7.42  # ëª©í‘œ ì£¼íŒŒìˆ˜

        # ë°°ê²½ìƒ‰
        self.bg_color = (10, 15, 25)

        # ìƒ‰ìƒ
        self.wave_color = (0, 255, 150)
        self.signal_color = (255, 200, 50)

    def _on_fadein_complete(self):
        """í˜ì´ë“œì¸ ì™„ë£Œ"""
        self.phase = self.PHASE_SCANNING
        self.phase_timer = 0.0

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt

        # ì›¨ì´ë¸Œ ë°ì´í„° ì—…ë°ì´íŠ¸
        self.wave_data.pop(0)
        if self.phase == self.PHASE_SIGNAL_FOUND or self.phase == self.PHASE_VOICE_DETECTED:
            # ì‹ í˜¸ ê°ì§€ë¨: ê·œì¹™ì ì¸ íŒ¨í„´
            wave_value = math.sin(self.phase_timer * 10) * 0.8
            wave_value += random.uniform(-0.1, 0.1) * self.noise_intensity
        else:
            # ìŠ¤ìº” ì¤‘: ëœë¤ ë…¸ì´ì¦ˆ
            wave_value = random.uniform(-1, 1) * self.noise_intensity

        self.wave_data.append(wave_value)

        # ë…¸ì´ì¦ˆ íŒŒí‹°í´ ì—…ë°ì´íŠ¸
        if random.random() < 0.3:
            for p in self.noise_particles:
                p['x'] = random.randint(0, self.screen_size[0])
                p['y'] = random.randint(0, self.screen_size[1])

        # í˜ì´ì¦ˆ ì²˜ë¦¬
        if self.phase == self.PHASE_FADEIN:
            if self._update_fadein(dt):
                self._on_fadein_complete()

        elif self.phase == self.PHASE_SCANNING:
            # ì£¼íŒŒìˆ˜ ìŠ¤ìº”
            self.frequency += dt * 2
            if self.frequency >= self.target_frequency:
                self.phase = self.PHASE_SIGNAL_FOUND
                self.phase_timer = 0.0
                self.signal_strength = 0.3

        elif self.phase == self.PHASE_SIGNAL_FOUND:
            # ì‹ í˜¸ ê°•í™”
            self.signal_strength = min(1.0, self.signal_strength + dt * 0.3)
            self.noise_intensity = max(0.2, 1.0 - self.signal_strength)

            if self.signal_strength >= 0.8:
                self.phase = self.PHASE_VOICE_DETECTED
                self.phase_timer = 0.0

        elif self.phase == self.PHASE_VOICE_DETECTED:
            # í…ìŠ¤íŠ¸ ë””ì½”ë”©
            self.decode_progress = min(1.0, self.decode_progress + dt * 0.3)
            decoded_len = int(len(self.mother_voice_text) * self.decode_progress)
            self.decoded_text = self.mother_voice_text[:decoded_len]

            if self.decode_progress >= 1.0 and self.phase_timer > 3.0:
                self._transition_to_dialogue()

        elif self.phase == self.PHASE_DIALOGUE:
            if self._update_dialogue(dt):
                self._transition_to_fadeout()

        elif self.phase == self.PHASE_FADEOUT:
            if self._update_fadeout(dt):
                self._on_fadeout_complete()

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        screen.fill(self.bg_color)

        # ê·¸ë¦¬ë“œ ë°°ê²½
        grid_color = (30, 40, 50)
        for x in range(0, self.screen_size[0], 50):
            pygame.draw.line(screen, grid_color, (x, 0), (x, self.screen_size[1]))
        for y in range(0, self.screen_size[1], 50):
            pygame.draw.line(screen, grid_color, (0, y), (self.screen_size[0], y))

        # ë…¸ì´ì¦ˆ íŒŒí‹°í´
        for p in self.noise_particles:
            alpha = int(self.noise_intensity * 150)
            pygame.draw.rect(screen, (100, 100, 100, alpha),
                           (p['x'], p['y'], p['size'], p['size']))

        # ë¼ë””ì˜¤ ì›¨ì´ë¸Œ
        wave_height = 150
        wave_y = self.screen_size[1] // 2
        wave_width = self.screen_size[0] - 100

        points = []
        for i, val in enumerate(self.wave_data):
            x = 50 + int(i * wave_width / len(self.wave_data))
            y = wave_y + int(val * wave_height)
            points.append((x, y))

        if len(points) > 1:
            # ê¸€ë¡œìš° íš¨ê³¼
            for offset in range(3, 0, -1):
                alpha = 100 - offset * 30
                offset_points = [(p[0], p[1] + offset) for p in points]
                pygame.draw.lines(screen, (*self.wave_color[:3], alpha), False, offset_points, 2)

            pygame.draw.lines(screen, self.wave_color, False, points, 2)

        # ì£¼íŒŒìˆ˜ í‘œì‹œ
        if "medium" in self.fonts:
            freq_text = f"ì£¼íŒŒìˆ˜: {self.frequency:.2f} MHz"
            freq_surf = self.fonts["medium"].render(freq_text, True, self.wave_color)
            screen.blit(freq_surf, (50, 50))

        # ì‹ í˜¸ ê°•ë„ ê²Œì´ì§€
        gauge_x = self.screen_size[0] - 200
        gauge_y = 50
        gauge_width = 150
        gauge_height = 20

        pygame.draw.rect(screen, (50, 50, 50), (gauge_x, gauge_y, gauge_width, gauge_height))
        fill_width = int(gauge_width * self.signal_strength)
        if fill_width > 0:
            color = self.signal_color if self.signal_strength > 0.5 else self.wave_color
            pygame.draw.rect(screen, color, (gauge_x, gauge_y, fill_width, gauge_height))
        pygame.draw.rect(screen, (100, 100, 100), (gauge_x, gauge_y, gauge_width, gauge_height), 2)

        if "small" in self.fonts:
            label = self.fonts["small"].render("ì‹ í˜¸ ê°•ë„", True, (150, 150, 150))
            screen.blit(label, (gauge_x, gauge_y - 20))

        # ë””ì½”ë”©ëœ í…ìŠ¤íŠ¸
        if self.phase == self.PHASE_VOICE_DETECTED and self.decoded_text:
            if "medium" in self.fonts:
                text_y = self.screen_size[1] - 200
                # ê¸€ë¡œìš° ë°•ìŠ¤
                box_rect = pygame.Rect(50, text_y - 20, self.screen_size[0] - 100, 80)
                pygame.draw.rect(screen, (20, 30, 40, 200), box_rect, border_radius=10)
                pygame.draw.rect(screen, self.signal_color, box_rect, 2, border_radius=10)

                decoded_surf = self.fonts["medium"].render(self.decoded_text, True, self.signal_color)
                screen.blit(decoded_surf, (70, text_y))

                label = self.fonts["small"].render("ìˆ˜ì‹ ëœ ë©”ì‹œì§€:", True, (150, 150, 150))
                screen.blit(label, (70, text_y - 25))

        # ìŠ¤ìº” ì¤‘ í…ìŠ¤íŠ¸
        if self.phase == self.PHASE_SCANNING and "medium" in self.fonts:
            scan_text = "ì£¼íŒŒìˆ˜ ìŠ¤ìº” ì¤‘..."
            alpha = int(128 + 127 * math.sin(self.phase_timer * 5))
            scan_surf = self.fonts["medium"].render(scan_text, True, (*self.wave_color[:3], alpha))
            x = self.screen_size[0] // 2 - scan_surf.get_width() // 2
            screen.blit(scan_surf, (x, self.screen_size[1] - 100))

        # í˜ì´ë“œ
        if self.phase == self.PHASE_FADEIN:
            fade_surf = pygame.Surface(self.screen_size)
            fade_surf.fill((0, 0, 0))
            fade_surf.set_alpha(255 - int(self.fade_alpha))
            screen.blit(fade_surf, (0, 0))

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DIALOGUE:
            self._render_dialogue(screen)

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€í™”ì°½ ë Œë”ë§"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(15, 25, 35, 230), border_color=(0, 200, 150),
                           text_color=(200, 255, 230), box_height=180,
                           has_portrait=(portrait is not None), portrait=portrait)


class CountdownEffect(BaseCutsceneEffect):
    """
    ì¹´ìš´íŠ¸ë‹¤ìš´ ì»·ì”¬ (Act 5)

    íŠ¹ì§•:
    - ìµœì¢… ê²°ì „ ì „ ì¹´ìš´íŠ¸ë‹¤ìš´
    - ê¸´ë°•í•œ ë¶„ìœ„ê¸°
    - ìˆ«ìê°€ í™”ë©´ì— í¬ê²Œ í‘œì‹œ
    - ê° ìˆ«ìë§ˆë‹¤ íšŒìƒ/ê²°ì˜ ëŒ€ì‚¬
    """

    PHASE_COUNTDOWN = 10
    PHASE_ZERO = 11

    def __init__(self, screen_size: tuple, countdown_start: int = 10,
                 countdown_messages: list = None, dialogue_after: list = None,
                 sound_manager=None, special_effects: dict = None,
                 scene_id: str = "countdown_scene"):
        super().__init__(screen_size, None, dialogue_after,
                        sound_manager, special_effects, scene_id)

        self.typing_speed = 30.0

        # ì¹´ìš´íŠ¸ë‹¤ìš´ ì„¤ì •
        self.countdown_start = countdown_start
        self.current_count = countdown_start
        self.count_timer = 0.0
        self.count_interval = 1.5  # ê° ìˆ«ì í‘œì‹œ ì‹œê°„

        # ê° ìˆ«ìë³„ ë©”ì‹œì§€
        self.countdown_messages = countdown_messages or [
            "ëª¨ë“  ê²ƒì´ ì´ ìˆœê°„ì„ ìœ„í•´...",
            "10ë…„ì˜ ê¸°ë‹¤ë¦¼...",
            "ìƒì–´ë²„ë¦° ê²ƒë“¤ì„ ìœ„í•´...",
            "ê°€ì¡±ì„ ë˜ì°¾ê¸° ìœ„í•´...",
            "í¬ë§ì„ ì§€í‚¤ê¸° ìœ„í•´...",
            "í¬ê¸°í•˜ì§€ ì•Šì•˜ê¸°ì—...",
            "í•¨ê»˜ ì‹¸ì›Œì™”ê¸°ì—...",
            "ì´ì œ ë§ˆì§€ë§‰...",
            "ë‘ë ¤ì›€ì€ ì—†ì–´...",
            "ì‹œì‘ì´ë‹¤!",
        ]

        self.current_message = ""
        self.message_alpha = 0

        # ì‹œê° íš¨ê³¼
        self.pulse_scale = 1.0
        self.shake_offset = (0, 0)
        self.warning_flash = 0.0

        # íŒŒí‹°í´ (ë¶ˆê½ƒ)
        self.spark_particles = []

        # ë°°ê²½ ìƒ‰ìƒ (ê¸´ë°•í•œ ë¹¨ê°„ í†¤)
        self.bg_colors = [
            (20, 10, 15),  # ì‹œì‘
            (40, 15, 20),  # ì¤‘ê°„
            (60, 20, 25),  # ë
        ]

    def _on_fadein_complete(self):
        """í˜ì´ë“œì¸ ì™„ë£Œ"""
        self.phase = self.PHASE_COUNTDOWN
        self.phase_timer = 0.0
        self.current_count = self.countdown_start

    def _create_sparks(self):
        """ë¶ˆê½ƒ íŒŒí‹°í´ ìƒì„±"""
        center = (self.screen_size[0] // 2, self.screen_size[1] // 2)
        for _ in range(20):
            angle = random.uniform(0, math.pi * 2)
            speed = random.uniform(100, 300)
            self.spark_particles.append({
                'x': center[0],
                'y': center[1],
                'vx': math.cos(angle) * speed,
                'vy': math.sin(angle) * speed,
                'life': 1.0,
                'color': random.choice([(255, 200, 100), (255, 150, 50), (255, 100, 50)]),
            })

    def update(self, dt: float):
        """ì—…ë°ì´íŠ¸"""
        if not self.is_alive:
            return

        self.phase_timer += dt
        self.count_timer += dt

        # ê²½ê³  í”Œë˜ì‹œ
        self.warning_flash += dt * 10
        flash_intensity = (math.sin(self.warning_flash) + 1) / 2

        # í„ìŠ¤ íš¨ê³¼
        self.pulse_scale = 1.0 + 0.1 * math.sin(self.phase_timer * 5)

        # í™”ë©´ í”ë“¤ë¦¼ (ì¹´ìš´íŠ¸ê°€ ë‚®ì„ìˆ˜ë¡ ê°•í•´ì§)
        shake_intensity = max(0, (5 - self.current_count)) * 2
        self.shake_offset = (
            random.randint(-int(shake_intensity), int(shake_intensity)),
            random.randint(-int(shake_intensity), int(shake_intensity))
        )

        # íŒŒí‹°í´ ì—…ë°ì´íŠ¸
        for p in self.spark_particles[:]:
            p['x'] += p['vx'] * dt
            p['y'] += p['vy'] * dt
            p['vy'] += 200 * dt  # ì¤‘ë ¥
            p['life'] -= dt * 2
            if p['life'] <= 0:
                self.spark_particles.remove(p)

        # í˜ì´ì¦ˆ ì²˜ë¦¬
        if self.phase == self.PHASE_FADEIN:
            if self._update_fadein(dt):
                self._on_fadein_complete()

        elif self.phase == self.PHASE_COUNTDOWN:
            if self.count_timer >= self.count_interval:
                self.count_timer = 0
                self.current_count -= 1
                self._create_sparks()

                # ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
                msg_index = self.countdown_start - self.current_count - 1
                if 0 <= msg_index < len(self.countdown_messages):
                    self.current_message = self.countdown_messages[msg_index]
                    self.message_alpha = 255

                if self.current_count <= 0:
                    self.phase = self.PHASE_ZERO
                    self.phase_timer = 0.0

            # ë©”ì‹œì§€ í˜ì´ë“œ
            self.message_alpha = max(0, self.message_alpha - 100 * dt)

        elif self.phase == self.PHASE_ZERO:
            if self.phase_timer > 2.0:
                self._transition_to_dialogue()

        elif self.phase == self.PHASE_DIALOGUE:
            if self._update_dialogue(dt):
                self._transition_to_fadeout()

        elif self.phase == self.PHASE_FADEOUT:
            if self._update_fadeout(dt):
                self._on_fadeout_complete()

    def render(self, screen: pygame.Surface):
        """ë Œë”ë§"""
        # ë°°ê²½ ê·¸ë¼ë°ì´ì…˜ (ê¸´ë°•í•¨ ì¦ê°€)
        progress = 1 - (self.current_count / self.countdown_start) if self.countdown_start > 0 else 1
        bg_color = [
            int(self.bg_colors[0][i] + (self.bg_colors[2][i] - self.bg_colors[0][i]) * progress)
            for i in range(3)
        ]
        screen.fill(bg_color)

        # ê²½ê³  í”Œë˜ì‹œ ì˜¤ë²„ë ˆì´
        flash_intensity = (math.sin(self.warning_flash) + 1) / 2
        if self.current_count <= 3:
            flash_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
            flash_surf.fill((100, 20, 20, int(flash_intensity * 50)))
            screen.blit(flash_surf, (0, 0))

        # ì›í˜• ì›¨ì´ë¸Œ (ìˆ«ì ì£¼ë³€)
        center = (self.screen_size[0] // 2 + self.shake_offset[0],
                 self.screen_size[1] // 2 + self.shake_offset[1])

        wave_radius = int(100 + (self.count_timer / self.count_interval) * 200)
        wave_alpha = int(100 * (1 - self.count_timer / self.count_interval))
        if wave_alpha > 0:
            for r in range(wave_radius, wave_radius - 20, -5):
                if r > 0:
                    alpha = int(wave_alpha * (1 - (wave_radius - r) / 20))
                    pygame.draw.circle(screen, (255, 100, 100, alpha), center, r, 2)

        # ì¹´ìš´íŠ¸ë‹¤ìš´ ìˆ«ì
        if self.phase in [self.PHASE_COUNTDOWN, self.PHASE_ZERO]:
            count_text = str(max(0, self.current_count))
            if "xlarge" in self.fonts:
                font = self.fonts["xlarge"]
            elif "large" in self.fonts:
                font = self.fonts["large"]
            else:
                font = pygame.font.Font(None, 200)

            # ê¸€ë¡œìš° íš¨ê³¼
            for glow_offset in range(10, 0, -2):
                glow_color = (255, 100 + glow_offset * 10, 100 + glow_offset * 10)
                glow_surf = font.render(count_text, True, glow_color)
                glow_surf.set_alpha(50 - glow_offset * 4)

                scaled_size = (int(glow_surf.get_width() * self.pulse_scale),
                              int(glow_surf.get_height() * self.pulse_scale))
                scaled = pygame.transform.smoothscale(glow_surf, scaled_size)

                x = center[0] - scaled.get_width() // 2
                y = center[1] - scaled.get_height() // 2 - 50
                screen.blit(scaled, (x, y))

            # ë©”ì¸ ìˆ«ì
            number_surf = font.render(count_text, True, (255, 220, 200))
            scaled_size = (int(number_surf.get_width() * self.pulse_scale),
                          int(number_surf.get_height() * self.pulse_scale))
            scaled = pygame.transform.smoothscale(number_surf, scaled_size)

            x = center[0] - scaled.get_width() // 2
            y = center[1] - scaled.get_height() // 2 - 50
            screen.blit(scaled, (x, y))

        # ë©”ì‹œì§€
        if self.current_message and self.message_alpha > 0:
            if "medium" in self.fonts:
                msg_surf = self.fonts["medium"].render(self.current_message, True, (255, 230, 200))
                msg_surf.set_alpha(int(self.message_alpha))
                x = center[0] - msg_surf.get_width() // 2
                y = center[1] + 100
                screen.blit(msg_surf, (x, y))

        # ë¶ˆê½ƒ íŒŒí‹°í´
        for p in self.spark_particles:
            alpha = int(255 * p['life'])
            size = int(3 * p['life'])
            if size > 0:
                spark_surf = pygame.Surface((size * 2, size * 2), pygame.SRCALPHA)
                pygame.draw.circle(spark_surf, (*p['color'], alpha), (size, size), size)
                screen.blit(spark_surf, (int(p['x']) - size, int(p['y']) - size))

        # PHASE_ZERO íŠ¹ë³„ íš¨ê³¼
        if self.phase == self.PHASE_ZERO:
            # í™”ë©´ ì „ì²´ í”Œë˜ì‹œ
            flash_progress = min(1.0, self.phase_timer / 0.5)
            if flash_progress < 1.0:
                flash_surf = pygame.Surface(self.screen_size, pygame.SRCALPHA)
                flash_surf.fill((255, 255, 255, int(255 * (1 - flash_progress))))
                screen.blit(flash_surf, (0, 0))

            # "ì „íˆ¬ ê°œì‹œ" í…ìŠ¤íŠ¸
            if self.phase_timer > 0.5 and "large" in self.fonts:
                battle_text = "ì „íˆ¬ ê°œì‹œ"
                battle_surf = self.fonts["large"].render(battle_text, True, (255, 200, 150))
                x = center[0] - battle_surf.get_width() // 2
                y = center[1] - battle_surf.get_height() // 2 - 50
                screen.blit(battle_surf, (x, y))

        # í˜ì´ë“œ
        if self.phase == self.PHASE_FADEIN:
            fade_surf = pygame.Surface(self.screen_size)
            fade_surf.fill((0, 0, 0))
            fade_surf.set_alpha(255 - int(self.fade_alpha))
            screen.blit(fade_surf, (0, 0))

        # ëŒ€ì‚¬
        if self.phase == self.PHASE_DIALOGUE:
            self._render_dialogue(screen)

    def _render_dialogue(self, screen: pygame.Surface):
        """ëŒ€í™”ì°½ ë Œë”ë§"""
        if not self.dialogue_after or self.current_dialogue_index >= len(self.dialogue_after):
            return
        dialogue = self.dialogue_after[self.current_dialogue_index]
        speaker = dialogue.get("speaker", "")
        portrait = self._get_portrait(speaker) if speaker else None

        render_dialogue_box(screen, self.screen_size, self.fonts, dialogue,
                           self.dialogue_text, self.typing_progress, self.waiting_for_click,
                           box_color=(40, 20, 25, 230), border_color=(255, 150, 100),
                           text_color=(255, 240, 230), box_height=180,
                           has_portrait=(portrait is not None), portrait=portrait)
